<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sword1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sword2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhahr.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:type" content="website">
<meta property="og:title" content="HahのBlog">
<meta property="og:url" content="http://rhahr.top/index.html">
<meta property="og:site_name" content="HahのBlog">
<meta property="og:description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rhahr.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HahのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Jenwein" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HahのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/10/29/OpenGL-D3-%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/29/OpenGL-D3-%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">设置顶点属性与编写着色器</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-29 22:00:00 / 修改时间：22:08:54" itemprop="dateCreated datePublished" datetime="2024-10-29T22:00:00+08:00">2024-10-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/Cherno/" itemprop="url" rel="index"><span itemprop="name">Cherno</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h2><h3 id="什么是顶点属性？"><a href="#什么是顶点属性？" class="headerlink" title="什么是顶点属性？"></a>什么是顶点属性？</h3><p><strong>顶点属性</strong>（Vertex Attribute）在计算机图形学中，是指用来描述一个顶点特征的数据。这些数据可以是位置、颜色、法线、纹理坐标等等。简单来说，就是用来定义一个顶点在三维空间中的属性，以及它在渲染过程中应该如何被处理</p>
<p>在之前的内容中已经创建了顶点缓冲区，也就是用来存放CPU传过来的顶点数据的缓冲区，有了数据，还需要告诉OpenGL如何解释这些数据，就需要用方法<code>	glVertexAttribPointer</code></p>
<p>如果顶点只有位置属性，那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = &#123;</span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(GL_FLOAT) * <span class="number">2</span>, (<span class="type">const</span> <span class="type">void</span>*)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？layout就是这里的顶点属性的标号，对应position中的顶点，从前到后为位置，颜色，纹理，所以分别为0，1，2</p>
</li>
<li><p>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</p>
</li>
<li><p>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</p>
</li>
<li><p>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</p>
</li>
<li><p>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>float</code>之后，我们把步长设置为<code>3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</p>
</li>
<li><p>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</p>
<p><img src="https://learnopengl-cn.github.io/img/01/06/vertex_attribute_pointer_interleaved_textures.png" alt="img"></p>
</li>
</ul>
<p>如果有其他属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">		<span class="comment">//位置			    //颜色             //纹理    </span></span><br><span class="line">		<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">1.0f</span>,     <span class="comment">// 右上角</span></span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">0.0f</span>,     <span class="comment">// 右下角</span></span><br><span class="line">	   <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>,<span class="number">0.0f</span>,     <span class="comment">// 左下角</span></span><br><span class="line">	   <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">1.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>设置顶点属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">8</span>, (<span class="type">const</span> <span class="type">void</span>*)<span class="number">0</span>);	<span class="comment">//positon</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">8</span>, (<span class="type">const</span> <span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));	<span class="comment">//color</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">8</span>, (<span class="type">const</span> <span class="type">void</span>*)(<span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));	<span class="comment">//color</span></span><br></pre></td></tr></table></figure>

<h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>现在准备数据的事情都准备的差不多了，总结一下之前做了什么，有一个代表顶点位置的数组，创建了一个VBO用来存放CPU传过来的数据，并初始化VBO的数据为顶点位置的数据，然后设置顶点属性，告诉OpenGL以何种方式来读取数据，现在可以来编写着色器了。</p>
<p>要把着色器代码变为着色器程序，类似于C++的程序的执行过程，同样需要编译链接，所以先来写一个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">createShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个着色器程序</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	<span class="comment">//编译着色器代码</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">compileShader</span>(GL_VERTEX_SHADER, vertexShader);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">compileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将得到的着色器代码文件附加到程序上</span></span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链接程序</span></span><br><span class="line">	<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除中间文件</span></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vs);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建一个程序，然后编译着色器代码，编译后得到的vs和fs可以看作两个文件，将两个文件附加在program上后，链接程序，程序成功链接之后，就获得了一个可以执行的程序，之前的中间文件就不再需要可以直接删除。</p>
<p>编译代码的部分重复较多，再抽象出一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译着色器代码</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">compileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建着色器</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//指定着色器源码（将源代码加载到着色器对象中）</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="built_in">glShaderSource</span>(id, <span class="number">1</span>, &amp;src, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//id：指定要加载源代码的着色器对象的ID。1：表示只有一个字符串。</span></span><br><span class="line">    <span class="comment">//&amp;src：指向包含着色器源代码的字符串。nullptr：表示字符串以空字符结尾。</span></span><br><span class="line">	<span class="comment">//编译着色器代码</span></span><br><span class="line">	<span class="built_in">glCompileShader</span>(id);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//错误处理</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="built_in">glGetShaderiv</span>(id, GL_COMPILE_STATUS, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">		<span class="type">char</span>* message = (<span class="type">char</span>*)<span class="built_in">alloca</span>(length*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">		<span class="comment">//char* message = new char[length];</span></span><br><span class="line">		<span class="built_in">glGetShaderInfoLog</span>(id, length, &amp;length, message);</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to compile &quot;</span> &lt;&lt; (type == GL_VERTEX_SHADER ? <span class="string">&quot;vertex&quot;</span> : <span class="string">&quot;fragment&quot;</span>) &lt;&lt; <span class="string">&quot; shader! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>着色器代码的编译链接已经完成，现在可以着手着色器代码本身，着色器代码（GLSL）。GLSL需要记住之前提到的，着色器接收一个输入得到一个输出给下一个阶段，所以通过in接收上一阶段的数据处理，之后将结果通过out输出到下一阶段，下一阶段可以通过in来获取这个输出作为本阶段的输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//编写着色器源码</span></span><br><span class="line">	std::string vertexShader = </span><br><span class="line"><span class="string">R&quot;(#version 330 core				</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec4 aPos;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    gl_Position = aPos;</span></span><br><span class="line"><span class="string">&#125;	</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	std::string fragmentShader = </span><br><span class="line"><span class="string">R&quot;(#version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 FragColor;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语法细节：（待补充）</p>
<p>准备工作完成，最后开始使用代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译着色器，通过编译链接vs和fs的源码，得到最终的着色器程序</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">createShader</span>(vertexShader,fragmentShader);</span><br><span class="line"><span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteProgram</span>(shader);	<span class="comment">//回收资源</span></span><br></pre></td></tr></table></figure>

<p>不出意外的得到了一个大红色的三角形。</p>
<p><img src="http://cdn.rhahr.asia/43bbc9affcedeeba559d48327483301.png"></p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/10/25/OpenGL-D2-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/25/OpenGL-D2-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/" class="post-title-link" itemprop="url">顶点缓冲区与着色器</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-25 22:00:00" itemprop="dateCreated datePublished" datetime="2024-10-25T22:00:00+08:00">2024-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-29 22:08:47" itemprop="dateModified" datetime="2024-10-29T22:08:47+08:00">2024-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/Cherno/" itemprop="url" rel="index"><span itemprop="name">Cherno</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
</blockquote>
<p>OpenGL的工作主要负责将3D空间坐标转换为屏幕的2D像素，3D坐标转换到2D的过程叫做<strong>PipeLine</strong>，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</p>
<blockquote>
<p>2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕&#x2F;窗口分辨率的限制。</p>
</blockquote>
<p>渲染管线就是GPU执行的这个流水线，通过CPU将数据在应用阶段传送给GPU后，通过渲染管线的每个阶段，每个阶段都接收一个输入，产出一个输出，这些输入输出就是需要被渲染的顶点数据，输出数据给下一个阶段处理。</p>
<blockquote>
<p>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。<strong>OpenGL着色器是用OpenGL着色器语言</strong></p>
</blockquote>
<p><img src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="img"></p>
<h2 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h2><p>顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而这样一个顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据</p>
<blockquote>
<p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：</p>
<ul>
<li>GL_POINTS</li>
<li>GL_TRIANGLES</li>
<li>GL_LINE_STRIP</li>
</ul>
</blockquote>
<h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>怎么理解着色器，着色器就是渲染管线中的每个阶段运行的各自的小程序，下面简要介绍各个阶段的功能</p>
<p>图形渲染管线的第一个部分是**&#x3D;&#x3D;顶点着色器&#x3D;&#x3D;**(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p>顶点着色器阶段的输出可以选择性地传递给<strong>几何着色器</strong>(Geometry Shader)。几何着色器将一组顶点作为输入，这些顶点形成图元，并且能够通过发出新的顶点来形成新的(或其他)图元来生成其他形状。在这个例子中，它从给定的形状中生成第二个三角形。</p>
<p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器（或几何着色器）输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状；本节例子中是两个三角形。</p>
<p>图元装配阶段的输出会被传入<strong>光栅化阶段</strong>(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
</blockquote>
<p>**&#x3D;&#x3D;片段着色器&#x3D;&#x3D;**的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<ul>
<li>为每个像素&#x2F;片段运行片段着色器并且他们决定了颜色输出，顶点着色器为每个顶点运行，他们决定了屏幕上的位置。</li>
</ul>
<h2 id="顶点缓冲区-VB"><a href="#顶点缓冲区-VB" class="headerlink" title="顶点缓冲区-VB"></a>顶点缓冲区-VB</h2><p><em>OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理它。所有在这个范围内的坐标叫做标准化设备坐标(Normalized Device Coordinates)，此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）</em></p>
<ul>
<li><p>指定坐标时，一般有三个点，<code>x,y,z</code> 这个z指的时深度，也就是在右手坐标系中，z轴指向屏幕外的方向，z就相当于离你的距离，如果离得远可能被别的像素遮挡，就会被丢弃&#x2F;裁剪来节省资源。</p>
</li>
<li><p>顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃&#x2F;裁剪，不会显示在你的屏幕上。</p>
</li>
</ul>
<p>光栅化阶段中，在使用<code>glViewPort</code>函数指定视口后，通过视口变换之后，NDC会变换为屏幕空间坐标。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> position[<span class="number">6</span>] = &#123;</span><br><span class="line">		<span class="number">-0.5f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">		<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">		 <span class="number">0.5f</span>,  <span class="number">0.5f</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>定义顶点数据后，顶点着色器接收这些数据，在GPU上创建内存用于存储顶点数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----用于将顶点数据上传GPU----*/</span></span><br><span class="line"><span class="comment">//GLenum -- 理解为slot</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;					<span class="comment">//存储生成的缓冲区对象的ID</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);				<span class="comment">//生成1个缓冲区，将ID存储在buffer变量中</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,buffer);	<span class="comment">//绑定缓冲区对象到当前的OpenGL上下文中的GL_ARRAY_BUFFER上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(position), position, GL_STATIC_DRAW);	<span class="comment">//为绑定到GL_ARRAY_BUFFER的缓冲区对象分配内存并初始化数据</span></span><br></pre></td></tr></table></figure>

<p>这里的buffer也就是所谓的VBO顶点缓冲对象，这四行就是VBO的初始化，通过Genbuffer生成带有ID的缓冲区，ID给Buffer，通过bind绑定为GL_ARRAY_BUFFER的缓存类型。</p>
<blockquote>
<p>OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型.</p>
<p>这里就可以直接把缓存类型当作某种插槽，也就是说可以将VBO同时插在多个插槽里</p>
</blockquote>
<p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中</p>
<blockquote>
<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>
</blockquote>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/10/22/OpenGL-D1-%E5%88%9D%E5%A7%8B%E9%9C%80%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/10/22/OpenGL-D1-%E5%88%9D%E5%A7%8B%E9%9C%80%E8%A6%81/" class="post-title-link" itemprop="url">开始之前</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-22 22:00:00 / 修改时间：18:54:29" itemprop="dateCreated datePublished" datetime="2024-10-22T22:00:00+08:00">2024-10-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/Cherno/" itemprop="url" rel="index"><span itemprop="name">Cherno</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h1><p>配置好glfw和glew&#x2F;glad之后，仍需要一些初始环境，首先需要在main中实例化GLFW的窗口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();		<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//配置GLFW</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);	</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是初始化GLFW的内容，然后创建一个窗口对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(window);</span><br></pre></td></tr></table></figure>

<p>然后初始化GLAD&#x2F;GLEW,之后就可以使用OpenGL的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLEW</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glewInit</span>() != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//GLAD</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>Viewport，定义渲染输出的区域，视口将窗口坐标映射到裁剪空间坐标，从而决定了渲染内容在窗口中的显示位置和大小，在开始渲染之前需要指定，可以将视口的维度设置的小于GLFW的维度，这样实际渲染的内容将在更小的窗口内，这样就可以将一些其他元素显示在OpenGL视口之外,默认则是整个GLFW。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glViewport(0, 0, 800, 600);</span><br></pre></td></tr></table></figure>

<p>视口需要会随着窗口大小改变，所以可以对窗口注册一个回调函数来处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在函数中定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> viewportwidth = width - <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, viewportwidth, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以注册这个回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure>

<p>当窗口被第一次显示的时候framebuffer_size_callback也会被调用</p>
<p>设置视口是有必要的，如果没有设置视口，那么拖动窗口的效果将是</p>
<p><img src="http://cdn.rhahr.asia/7fae48ba00e94e61e06bd095d3da130.png"></p>
<p>设置视口之后：</p>
<p><img src="http://cdn.rhahr.asia/ef99e4ff8435c34e2bc4997cb64593e.png"></p>
<p>效果很明显，视口定义了窗口坐标到裁剪空间坐标的映射关系。如果不设置视口，当窗口大小改变时，OpenGL仍然使用初始的视口设置，这会导致渲染内容无法正确适应新的窗口尺寸，从而出现内容缺失或变形的情况。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>之前的都只是设置窗口，设置显示，设置GLFW，接下来为渲染做准备工作。图形渲染需要一个RenderLoop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Render here */</span></span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">//每个渲染迭代钱总是清屏</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);<span class="comment">//交换颜色缓冲</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Poll for and process events */</span></span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();<span class="comment">//检查有没有触发事件/更新窗口状态/调用回调</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="事后"><a href="#事后" class="headerlink" title="事后"></a>事后</h2><p>渲染循环结束后我们需要正确释放&#x2F;删除之前的分配的所有资源。我们可以在main函数的最后调用glfwTerminate函数来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwTerminate</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>希望能够在GLFW中实现一些输入控制，这可以通过使用GLFW的几个输入函数来完成。我们将会使用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个processInput函数来让所有的输入代码保持整洁。</p>
<p>比如，想要在按下<code>esc</code>之后退出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window,GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);		<span class="comment">//设置关闭状态为true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后只需要在循环内调用该函数即可。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>将所有的渲染操作放在渲染循环中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染循环</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染指令</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/</a></p>
</blockquote>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/25/C++%E9%9D%A2%E8%AF%95100%E9%97%AE1-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/25/C++%E9%9D%A2%E8%AF%95100%E9%97%AE1-10/" class="post-title-link" itemprop="url">面试100问01</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-09-25 12:00:00 / 修改时间：08:56:42" itemprop="dateCreated datePublished" datetime="2024-09-25T12:00:00+08:00">2024-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="include双引号和尖括号的区别"><a href="#include双引号和尖括号的区别" class="headerlink" title="include双引号和尖括号的区别"></a>include双引号和尖括号的区别</h1><p>在C++中，<code>#include</code>指令使用双引号（<code>&quot;&quot;</code>）和尖括号（<code>&lt;&gt;</code>）的区别主要在于编译器搜索头文件的路径：</p>
<ol>
<li>**尖括号 (&lt;&gt;)**：<ul>
<li>编译器会在标准库路径中搜索头文件。这些路径通常包含系统提供的头文件和编译器自带的标准库文件。</li>
<li>例如，<code>#include &lt;iostream&gt;</code> 会让编译器在标准库路径中查找 <code>iostream</code> 头文件。</li>
</ul>
</li>
<li>**双引号 (“”)**：<ul>
<li>编译器首先会在当前源文件所在的目录中搜索头文件。如果在当前目录中找不到，才会转而在标准库路径中搜索。</li>
<li>例如，<code>#include &quot;my_header.h&quot;</code> 会让编译器先在当前目录中查找 <code>my_header.h</code>，如果找不到，再去标准库路径中查找。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://dev.devbf.com/posts/angle-brackets-or-double-quotes-which-should-you-use-in-c-includes-3e464/">这种区别的目的是为了区分标准库头文件和项目自定义头文件，确保编译器能够正确找到并包含所需的头文件</a><a target="_blank" rel="noopener" href="https://dev.devbf.com/posts/angle-brackets-or-double-quotes-which-should-you-use-in-c-includes-3e464/">1</a><a target="_blank" rel="noopener" href="https://www.daniweb.com/programming/software-development/threads/359946/include-vs-include">2</a><a target="_blank" rel="noopener" href="https://www.rightreaders.com/what-is-the-difference-between-using-angle-brackets-and-quotes-in-an-include-directive-include-include-filename/">3</a>。</p>
<hr>
<p>双引号是优先查找当前项目中的文件，是属于本项目的文件，如果查找不到，再去<strong>标准库路径</strong>查找，而尖括号只在外部查找</p>
<h1 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h1><p><code>const</code> 关键字在 C++ 中用于声明常量，表示变量的值在初始化后不能被修改。它可以用于变量、指针、函数参数和成员函数等多种场景。</p>
<h3 id="1-常量变量"><a href="#1-常量变量" class="headerlink" title="1. 常量变量"></a>1. 常量变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_value = <span class="number">100</span>; max_value = <span class="number">200</span>; </span><br><span class="line"><span class="comment">// 错误，不能修改常量变量的值 </span></span><br></pre></td></tr></table></figure>

<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h3><ul>
<li><p><strong>指向常量的指针</strong>：指针指向的值不能被修改。</p>
<p><code>const int *ptr = &amp;max_value; *ptr = 200; // 错误，不能修改指向的值 ptr = &amp;another_value; // 正确，可以修改指针本身 </code></p>
</li>
<li><p><strong>常量指针</strong>：指针本身不能被修改，但指向的值可以被修改。</p>
<p><code>int *const ptr = &amp;max_value; *ptr = 200; // 正确，可以修改指向的值 ptr = &amp;another_value; // 错误，不能修改指针本身 </code></p>
</li>
<li><p><strong>指向常量的常量指针</strong>：指针本身和指向的值都不能被修改。</p>
<p><code>const int *const ptr = &amp;max_value; *ptr = 200; // 错误，不能修改指向的值 ptr = &amp;another_value; // 错误，不能修改指针本身 </code></p>
</li>
</ul>
<h3 id="3-常量函数参数"><a href="#3-常量函数参数" class="headerlink" title="3. 常量函数参数"></a>3. 常量函数参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">// value 不能被修改     </span></span><br><span class="line">	std::cout &lt;&lt; value &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="4-常量成员函数"><a href="#4-常量成员函数" class="headerlink" title="4. 常量成员函数"></a>4. 常量成员函数</h3><p>常量成员函数不能修改对象的成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 正确，常量成员函数可以访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        value = val; <span class="comment">// 正确，非常量成员函数可以修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>const</code> 关键字可以提高代码的安全性和可读性，防止意外修改数据。</p>
<h1 id="常量指针和指针常量分别是什么意思"><a href="#常量指针和指针常量分别是什么意思" class="headerlink" title="常量指针和指针常量分别是什么意思"></a>常量指针和指针常量分别是什么意思</h1><p>在C++中，常量指针和指针常量是两个不同的概念，尽管它们的名称听起来很相似。以下是它们的区别：</p>
<ol>
<li><strong>常量指针（Pointer to Constant）</strong>：<ul>
<li>定义形式：<code>const 数据类型 *指针变量名</code> 或 <code>数据类型 const *指针变量名</code></li>
<li>含义：指针指向的内容是常量，不能通过该指针修改内容，但指针本身可以指向其他地址。</li>
<li>例子：<code>const int *p; int a = 10; p = &amp;a;  // 允许 *p = 20; // 错误，不能修改指向内容 </code></li>
</ul>
</li>
<li><strong>指针常量（Constant Pointer）</strong>：<ul>
<li>定义形式：<code>数据类型 *const 指针变量名</code></li>
<li>含义：指针本身是常量，不能改变指向的地址，但可以通过指针修改指向地址的内容。</li>
<li>例子：<code>int *const p = &amp;a; int a = 10; *p = 20; // 允许，修改指向内容 int b = 30; p = &amp;b;  // 错误，不能改变指向地址 </code></li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo_dm/article/details/80445205">总结来说，<strong>常量指针</strong>限制的是指针指向的内容，而<strong>指针常量</strong>限制的是指针本身的地址</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo_dm/article/details/80445205">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337321951">2</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88+vs+%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F">3</a>。</p>
<hr>
<p>常量指针是指常量的指针，表示这个量是常量，不可被改变，但是指针的指向可以修改。</p>
<p>指针常量表示这个指针本身是常量，意思这个指针不可被修改，但是指向的内容可以被修改</p>
<h1 id="C-常用新特性有哪些，举例说明"><a href="#C-常用新特性有哪些，举例说明" class="headerlink" title="C++常用新特性有哪些，举例说明"></a>C++常用新特性有哪些，举例说明</h1><p>C++近年来引入了许多新特性，以下是一些常用且重要的特性及其示例：</p>
<h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><ol>
<li><p><strong>自动类型推导（auto）</strong></p>
</li>
<li><p><strong>范围for循环</strong>：</p>
<p><strong>范围for循环</strong></p>
</li>
<li><p><strong>lambda表达式</strong>：</p>
<p><code>auto add =  &#123; return a + b; &#125;; std::cout &lt;&lt; add(2, 3); // 输出 5 </code></p>
</li>
</ol>
<h3 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h3><ol>
<li><p><strong>泛型lambda</strong>：</p>
<p><code>auto add =  &#123; return a + b; &#125;; </code></p>
<p> <code>std::cout &lt;&lt; add(2, 3); // 输出 5 </code></p>
<p> <code>std::cout &lt;&lt; add(2.5, 3.5); // 输出 6.0 </code> </p>
</li>
<li><p><strong>二进制字面量</strong>：</p>
<p><code>int binary = 0b1010; // binary 的值是 10 </code></p>
</li>
</ol>
<h3 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h3><ol>
<li><p><strong>结构化绑定</strong>：</p>
<p><code>std::tuple&lt;int, double, std::string&gt; t(1, 2.3, &quot;hello&quot;); </code></p>
<p> <code>auto [i, d, s] = t; </code></p>
<p> <code>std::cout &lt;&lt; i &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; &quot;, &quot; &lt;&lt; s; // 输出 1, 2.3, hello </code> </p>
</li>
<li><p><strong>if constexpr</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> [i, d, s] = t;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s; <span class="comment">// 输出 1, 2.3, hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::optional</strong>：</p>
<p><code>std::optional&lt;int&gt; opt; if (!opt) &#123;     opt = 42; &#125; std::cout &lt;&lt; *opt; // 输出 42 </code></p>
</li>
</ol>
<h3 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h3><ol>
<li><p><strong>协程（coroutines）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReturnObject</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="function">ReturnObject <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_never <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ReturnObject <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">    <span class="keyword">co_await</span> std::suspend_always&#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>概念（concepts）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 输出 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cppstories.com/2017/01/cpp17features/">这些新特性大大增强了C++的表达能力和代码简洁性，帮助开发者编写更高效和可维护的代码</a><a target="_blank" rel="noopener" href="https://www.cppstories.com/2017/01/cpp17features/">1</a><a target="_blank" rel="noopener" href="https://github.com/AnthonyCalandra/modern-cpp-features/blob/master/CPP17.md">2</a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/features-of-c17-with-examples/">3</a>。</p>
<h1 id="智能指针的使用有什么坑"><a href="#智能指针的使用有什么坑" class="headerlink" title="智能指针的使用有什么坑"></a>智能指针的使用有什么坑</h1><p>在C++中，智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>）极大地简化了内存管理，但在使用过程中仍有一些常见的坑需要注意：</p>
<h3 id="1-不必要地使用std-shared-ptr"><a href="#1-不必要地使用std-shared-ptr" class="headerlink" title="1. 不必要地使用std::shared_ptr"></a>1. 不必要地使用<code>std::shared_ptr</code></h3><p><strong>问题</strong>：在不需要共享所有权的情况下使用<code>std::shared_ptr</code>，会导致不必要的性能开销，因为<code>std::shared_ptr</code>需要维护引用计数。</p>
<p><a target="_blank" rel="noopener" href="https://acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/"><strong>建议</strong>：默认使用<code>std::unique_ptr</code>，只有在确实需要共享所有权时才使用<code>std::shared_ptr</code></a><a target="_blank" rel="noopener" href="https://acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/">1</a>。</p>
<p>在lambda中可以通过传入shared_from_this()的指针来保证std::shared_ptr的存活，是一种伪闭包的实现</p>
<h3 id="2-循环引用"><a href="#2-循环引用" class="headerlink" title="2. 循环引用"></a>2. 循环引用</h3><p><strong>问题</strong>：两个或多个<code>std::shared_ptr</code>相互引用，导致内存泄漏，因为引用计数永远不会归零。</p>
<p><strong>解决方案</strong>：使用<code>std::weak_ptr</code>打破循环引用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    std::weak_ptr&lt;Node&gt; prev; <span class="comment">// 使用 weak_ptr 打破循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-多线程环境中的线程安全问题"><a href="#3-多线程环境中的线程安全问题" class="headerlink" title="3. 多线程环境中的线程安全问题"></a>3. 多线程环境中的线程安全问题</h3><p><strong>问题</strong>：<code>std::shared_ptr</code>本身是线程安全的，但它管理的对象并不是。如果多个线程同时访问和修改对象，可能会导致数据竞争。</p>
<p><a target="_blank" rel="noopener" href="https://acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/"><strong>建议</strong>：在多线程环境中，使用适当的同步机制（如互斥锁）来保护共享资源</a><a target="_blank" rel="noopener" href="https://acodersjourney.com/top-10-dumb-mistakes-avoid-c-11-smart-pointers/">1</a>。</p>
<h3 id="4-自定义删除器的使用"><a href="#4-自定义删除器的使用" class="headerlink" title="4. 自定义删除器的使用"></a>4. 自定义删除器的使用</h3><p><strong>问题</strong>：在使用自定义删除器时，可能会忘记正确处理资源释放，导致资源泄漏。</p>
<p><strong>建议</strong>：确保自定义删除器正确释放资源。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">filePtr</span><span class="params">(fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>), &amp;fclose)</span></span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-不要混用原始指针和智能指针"><a href="#5-不要混用原始指针和智能指针" class="headerlink" title="5. 不要混用原始指针和智能指针"></a>5. 不要混用原始指针和智能指针</h3><p><strong>问题</strong>：混用原始指针和智能指针可能导致双重释放或未定义行为。</p>
<p><strong>建议</strong>：一旦使用智能指针管理资源，就不要再使用原始指针。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 不要再使用原始指针来管理同一资源 </span></span><br></pre></td></tr></table></figure>

<h3 id="6-避免在容器中直接存储智能指针"><a href="#6-避免在容器中直接存储智能指针" class="headerlink" title="6. 避免在容器中直接存储智能指针"></a>6. 避免在容器中直接存储智能指针</h3><p><strong>问题</strong>：在容器中直接存储智能指针可能导致意外的资源管理问题。</p>
<p><a target="_blank" rel="noopener" href="https://dev.to/jaehyun_park_52/understanding-smart-pointers-in-c-7g9"><strong>建议</strong>：尽量使用容器的智能指针版本（如<code>std::vector&gt;</code>）来管理资源</a><a target="_blank" rel="noopener" href="https://dev.to/jaehyun_park_52/understanding-smart-pointers-in-c-7g9">2</a>。</p>
<h3 id="7-使用std-make-shared和std-make-unique"><a href="#7-使用std-make-shared和std-make-unique" class="headerlink" title="7. 使用std::make_shared和std::make_unique"></a>7. 使用<code>std::make_shared</code>和<code>std::make_unique</code></h3><p><strong>问题</strong>：直接使用<code>new</code>创建对象并赋值给智能指针，可能会导致异常安全问题。</p>
<p><strong>建议</strong>：使用<code>std::make_shared</code>和<code>std::make_unique</code>来创建智能指针，确保异常安全。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="keyword">auto</span> uniquePtr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>); </span><br></pre></td></tr></table></figure>

<p>这些是使用智能指针时需要注意的一些常见问题和建议。希望这些信息对你有帮助！如果你有更多问题或需要进一步的解释，请随时告诉我。</p>
<h1 id="什么是内存泄漏，有哪几种，怎么解决"><a href="#什么是内存泄漏，有哪几种，怎么解决" class="headerlink" title="什么是内存泄漏，有哪几种，怎么解决"></a>什么是内存泄漏，有哪几种，怎么解决</h1><p>内存泄漏是指程序在动态分配内存后未能正确释放，导致这些内存无法被重新分配和使用。内存泄漏会导致程序占用越来越多的内存，最终可能导致系统性能下降或程序崩溃。</p>
<p>内存泄漏是指程序在动态分配内存后未能正确释放，导致内存无法被重新分配和使用。内存泄漏会导致程序占用越来越多的内存，最终可能导致系统崩溃或性能严重下降。</p>
<h3 id="内存泄漏的几种类型"><a href="#内存泄漏的几种类型" class="headerlink" title="内存泄漏的几种类型"></a>内存泄漏的几种类型</h3><ol>
<li><strong>堆内存泄漏</strong>：这是最常见的内存泄漏类型，发生在使用 <code>new</code> 或 <code>malloc</code> 分配内存后未能使用 <code>delete</code> 或 <code>free</code> 释放内存。</li>
<li><strong>全局内存泄漏</strong>：全局变量或静态变量在程序结束前未能释放内存。</li>
<li><strong>栈内存泄漏</strong>：虽然栈内存通常由编译器自动管理，但在某些情况下（如递归调用过深），也可能导致内存泄漏。</li>
<li><strong>资源泄漏</strong>：不仅限于内存，还包括文件句柄、网络连接等资源未能正确释放。</li>
</ol>
<h3 id="解决内存泄漏的方法"><a href="#解决内存泄漏的方法" class="headerlink" title="解决内存泄漏的方法"></a>解决内存泄漏的方法</h3><ol>
<li><strong>手动管理内存</strong>：确保每次使用 <code>new</code> 或 <code>malloc</code> 分配内存后，都有相应的 <code>delete</code> 或 <code>free</code> 释放内存。</li>
<li><strong>使用智能指针</strong>：C++11 引入了智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），可以自动管理内存，减少内存泄漏的风险。</li>
<li><a target="_blank" rel="noopener" href="https://www.pullrequest.com/blog/the-art-of-detecting-memory-leaks-in-c-applications/"><strong>工具检测</strong>：使用工具如 Valgrind、AddressSanitizer 或 Visual Studio 的内存分析工具来检测和修复内存泄漏</a><a target="_blank" rel="noopener" href="https://www.pullrequest.com/blog/the-art-of-detecting-memory-leaks-in-c-applications/">1</a><a target="_blank" rel="noopener" href="https://www.codewithc.com/memory-leaks-in-pointers/">2</a><a target="_blank" rel="noopener" href="https://codeknowcode.com/understanding-memory-leaks-in-c-detection-prevention-and-best-practices/">3</a>。</li>
<li><strong>代码审查和测试</strong>：通过代码审查和单元测试，尽早发现和修复内存泄漏问题。</li>
</ol>
<h1 id="new-x2F-delete与malloc-x2F-free的区别是什么"><a href="#new-x2F-delete与malloc-x2F-free的区别是什么" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的区别是什么"></a>new&#x2F;delete与malloc&#x2F;free的区别是什么</h1><h1 id="引用作为函数的参数或者返回值好处在哪里"><a href="#引用作为函数的参数或者返回值好处在哪里" class="headerlink" title="引用作为函数的参数或者返回值好处在哪里"></a>引用作为函数的参数或者返回值好处在哪里</h1><p><strong>引用就是某一变量（目标）的别名，对引用的操作与对变量直接操作完全一样。</strong> </p>
<p><strong>引用作为函数参数</strong> </p>
<p>引用传参的好处： </p>
<ol>
<li><p>在函数内部会对此参数进行修改 </p>
</li>
<li><p>提高函数调用和运行效率</p>
</li>
</ol>
<p><strong>引用作为函数返回值</strong></p>
<ol>
<li><p>以引用返回函数值，定义函数时需要在函数名前加 &amp; </p>
</li>
<li><p>用引用返回一个函数值的最大好处是：在内存中不产生被返回值的副本</p>
</li>
</ol>
<p>引用作为返回值，<strong>必须遵守以下规则</strong>： </p>
<ol>
<li><strong>不能返回局部变量的引用</strong>。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为</li>
</ol>
<p>了”无所指”的引用，程序会进入未知状态。 </p>
<ol start="2">
<li><p><strong>不能返回函数内部new 分配的内存的引用</strong> 虽然不存在局部变量的被动销毁问题，可对于这种情况 （返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为 一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就 无法释放，造成memory leak。 </p>
</li>
<li><p><strong>引用与一些操作符的重载。</strong>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。</p>
</li>
</ol>
<hr>
<p>引用可以修改参数本身的值，如果想要对参数进行修改就要使用引用，作为返回值的引用则是减少拷贝，不会产生副本，不过要注意不能返回局部变量的引用，</p>
<h1 id="哈希表的原理是什么"><a href="#哈希表的原理是什么" class="headerlink" title="哈希表的原理是什么"></a>哈希表的原理是什么</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">哈希表（Hash Table），也叫散列表，是一种根据关键码值（Key value）直接访问内存存储位置的数据结构。它通过一个称为哈希函数（Hash Function）的映射函数，将关键码值映射到表中的一个位置，从而加快查找速度</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</p>
<h3 id="哈希表的基本原理"><a href="#哈希表的基本原理" class="headerlink" title="哈希表的基本原理"></a>哈希表的基本原理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136"><strong>哈希函数</strong>：哈希函数将关键码值转换为数组的索引。理想的哈希函数应当计算简单且分布均匀，以减少冲突的概率</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136"><strong>哈希冲突</strong>：当两个不同的关键码值通过哈希函数得到相同的索引时，就会发生哈希冲突。常见的解决方法有开放定址法和链表法</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86">3</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136"><strong>查找和插入</strong>：通过哈希函数计算关键码值的哈希地址，然后直接访问该地址进行查找或插入操作。哈希表的查找和插入操作时间复杂度接近O(1)</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
</ol>
<h3 id="哈希表的优缺点"><a href="#哈希表的优缺点" class="headerlink" title="哈希表的优缺点"></a>哈希表的优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">查找和插入速度非常快，接近常量时间复杂度O(1)</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">编程实现相对简单，适用于需要快速查找的场景</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a>。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">基于数组实现，扩展困难。当哈希表接近满载时，性能可能会显著下降</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136">需要处理哈希冲突，可能会增加实现的复杂性</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
</ul>
<h3 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="headerlink" title="哈希冲突解决方法"></a>哈希冲突解决方法</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/duan19920101/article/details/51579136"><strong>开放定址法</strong>：发生冲突时，通过某种探测序列找到下一个空闲位置</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a>。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005"><strong>链表法</strong>：每个数组位置存储一个链表，所有哈希值相同的元素都存储在该链表中</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63142005">2</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86">3</a>。</li>
</ol>
<p>​                </p>
<h1 id="什么是运行时多态"><a href="#什么是运行时多态" class="headerlink" title="什么是运行时多态"></a>什么是运行时多态</h1><p>运行时多态（Runtime Polymorphism），也称为动态多态，是面向对象编程中的一个重要特性。它允许程序在运行时决定调用哪个方法，从而实现灵活和可扩展的代码设计。</p>
<h3 id="运行时多态的实现"><a href="#运行时多态的实现" class="headerlink" title="运行时多态的实现"></a>运行时多态的实现</h3><p>在C++中，运行时多态主要通过<strong>虚函数</strong>（virtual functions）和<strong>继承</strong>（inheritance）来实现。以下是实现运行时多态的关键步骤：</p>
<ol>
<li><strong>虚函数</strong>：在基类中声明虚函数，并在派生类中重写这些虚函数。</li>
<li><strong>基类指针或引用</strong>：使用基类的指针或引用来指向派生类对象。</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class show function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class show function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b;</span><br><span class="line">    Derived d;</span><br><span class="line">    b = &amp;d;</span><br><span class="line">    b-&gt;<span class="built_in">show</span>();  <span class="comment">// 输出: Derived class show function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xylitolz/article/details/115800775">在这个例子中，<code>Base</code>类中定义了一个虚函数<code>show</code>，而<code>Derived</code>类重写了这个函数。在<code>main</code>函数中，基类指针<code>b</code>指向派生类对象<code>d</code>，调用<code>b-&gt;show()</code>时，实际执行的是派生类<code>Derived</code>中的<code>show</code>函数</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/xylitolz/article/details/115800775">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43935710/article/details/103871715">2</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81">3</a>。</p>
<h3 id="运行时多态的优点"><a href="#运行时多态的优点" class="headerlink" title="运行时多态的优点"></a>运行时多态的优点</h3><ul>
<li><strong>灵活性</strong>：允许在运行时决定调用哪个方法，使得代码更灵活。</li>
<li><strong>可扩展性</strong>：可以通过继承和重写方法来扩展现有代码，而无需修改原有代码。</li>
</ul>
<h3 id="运行时多态的缺点"><a href="#运行时多态的缺点" class="headerlink" title="运行时多态的缺点"></a>运行时多态的缺点</h3><ul>
<li><strong>性能开销</strong>：由于需要在运行时决定调用哪个方法，可能会带来一些性能开销。</li>
<li><strong>复杂性</strong>：需要理解和正确使用虚函数和继承，增加了代码的复杂性。</li>
</ul>
<p>​                     </p>
<p>​                </p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/25/Http%E4%B8%8EHttps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/25/Http%E4%B8%8EHttps/" class="post-title-link" itemprop="url">面试</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-09-25 12:00:00 / 修改时间：08:57:09" itemprop="dateCreated datePublished" datetime="2024-09-25T12:00:00+08:00">2024-09-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="http和https的区别以及https加密过程"><a href="#http和https的区别以及https加密过程" class="headerlink" title="http和https的区别以及https加密过程"></a>http和https的区别以及https加密过程</h2><p>HTTP（超文本传输协议）和HTTPS（超文本传输安全协议）是用于在Web浏览器和服务器之间传输数据的两种协议。它们的主要区别在于安全性和数据加密方式。</p>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ol>
<li><strong>安全性</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html"><strong>HTTP</strong>：数据以明文形式传输，容易被窃听和篡改</a><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/631089816"><strong>HTTPS</strong>：通过SSL&#x2F;TLS协议加密数据，确保数据在传输过程中不被窃听和篡改</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/631089816">2</a>。</li>
</ul>
</li>
<li><strong>端口</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html"><strong>HTTP</strong>：使用TCP的80端口</a><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html">1</a>。</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html"><strong>HTTPS</strong>：使用TCP的443端口</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/631089816">2</a>。</li>
</ul>
</li>
<li><strong>证书</strong>：<ul>
<li><strong>HTTP</strong>：不需要证书。</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html"><strong>HTTPS</strong>：需要从CA（证书颁发机构）申请数字证书，以验证服务器身份</a></li>
</ul>
</li>
</ol>
<h3 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h3><ol>
<li><strong>客户端发起HTTPS请求</strong>：<ul>
<li>客户端（C）向服务器（S）发送HTTPS请求，连接到服务器的443端口。</li>
</ul>
</li>
<li><strong>服务器发送证书</strong>：<ul>
<li>服务器生成一对公钥和私钥（这对密钥在服务器配置HTTPS时已经生成）。</li>
<li>服务器将包含公钥的数字证书发送给客户端。证书由可信的证书颁发机构（CA）签发，包含服务器的公钥和其他信息。</li>
</ul>
</li>
<li><strong>客户端验证证书</strong>：<ul>
<li>客户端验证证书的有效性，包括检查证书是否由可信的CA签发、证书是否在有效期内等。</li>
<li>如果证书有效，客户端生成一个随机数（称为会话密钥），并用服务器的公钥加密该随机数。</li>
</ul>
</li>
<li><strong>传送加密信息</strong>：<ul>
<li>客户端将加密后的会话密钥发送给服务器。由于只有服务器持有对应的私钥，只有服务器能解密这个会话密钥。</li>
</ul>
</li>
<li><strong>服务器解密信息</strong>：<ul>
<li>服务器使用私钥解密，得到客户端发送的会话密钥。此后，客户端和服务器使用该会话密钥进行对称加密通信。</li>
</ul>
</li>
<li><strong>加密通信</strong>：<ul>
<li>双方使用对称加密算法和会话密钥对数据进行加密和解密，确保数据在传输过程中的机密性和完整性。</li>
</ul>
</li>
</ol>
<h3 id="关键概念解释"><a href="#关键概念解释" class="headerlink" title="关键概念解释"></a>关键概念解释</h3><ol>
<li><strong>公钥和私钥</strong>：<ul>
<li><strong>公钥</strong>：公开给所有人，用于加密数据或验证数字签名。</li>
<li><strong>私钥</strong>：仅服务器持有，用于解密数据或生成数字签名。私钥在服务器配置HTTPS时生成，并且不会在通信过程中传输。</li>
</ul>
</li>
<li><strong>会话密钥</strong>：<ul>
<li>会话密钥是客户端生成的一个随机数，用于对称加密通信。会话密钥在初始的公钥加密过程中被加密并传输给服务器。</li>
<li>使用会话密钥进行对称加密通信，速度快且适合大数据量的传输。</li>
</ul>
</li>
</ol>
<h2 id="C-中哪些函数不能是虚函数"><a href="#C-中哪些函数不能是虚函数" class="headerlink" title="C++中哪些函数不能是虚函数"></a>C++中哪些函数不能是虚函数</h2><p>在C++中，虚函数是一种实现动态多态的方法，有虚表vtable和虚指针vptr，vtable基于类层次，所以普通函数不能时虚函数，vptr基于对象层次，所以构造函数不能是虚函数，因为是运行时动态多态，所以不能是静态函数</p>
<p>以下是这些函数及其原因：</p>
<ol>
<li><strong>普通函数（非成员函数）</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45606415/article/details/107061831">普通函数不属于类的成员函数，不能被继承。因此，声明为虚函数没有意义</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45606415/article/details/107061831">1</a>。</li>
</ul>
</li>
<li><strong>构造函数</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45606415/article/details/107061831">构造函数用于初始化对象，而虚函数的主要作用是实现多态。多态依赖于对象的存在，而构造函数是在对象创建时调用的，因此构造函数不能是虚函数</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45606415/article/details/107061831">1</a>。</li>
</ul>
</li>
<li><strong>静态成员函数</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nie19940803/article/details/77427219">静态成员函数与类的实例无关，它们在编译时确定，无法动态绑定，因此不能声明为虚函数</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/nie19940803/article/details/77427219">2</a>。</li>
</ul>
</li>
<li><strong>内联函数</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nie19940803/article/details/77427219">内联函数在编译时展开，而虚函数在运行时动态绑定。两者的机制不同，内联函数不能声明为虚函数</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/nie19940803/article/details/77427219">2</a>。</li>
<li>内联函数的展开是指编译器在编译时将内联函数的代码直接插入到每个调用它的地方，而不是生成一个函数调用。这样可以减少函数调用的开销，提高程序的执行效率。</li>
<li><strong>编译时与运行时的矛盾</strong>：<ul>
<li><strong>内联函数</strong>：在编译时展开，编译器需要在编译阶段确定函数的具体实现。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37436574"><strong>虚函数</strong>：在运行时通过虚函数表动态绑定，编译器在编译阶段无法确定具体调用哪个函数</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37436574">3</a>。</li>
</ul>
</li>
<li><strong>多态性</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/changyi9995/article/details/108245614">虚函数的多态性要求在运行时根据对象的实际类型调用相应的函数，而内联函数在编译时就已经展开，无法实现这种动态绑定</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/changyi9995/article/details/108245614">4</a>。</li>
</ul>
</li>
<li><strong>性能优化</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/this-543273659/archive/2011/08/17/2143607.html">虚函数调用涉及虚函数表查找，内联函数的展开则是为了避免这种查找开销。两者的设计目标不同，导致内联函数不能有效地作为虚函数</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>友元函数</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/nie19940803/article/details/77427219">友元函数不属于类的成员函数，不能被继承，因此不能声明为虚函数</a></li>
</ul>
</li>
</ol>
<h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><p>Linux内存管理是操作系统中非常重要的一部分，它确保了系统的稳定性和高效性。以下是对Linux内存管理的详细讲解：</p>
<h3 id="1-内存管理概述"><a href="#1-内存管理概述" class="headerlink" title="1. 内存管理概述"></a>1. 内存管理概述</h3><p>Linux内存管理主要包括物理内存和虚拟内存的管理。物理内存是实际存在的内存硬件，而虚拟内存是操作系统提供给每个进程的一个抽象概念。</p>
<h3 id="2-物理内存管理"><a href="#2-物理内存管理" class="headerlink" title="2. 物理内存管理"></a>2. 物理内存管理</h3><p>物理内存管理涉及以下几个方面：</p>
<ul>
<li><strong>页（Page）</strong>：物理内存被划分为固定大小的块，称为页。每个页通常为4KB。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712"><strong>区（Zone）</strong>：物理内存被进一步划分为不同的区域，如DMA区、普通区和高端内存区</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712">1</a>。</li>
</ul>
<h3 id="3-虚拟内存管理"><a href="#3-虚拟内存管理" class="headerlink" title="3. 虚拟内存管理"></a>3. 虚拟内存管理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149581303">虚拟内存管理是通过页表（Page Table）将虚拟地址映射到物理地址。每个进程都有自己的虚拟地址空间，分为用户空间和内核空间</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149581303">2</a>。</p>
<h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><ul>
<li><strong>用户空间</strong>：每个进程都有独立的用户空间，通常为3GB。</li>
<li><strong>内核空间</strong>：所有进程共享一个内核空间，通常为1GB。</li>
</ul>
<h3 id="4-内存分配"><a href="#4-内存分配" class="headerlink" title="4. 内存分配"></a>4. 内存分配</h3><p>内存分配涉及以下几个机制：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712"><strong>伙伴系统（Buddy System）</strong>：用于管理物理内存的分配和回收。它将内存划分为不同大小的块，按需分配</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3">3</a>。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712"><strong>slab分配器</strong>：用于管理小块内存的分配，减少内存碎片</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3">3</a>。</li>
</ul>
<h3 id="5-页面置换"><a href="#5-页面置换" class="headerlink" title="5. 页面置换"></a>5. 页面置换</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712">当物理内存不足时，Linux会将不常用的页面交换到磁盘上，这个过程称为页面置换。常用的页面置换算法包括LRU（最近最少使用）算法</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63602189/article/details/137834785">4</a>。</p>
<h3 id="6-内存映射"><a href="#6-内存映射" class="headerlink" title="6. 内存映射"></a>6. 内存映射</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712">内存映射是将文件或设备映射到进程的地址空间中，常用于文件I&#x2F;O操作。Linux提供了<code>mmap</code>系统调用来实现内存映射</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63602189/article/details/137834785">4</a>。</p>
<h3 id="7-内存保护"><a href="#7-内存保护" class="headerlink" title="7. 内存保护"></a>7. 内存保护</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712">Linux通过虚拟内存机制实现内存保护，防止进程之间互相干扰。每个进程只能访问自己的虚拟地址空间，无法直接访问其他进程的内存</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149581303">2</a>。</p>
<h3 id="8-内存管理的数据结构"><a href="#8-内存管理的数据结构" class="headerlink" title="8. 内存管理的数据结构"></a>8. 内存管理的数据结构</h3><ul>
<li><strong>页表（Page Table）</strong>：用于记录虚拟地址到物理地址的映射关系。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550400712"><strong>内存描述符（Memory Descriptor）</strong>：用于描述进程的内存使用情况</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3">3</a>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux内存管理通过物理内存和虚拟内存的结合，提供了高效、安全的内存使用机制。它不仅确保了系统的稳定性，还提高了内存的利用率</p>
<h3 id="什么是内存碎片"><a href="#什么是内存碎片" class="headerlink" title="什么是内存碎片"></a>什么是内存碎片</h3><p><strong>内存碎片</strong>是指在内存分配和释放过程中，内存中出现了许多零散、不连续的空闲空间。这些碎片空间无法被有效利用，导致内存利用率降低，影响系统性能和稳定性。内存碎片通常分为两种类型：</p>
<ol>
<li><strong>内部碎片</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_kou/article/details/82891141">由于内存分配时采用固定大小的内存块，当一个进程不能完全使用分配给它的内存块时，剩余的部分就成为内部碎片</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_kou/article/details/82891141">1</a>。</li>
</ul>
</li>
<li><strong>外部碎片</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lulusilu/article/details/135429732">由于频繁的内存分配和释放，导致内存中出现许多不连续的空闲块，这些块可能太小，无法满足新的内存分配请求</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lulusilu/article/details/135429732">2</a>。</li>
</ul>
</li>
</ol>
<h3 id="如何防止内存碎片"><a href="#如何防止内存碎片" class="headerlink" title="如何防止内存碎片"></a>如何防止内存碎片</h3><p>防止内存碎片的方法主要有以下几种：</p>
<ol>
<li><strong>使用内存池</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://www.baoxiaoke.com/article/180023.html">内存池是一种预先分配一段连续内存用于多次申请的技术。通过内存池，可以减少频繁的内存分配和释放，从而减少内存碎片的产生</a><a target="_blank" rel="noopener" href="https://www.baoxiaoke.com/article/180023.html">3</a>。</li>
</ul>
</li>
<li><strong>减少动态内存分配</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375447849">尽量减少动态内存分配的次数，可以通过对象复用、对象缓存等方式来减少内存碎片的产生</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375447849">4</a>。</li>
</ul>
</li>
<li><strong>合理释放内存</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375447849">在使用完动态分配的内存后，及时释放。可以使用智能指针、RAII机制等技术来自动管理内存的生命周期，避免内存泄漏</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375447849">4</a>。</li>
</ul>
</li>
<li><strong>内存对齐</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35007676">通过合理使用内存对齐，可以提高内存访问效率，并减少内存碎片的产生。在C++中，可以使用关键字 <code>alignas</code> 和 <code>alignof</code> 来实现内存对齐</a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/35007676">5</a>。</li>
</ul>
</li>
<li><strong>使用适当的内存分配策略</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_kou/article/details/82891141">根据应用场景和数据特点，选择合适的内存分配策略。例如，使用固定大小的内存块或动态调整内存块大小</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87">6</a>。</li>
</ul>
</li>
<li><strong>定期重启服务</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46017342/article/details/131095051">定期重启服务可以释放所有由该服务占用的内存，包括碎片，从而减少内存碎片</a></li>
</ul>
</li>
</ol>
<h2 id="堆区和栈区的区别"><a href="#堆区和栈区的区别" class="headerlink" title="堆区和栈区的区别"></a>堆区和栈区的区别</h2><h3 id="1-内存分配方式"><a href="#1-内存分配方式" class="headerlink" title="1. 内存分配方式"></a>1. 内存分配方式</h3><ul>
<li><strong>栈区（Stack）</strong>：<ul>
<li>由编译器自动分配和释放。</li>
<li>存放函数的参数值、局部变量等。</li>
<li>内存分配和释放速度快，效率高。</li>
</ul>
</li>
<li><strong>堆区（Heap）</strong>：<ul>
<li>由程序员手动分配和释放（如使用 <code>malloc</code>、<code>new</code> 等）。</li>
<li>存放动态分配的内存块。</li>
<li>内存分配和释放速度较慢，容易产生内存碎片。</li>
</ul>
</li>
</ul>
<h3 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2. 存储方式"></a>2. 存储方式</h3><ul>
<li><strong>栈区</strong>：<ul>
<li>是一块连续的内存区域。</li>
<li>内存分配遵循先进后出的原则（类似于数据结构中的栈）。</li>
</ul>
</li>
<li><strong>堆区</strong>：<ul>
<li>是不连续的内存区域（由于系统使用链表存储空闲内存地址）。</li>
<li>内存分配灵活，但容易产生碎片。</li>
</ul>
</li>
</ul>
<h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. 生命周期</h3><ul>
<li><strong>栈区</strong>：<ul>
<li>由系统自动管理，函数调用结束后，栈内存自动释放。</li>
<li>生命周期短，适用于临时变量。</li>
</ul>
</li>
<li><strong>堆区</strong>：<ul>
<li>由程序员管理，需要手动释放（如使用 <code>free</code>、<code>delete</code> 等）。</li>
<li>生命周期长，适用于需要动态分配的内存。</li>
</ul>
</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul>
<li><strong>栈区</strong>：<ul>
<li>适用于存储局部变量、函数参数等临时数据。</li>
<li>由于栈内存有限，适合小数据量的快速存取。</li>
</ul>
</li>
<li><strong>堆区</strong>：<ul>
<li>适用于需要动态分配的大块内存，如动态数组、复杂数据结构等。</li>
<li>需要注意内存管理，防止内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP三次握手是建立TCP连接的过程，确保客户端和服务器之间的连接是可靠的。以下是详细步骤：</p>
<ol>
<li><strong>第一次握手</strong>：<ul>
<li>客户端向服务器发送一个SYN（同步序列号）报文，表示请求建立连接。此时，客户端进入SYN-SENT状态。</li>
</ul>
</li>
<li><strong>第二次握手</strong>：<ul>
<li>服务器收到SYN报文后，回复一个SYN+ACK（确认序列号）报文，表示同意连接并确认客户端的请求。此时，服务器进入SYN-RECEIVED状态。</li>
</ul>
</li>
<li><strong>第三次握手</strong>：<ul>
<li>客户端收到SYN+ACK报文后，再次发送一个ACK报文，确认服务器的响应。此时，客户端和服务器都进入ESTABLISHED状态，连接建立完成。</li>
</ul>
</li>
</ol>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>TCP四次挥手是断开TCP连接的过程，确保连接的双方都能正常关闭连接。以下是详细步骤：</p>
<ol>
<li><strong>第一次挥手</strong>：<ul>
<li>客户端发送一个FIN（结束）报文，表示不再发送数据。此时，客户端进入FIN-WAIT-1状态。</li>
</ul>
</li>
<li><strong>第二次挥手</strong>：<ul>
<li>服务器收到FIN报文后，回复一个ACK报文，确认客户端的请求。此时，服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。</li>
</ul>
</li>
<li><strong>第三次挥手</strong>：<ul>
<li>服务器发送一个FIN报文，表示不再发送数据。此时，服务器进入LAST-ACK状态。</li>
</ul>
</li>
<li><strong>第四次挥手</strong>：<ul>
<li>客户端收到FIN报文后，回复一个ACK报文，确认服务器的请求。此时，客户端进入TIME-WAIT状态，等待一段时间（通常为2MSL，最大报文生存时间）后，进入CLOSED状态。服务器收到ACK报文后，立即进入CLOSED状态，连接断开完成。</li>
</ul>
</li>
</ol>
<h3 id="为什么需要三次握手和四次挥手"><a href="#为什么需要三次握手和四次挥手" class="headerlink" title="为什么需要三次握手和四次挥手"></a>为什么需要三次握手和四次挥手</h3><ul>
<li><strong>三次握手</strong>：确保双方的发送和接收能力正常，防止已失效的连接请求报文突然到达服务器，导致错误连接。</li>
<li><strong>四次挥手</strong>：确保双方都能正常关闭连接，防止数据丢失或连接异常关闭。</li>
</ul>
<h2 id="滑动窗口的作用"><a href="#滑动窗口的作用" class="headerlink" title="滑动窗口的作用"></a>滑动窗口的作用</h2><p>滑动窗口是TCP协议中的一个重要机制，用于控制数据传输的流量和确保数据传输的可靠性。以下是滑动窗口的详细作用和工作原理：</p>
<h3 id="滑动窗口的作用-1"><a href="#滑动窗口的作用-1" class="headerlink" title="滑动窗口的作用"></a>滑动窗口的作用</h3><ol>
<li><strong>流量控制</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">滑动窗口机制允许接收方根据自身的处理能力和缓冲区空间动态调整窗口大小，从而控制发送方的数据发送速率，防止发送方发送过多数据导致接收方缓冲区溢出</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">1</a>。</li>
</ul>
</li>
<li><strong>可靠传输</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/571726228">通过滑动窗口，发送方可以在未收到确认应答（ACK）的情况下继续发送一定数量的数据段，从而提高传输效率。接收方通过ACK报文确认已成功接收的数据段，确保数据传输的可靠性</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/571726228">2</a>。</li>
</ul>
</li>
<li><strong>拥塞控制</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">滑动窗口还用于实现拥塞控制，通过调整窗口大小来适应网络的拥塞情况，避免网络过载</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8">3</a>。</li>
</ul>
</li>
</ol>
<h3 id="滑动窗口的工作原理"><a href="#滑动窗口的工作原理" class="headerlink" title="滑动窗口的工作原理"></a>滑动窗口的工作原理</h3><ol>
<li><strong>初始化窗口大小</strong>：<ul>
<li>在建立TCP连接时，双方协商并初始化窗口大小。窗口大小通常以字节为单位，表示接收方的缓冲区大小。</li>
</ul>
</li>
<li><strong>发送窗口滑动</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">发送方发送一个数据段并收到ACK确认应答后，将发送窗口向前滑动，使其离开已确认的数据。这样，发送方可以继续发送新的数据，只要它在滑动窗口范围内</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">1</a>。</li>
</ul>
</li>
<li><strong>接收方更新确认号</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">接收方根据接收到的报文段的序列号确定已成功接收的数据字节范围，并将确认号设置为下一个期望接收的字节的序列号</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/571726228">2</a>。</li>
</ul>
</li>
<li><strong>接收方通告窗口大小</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">接收方根据已成功接收的数据字节数和初始窗口大小计算可用的接收窗口大小，并通过TCP报文段中的窗口大小字段通告给发送方</a><a target="_blank" rel="noopener" href="https://bing.com/search?q=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8">3</a>。</li>
</ul>
</li>
<li><strong>动态调整窗口大小</strong>：<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">接收方通过ACK确认号通知发送方已成功接收的数据。发送方根据接收方通告的窗口大小调整发送速率，确保不会超出接收方的处理能力</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_46631497/article/details/137253124">1</a>。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设发送方需要发送400字节的数据，分成4个报文段，每个报文段长度为100字节：</p>
<ol>
<li><strong>发送方发送第一个报文段</strong>（序号1-100），接收方确认并通告窗口大小为300字节。</li>
<li><strong>发送方发送第二个报文段</strong>（序号101-200），接收方确认并通告窗口大小为200字节。</li>
<li><strong>发送方发送第三个报文段</strong>（序号201-300），接收方确认并通告窗口大小为100字节。</li>
<li><strong>发送方发送第四个报文段</strong>（序号301-400），接收方确认并通告窗口大小为0字节，表示接收方缓冲区已满，等待处理完毕后再继续发送。</li>
</ol>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/25/char%E5%92%8Cchar[]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/25/char%E5%92%8Cchar%5B%5D/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-25 08:58:09" itemprop="dateCreated datePublished" datetime="2024-09-25T08:58:09+08:00">2024-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-10 11:39:23" itemprop="dateModified" datetime="2024-09-10T11:39:23+08:00">2024-09-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>419</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="char-和char-的区别"><a href="#char-和char-的区别" class="headerlink" title="char*和char[] 的区别"></a>char*<code>和</code>char[] 的区别</h1><p>在C++中，<code>char*</code>和<code>char[]</code>有一些关键的区别：</p>
<ol>
<li><strong>定义和初始化</strong>：<ul>
<li><code>char*</code> 是一个指向字符的指针。例如：<code>char* str = &quot;Hello&quot;;</code>。这里，<code>str</code>指向一个字符串常量。</li>
<li><code>char[]</code> 是一个字符数组。例如：<code>char str[] = &quot;Hello&quot;;</code>。这里，<code>str</code>是一个包含字符的数组。</li>
</ul>
</li>
<li><strong>内存分配</strong>：<ul>
<li><code>char*</code> 指向的内存可以是动态分配的，也可以是静态分配的。它提供了更大的灵活性，可以指向不同的字符串。</li>
<li><code>char[]</code> 的大小在编译时确定，不能动态改变。它是一个固定大小的数组。</li>
</ul>
</li>
<li><strong>可修改性</strong>：<ul>
<li><code>char*</code> 指向的字符串常量通常是不可修改的。如果尝试修改，可能会导致未定义行为。</li>
<li><code>char[]</code> 中的字符是可以修改的。例如：<code>str[1] = &#39;a&#39;;</code>。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><code>char*</code> 更适合需要动态分配内存或需要指向不同字符串的场景。</li>
<li><code>char[]</code> 更适合固定大小的字符串或需要频繁修改字符串内容的场景。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F3/" class="post-title-link" itemprop="url">牛客模拟3</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-24 14:00:00" itemprop="dateCreated datePublished" datetime="2024-09-24T14:00:00+08:00">2024-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-25 08:58:02" itemprop="dateModified" datetime="2024-09-25T08:58:02+08:00">2024-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述一下-C-从代码到可执行二进制文件的过程"><a href="#简述一下-C-从代码到可执行二进制文件的过程" class="headerlink" title="简述一下 C++ 从代码到可执行二进制文件的过程"></a>简述一下 C++ 从代码到可执行二进制文件的过程</h1><p><a target="_blank" rel="noopener" href="https://www.prepbytes.com/blog/cpp-programming/cpp-compilation-process/">将C++代码转换为可执行二进制文件的过程可以分为以下几个主要步骤</a><a target="_blank" rel="noopener" href="https://www.prepbytes.com/blog/cpp-programming/cpp-compilation-process/">1</a>:</p>
<ol>
<li><strong>编写代码</strong>：编写C++源代码文件（.cpp）和头文件（.h）。</li>
<li><strong>预处理</strong>：预处理器处理源代码中的预处理指令（如<code>#include</code>和<code>#define</code>），生成扩展后的代码文件。</li>
<li><strong>编译</strong>：编译器将预处理后的代码转换为汇编代码，这个阶段会进行语法检查和优化。</li>
<li><strong>汇编</strong>：汇编器将汇编代码转换为机器代码，生成目标文件（.o或.obj）。</li>
<li><strong>链接</strong>：链接器将多个目标文件和库文件链接在一起，生成最终的可执行文件。</li>
</ol>
<h1 id="说一说STL-中有哪些常见的容器"><a href="#说一说STL-中有哪些常见的容器" class="headerlink" title="说一说STL 中有哪些常见的容器"></a>说一说STL 中有哪些常见的容器</h1><p>C++标准模板库（STL）中有许多常见的容器，每种容器都有其特定的用途和特点。以下是一些主要的STL容器：</p>
<ol>
<li><strong>序列容器</strong>：<ul>
<li><strong>vector</strong>：动态数组，支持快速随机访问和在末尾插入&#x2F;删除元素。</li>
<li><strong>deque</strong>：双端队列，支持在两端快速插入&#x2F;删除元素。</li>
<li><strong>list</strong>：双向链表，支持在任何位置快速插入&#x2F;删除元素，但随机访问较慢。</li>
<li><strong>array</strong>：固定大小的数组，大小在编译时确定。</li>
<li><strong>forward_list</strong>：单向链表，支持在任何位置快速插入&#x2F;删除元素，但只能单向遍历。</li>
</ul>
</li>
<li><strong>关联容器</strong>：<ul>
<li><strong>set</strong>：集合，存储唯一元素，元素按顺序排列。</li>
<li><strong>multiset</strong>：多重集合，允许存储重复元素，元素按顺序排列。</li>
<li><strong>map</strong>：映射，存储键值对，键唯一且按顺序排列。</li>
<li><strong>multimap</strong>：多重映射，允许存储重复键的键值对，键按顺序排列。</li>
</ul>
</li>
<li><strong>无序关联容器</strong>：<ul>
<li><strong>unordered_set</strong>：无序集合，存储唯一元素，使用哈希表实现。</li>
<li><strong>unordered_multiset</strong>：无序多重集合，允许存储重复元素，使用哈希表实现。</li>
<li><strong>unordered_map</strong>：无序映射，存储键值对，键唯一，使用哈希表实现。</li>
<li><strong>unordered_multimap</strong>：无序多重映射，允许存储重复键的键值对，使用哈希表实现。</li>
</ul>
</li>
<li><strong>容器适配器</strong>：<ul>
<li><strong>stack</strong>：栈，后进先出（LIFO）数据结构，通常基于<code>deque</code>或<code>vector</code>实现。</li>
<li><strong>queue</strong>：队列，先进先出（FIFO）数据结构，通常基于<code>deque</code>实现。</li>
<li><strong>priority_queue</strong>：优先队列，元素按优先级排序，通常基于<code>vector</code>实现</li>
</ul>
</li>
</ol>
<h1 id="简述一下-GDB-常见的调试命令"><a href="#简述一下-GDB-常见的调试命令" class="headerlink" title="简述一下 GDB 常见的调试命令"></a>简述一下 GDB 常见的调试命令</h1><p>GDB（GNU Debugger）是一个强大的调试工具，常用于调试C和C++程序。以下是一些常见的GDB调试命令：</p>
<ol>
<li><strong>启动和运行程序</strong>：<ul>
<li><code>gdb &lt;program&gt;</code>：启动GDB并加载指定的程序。</li>
<li><code>run</code>：运行程序直到遇到断点或程序结束。</li>
<li><code>run &lt;args&gt;</code>：带参数运行程序。</li>
</ul>
</li>
<li><strong>设置断点</strong>：<ul>
<li><code>break &lt;location&gt;</code>：在指定位置设置断点，例如函数名或行号（如<code>break main</code>或<code>break 42</code>）。</li>
<li><code>break &lt;file&gt;:&lt;line&gt;</code>：在指定文件的特定行设置断点。</li>
<li><code>tbreak &lt;location&gt;</code>：设置临时断点，命中一次后自动删除。</li>
</ul>
</li>
<li><strong>控制程序执行</strong>：<ul>
<li><code>continue</code> 或 <code>c</code>：继续执行程序直到下一个断点。</li>
<li><code>next</code> 或 <code>n</code>：单步执行，跳过函数调用。</li>
<li><code>step</code> 或 <code>s</code>：单步执行，进入函数调用。</li>
<li><code>finish</code>：运行到当前函数结束并返回。</li>
</ul>
</li>
<li><strong>检查变量和内存</strong>：<ul>
<li><code>print &lt;variable&gt;</code>：打印变量的值。</li>
<li><code>display &lt;variable&gt;</code>：每次程序暂停时自动显示变量的值。</li>
<li><code>x &lt;address&gt;</code>：检查内存地址的内容。</li>
</ul>
</li>
<li><strong>管理断点</strong>：<ul>
<li><code>info breakpoints</code>：列出所有断点。</li>
<li><code>delete &lt;breakpoint-number&gt;</code>：删除指定编号的断点。</li>
<li><code>disable &lt;breakpoint-number&gt;</code>：禁用指定编号的断点。</li>
<li><code>enable &lt;breakpoint-number&gt;</code>：启用指定编号的断点。</li>
</ul>
</li>
<li><strong>查看代码和堆栈</strong>：<ul>
<li><code>list</code> 或 <code>l</code>：显示源代码。</li>
<li><code>backtrace</code> 或 <code>bt</code>：显示当前调用堆栈。</li>
<li><code>frame &lt;frame-number&gt;</code>：切换到指定的堆栈帧。</li>
</ul>
</li>
<li><strong>其他有用命令</strong>：<ul>
<li><code>info locals</code>：显示当前函数的所有局部变量。</li>
<li><code>info args</code>：显示当前函数的所有参数。</li>
<li><code>set var &lt;variable&gt;=&lt;value&gt;</code>：设置变量的值。</li>
</ul>
</li>
</ol>
<p>​                    </p>
<h1 id="说一说C-11-的新特性有哪些"><a href="#说一说C-11-的新特性有哪些" class="headerlink" title="说一说C++11 的新特性有哪些"></a>说一说C++11 的新特性有哪些</h1><p>C++11引入了许多新特性，极大地增强了C++语言的功能和灵活性。以下是一些主要的新特性：</p>
<ol>
<li><p><strong>类型推导</strong>：</p>
<ul>
<li><strong>auto</strong>：让编译器自动推导变量的类型。</li>
<li><strong>decltype</strong>：用于推导表达式的类型。</li>
</ul>
</li>
<li><p><strong>智能指针</strong>：</p>
<ul>
<li><strong>std::unique_ptr</strong>：独占所有权的智能指针。</li>
<li><strong>std::shared_ptr</strong>：共享所有权的智能指针。</li>
<li><strong>std::weak_ptr</strong>：弱引用，不影响对象的生命周期。</li>
</ul>
</li>
<li><p><strong>右值引用和移动语义</strong>：</p>
<ul>
<li><strong>右值引用（&amp;&amp;）</strong>：用于实现移动语义，减少不必要的拷贝。</li>
<li><strong>std::move</strong> 和 <strong>std::forward</strong>：辅助实现移动语义和完美转发。</li>
</ul>
</li>
<li><p><strong>lambda表达式</strong>：允许在代码中定义匿名函数，简化了函数对象的使用。</p>
</li>
<li><p><strong>并发支持</strong>：</p>
<ul>
<li><strong>std::thread</strong>：用于创建和管理线程。</li>
<li><strong>std::mutex</strong>、<strong>std::lock</strong>、<strong>std::condition_variable</strong>：用于线程同步。</li>
<li><strong>std::atomic</strong>：提供原子操作，避免数据竞争。</li>
</ul>
</li>
<li><p><strong>基于范围的for循环</strong>：简化了遍历容器的代码。</p>
<p><code>for (int i : vec) &#123;     std::cout &lt;&lt; i &lt;&lt; std::endl; &#125; </code> </p>
</li>
<li><p><strong>constexpr</strong>：允许在编译时计算常量表达式，提高了代码的效率和安全性。</p>
</li>
<li><p><strong>新标准库组件</strong>：</p>
<ul>
<li>**<chrono>**：提供时间和日期处理。</li>
<li>**<random>**：提供随机数生成。</li>
<li>**<regex>**：提供正则表达式支持。</li>
<li>**<tuple>**：提供固定大小的多元组。</li>
</ul>
</li>
<li><p><strong>其他改进</strong>：</p>
<ul>
<li><strong>nullptr</strong>：引入空指针常量，替代<code>NULL</code>。</li>
<li><strong>static_assert</strong>：在编译时进行断言检查。</li>
<li><strong>enum class</strong>：强类型枚举，避免命名冲突。</li>
<li><strong>委托构造函数</strong>：一个构造函数可以调用另一个构造函数。</li>
<li><strong>继承构造函数</strong>：派生类可以继承基类的构造函数。</li>
</ul>
</li>
</ol>
<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p>将给定的单链表<img src="https://www.nowcoder.com/equation?tex=%5C%20L" alt="img">： <img src="https://www.nowcoder.com/equation?tex=L_0%E2%86%92L_1%E2%86%92%E2%80%A6%E2%86%92L_%7Bn-1%7D%E2%86%92L_%20n" alt="img"><br>重新排序为：<img src="https://www.nowcoder.com/equation?tex=L_0%E2%86%92L_n%20%E2%86%92L_1%E2%86%92L_%7Bn-1%7D%E2%86%92L_2%E2%86%92L_%7Bn-2%7D%E2%86%92%E2%80%A6" alt="img"><br>要求使用原地算法，不能只改变节点内部的值，需要对实际的节点进行交换。</p>
<p>数据范围：链表长度 <img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%2020000" alt="img"> ，链表中每个节点的值满足 <img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20val%20%5Cle%201000%20" alt="img"></p>
<p>要求：空间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n)" alt="img"> 并在链表上进行操作而不新建链表，时间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n)%20" alt="img"></p>
<p>进阶：空间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(1)%20" alt="img"> ， 时间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n)%20" alt="img"></p>
<p>​                </p>
<p>要实现这个功能，可以按照以下步骤进行：</p>
<ol>
<li><strong>找到链表的中点</strong>：使用快慢指针法（快指针每次移动两步，慢指针每次移动一步），当快指针到达链表末尾时，慢指针正好在链表中点。</li>
<li><strong>反转链表的后半部分</strong>：从中点开始，将链表的后半部分反转。</li>
<li><strong>合并两个链表</strong>：将前半部分和反转后的后半部分交替合并。</li>
</ol>
<p>以下是一个C++实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到链表的中点</span></span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表的后半部分</span></span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* curr = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        ListNode* next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 切断前半部分和后半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    ListNode* second = prev;</span><br><span class="line">    <span class="keyword">while</span> (second) &#123;</span><br><span class="line">        ListNode* temp1 = first-&gt;next;</span><br><span class="line">        ListNode* temp2 = second-&gt;next;</span><br><span class="line">        first-&gt;next = second;</span><br><span class="line">        second-&gt;next = temp1;</span><br><span class="line">        first = temp1;</span><br><span class="line">        second = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        std::cout &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原链表: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reorderList</span>(head);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;重新排序后的链表: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p>给定一个由 ‘0’ 和 ‘1’ 组成的2维矩阵，返回该矩阵中最大的由 ‘1’ 组成的正方形的面积。输入的矩阵是字符形式而非数字形式。</p>
<p>数据范围：矩阵的长宽满足 <img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%2020%20" alt="img">,矩阵中的元素属于 {‘1’,’0’}</p>
<p>进阶：空间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n%5E2)" alt="img"> ， 时间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n%5E2)" alt="img"></p>
<p>要找到一个由0和1组成的二维矩阵中最大的由1组成的正方形的面积，可以使用动态规划来解决这个问题。以下是一个C++实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个与matrix大小相同的dp数组</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>; <span class="comment">// 第一行或第一列的元素只能是1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = std::<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxSide = std::<span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最大的正方形的面积</span></span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大的由1组成的正方形的面积: &quot;</span> &lt;&lt; <span class="built_in">maximalSquare</span>(matrix) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码使用动态规划来解决问题。<code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的最大正方形的边长。通过遍历矩阵并更新<code>dp</code>数组，可以找到最大的正方形的边长，最后返回其面积。</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F1/" class="post-title-link" itemprop="url">牛客模拟1</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-24 13:00:00" itemprop="dateCreated datePublished" datetime="2024-09-24T13:00:00+08:00">2024-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-25 08:57:36" itemprop="dateModified" datetime="2024-09-25T08:57:36+08:00">2024-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常见的HTTP协议响应头有哪些？"><a href="#常见的HTTP协议响应头有哪些？" class="headerlink" title="常见的HTTP协议响应头有哪些？"></a>常见的HTTP协议响应头有哪些？</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/an-wen/p/11180076.html">HTTP协议超级详解 - 爱文飞翔 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<ol>
<li><code>Content-Type</code>：指定响应的媒体类型（例如：text&#x2F;html、application&#x2F;json）。</li>
<li><code>Content-Length</code>：指定响应正文的长度（以字节为单位）。</li>
<li><code>Server</code>：指定服务器软件的名称和版本。</li>
<li><code>Date</code>：指定响应生成的日期和时间。</li>
<li><code>Last-Modified</code>：指定资源的最后修改日期和时间。</li>
<li><code>ETag</code>：指定资源的实体标识符，用于缓存验证。</li>
<li><code>Expires</code>：指定响应的过期日期和时间。</li>
<li><code>Cache-Control</code>：指定缓存机制的控制指令。</li>
<li><code>Location</code>：指定重定向的目标 URL。</li>
<li><code>Set-Cookie</code>：在客户端保存一个或多个 cookie。</li>
<li><code>Access-Control-Allow-Origin</code>：指定允许访问资源的域名。</li>
<li><code>Content-Encoding</code>：指定响应正文的编码方式（例如：gzip、deflate）。</li>
<li><code>Content-Disposition</code>：指定响应正文的处理方式（例如：inline、attachment）。</li>
</ol>
<h2 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h2><ol>
<li><strong>Host</strong>：指定请求的服务器的域名和端口号，例如：<code>Host: www.example.com</code>。</li>
<li><strong>User-Agent</strong>：标识客户端使用的浏览器和操作系统信息，例如：<code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</code>。</li>
<li><strong>Accept</strong>：指定客户端能够处理的内容类型，例如：<code>Accept: text/html,application/xhtml+xml</code>。</li>
<li><strong>Accept-Encoding</strong>：指定客户端能够接受的压缩格式，例如：<code>Accept-Encoding: gzip, deflate</code>。</li>
<li><strong>Accept-Language</strong>：指定客户端偏好的语言，例如：<code>Accept-Language: en-US,en;q=0.5</code>。</li>
<li><strong>Content-Type</strong>：指定请求体中的数据格式类型，例如：<code>Content-Type: application/json</code>。</li>
<li><strong>Content-Length</strong>：指定请求体的长度，例如：<code>Content-Length: 348</code>。</li>
<li><strong>Authorization</strong>：用于进行身份验证的凭证信息，例如：<code>Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</code>。</li>
<li><strong>Cookie</strong>：包含来自客户端的Cookie信息，例如：<code>Cookie: sessionId=abc123</code>。</li>
<li><strong>Referer</strong>：指示当前请求是从哪个URL页面发起的，例如：<code>Referer: http://www.example.com/previous-page</code>。</li>
<li><strong>Connection</strong>：指定连接方式，例如：<code>Connection: keep-alive</code>。</li>
<li><strong>If-Modified-Since</strong>：用于缓存控制，表示客户端只接受在指定时间之后修改过的资源，例如：<code>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code>。</li>
<li><strong>Range</strong>：用于请求资源的一部分，例如：<code>Range: bytes=500-999</code>。</li>
</ol>
<h1 id="TCP协议的首部结构"><a href="#TCP协议的首部结构" class="headerlink" title="TCP协议的首部结构"></a>TCP协议的首部结构</h1><p>TCP尽管是面向字节流的，和UDP面向数据报不一样，但是TCP传送的每一个数据单元却是报文段。每一个TCP报文段分为首部和数据两部分，首部的各个字段都很好的体现了TCP的每个功能。TCP报文段首部的前20个字节是固定的，后面有4*n（整数）个字节是根据需要可选的，所以TCP首部的最小长度是20字节。首部字段分别是：源端口、目的端口、序号、确认号、数据偏移、保留、紧急URG、确认ACK、推送PSH、复位RST、同步SYN、终止FIN、窗口、检验和、紧急指针、选项。</p>
<p><img src="C:\Users\任公伟\AppData\Roaming\Typora\typora-user-images\1726710377364.png" alt="1726710377364"></p>
<p><strong>加分回答</strong></p>
<p>首部字段的意义分别是：</p>
<ul>
<li><p><strong>源端口（Source Port）</strong>：16位，用于标识发送端的应用程序端口。</p>
</li>
<li><p><strong>目的端口（Destination Port）</strong>：16位，用于标识接收端的应用程序端口。</p>
</li>
<li><p><strong>序号（Sequence Number）</strong>：32位，用于标识数据段在整个数据流中的位置。</p>
</li>
<li><p><strong>确认号（Acknowledgment Number）</strong>：32位，用于确认接收到的数据段的序号。</p>
</li>
<li><p><strong>数据偏移（Data Offset）</strong>：4位，表示TCP首部的长度，以32位字（4字节）为单位。</p>
</li>
<li><p><strong>保留（Reserved）</strong>：6位，保留为将来使用，目前应置为0。</p>
</li>
<li><p>控制位（Control Bits）</p>
<p>：6位，包括以下标志：</p>
<ul>
<li><strong>URG</strong>：紧急指针有效。</li>
<li><strong>ACK</strong>：确认号有效。</li>
<li><strong>PSH</strong>：接收方应立即将数据推送给应用程序。</li>
<li><strong>RST</strong>：重置连接。</li>
<li><strong>SYN</strong>：同步序号，用于建立连接。</li>
<li><strong>FIN</strong>：发送方完成发送任务。</li>
</ul>
</li>
<li><p><strong>窗口大小（Window Size）</strong>：16位，用于流量控制，表示接收方的缓冲区大小。</p>
</li>
<li><p><strong>校验和（Checksum）</strong>：16位，用于检验数据的完整性。</p>
</li>
<li><p><strong>紧急指针（Urgent Pointer）</strong>：16位，仅在URG标志置位时有效，指示紧急数据的结束位置。</p>
</li>
<li><p><strong>选项（Options）</strong>：可变长度，用于指定其他选项，如最大报文段长度（MSS）</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_17611285/article/details/80171239">TCP首部的最小长度是20字节，如果包含选项字段，最大长度可以达到60字节</a></p>
<h1 id="说一说-select-的原理以及缺点"><a href="#说一说-select-的原理以及缺点" class="headerlink" title="说一说 select 的原理以及缺点"></a>说一说 select 的原理以及缺点</h1><p>select 是 一种 IO 多路复用技术，它的主旨思想是：</p>
<ol>
<li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中，这个文件描述符的列表数据类型为 fd_set，它是一个整型数组，总共是 1024 个比特位，每一个比特位代表一个文件描述符的状态。比如当需要 select 检测时，这一位为 0 就表示不检测对应的文件描述符的事件，为 1 表示检测对应的文件描述符的事件。</li>
<li>调用 select() 系统调用，监听该列表中的文件描述符的事件，这个函数是阻塞的，直到这些描述符中的一个或者多个进行 I&#x2F;O 操作时，该函数才返回，并修改文件描述符的列表中对应的值，0 表示没有检测到该事件，1 表示检测到该事件。函数对文件描述符的检测的操作是由内核完成的。</li>
<li>select() 返回时，会告诉进程有多少描述符要进行 I&#x2F;O 操作，接下来遍历文件描述符的列表进行 I&#x2F;O 操作。</li>
</ol>
<p>select 的缺点：</p>
<ol>
<li>每次调用select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</li>
<li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大；</li>
<li>select 支持的文件描述符数量太小了，默认是 1024（由 fd_set 决定）；</li>
<li>文件描述符集合不能重用，因为内核每次检测到事件都会修改，所以每次都需要重置；</li>
<li>每次 select 返回后，只能知道有几个 fd 发生了事件，但是具体哪几个还需要遍历文件描述符集合进一步判断。</li>
</ol>
<h1 id="GET方法和POST方法的区别是什么？"><a href="#GET方法和POST方法的区别是什么？" class="headerlink" title="GET方法和POST方法的区别是什么？"></a>GET方法和POST方法的区别是什么？</h1><p>get:主要用于从服务端获取数据，并且参数拼接在url中，安全性较小，数据大小有限1024字节</p>
<p>post：主要用于发送数据到服务端，参数拼接在请求体中，安全性较大，数据大小没有限制</p>
<p>get会被浏览器主动缓存，post不会，除非手动设置。</p>
<p>get在 回退&#x2F;前进 操作是无害的，post会再次提交表单。</p>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><ol>
<li><strong>用途</strong>：主要用于从服务器获取数据。</li>
<li><strong>参数传递</strong>：参数通过URL传递，通常附加在URL的末尾，例如：<code>http://example.com/page?name=value</code>。</li>
<li><strong>数据大小</strong>：由于参数包含在URL中，GET请求的数据量较小，通常不超过2048字节（具体限制取决于浏览器和服务器）。</li>
<li><strong>安全性</strong>：参数暴露在URL中，安全性较低，不适合传递敏感信息。</li>
<li><strong>缓存</strong>：GET请求可以被浏览器缓存，适合用于获取不变的数据。</li>
<li><strong>幂等性</strong>：GET请求是幂等的，重复执行相同的GET请求不会改变服务器的状态。</li>
</ol>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><ol>
<li><strong>用途</strong>：主要用于向服务器提交数据，例如表单数据。</li>
<li><strong>参数传递</strong>：参数包含在请求体中，而不是URL中，因此用户看不到传递的数据。</li>
<li><strong>数据大小</strong>：POST请求的数据量较大，理论上没有限制，但实际限制取决于服务器配置。</li>
<li><strong>安全性</strong>：参数不暴露在URL中，安全性较高，适合传递敏感信息。</li>
<li><strong>缓存</strong>：POST请求不会被浏览器缓存，适合用于提交需要处理的数据。</li>
<li><strong>幂等性</strong>：POST请求不是幂等的，重复执行相同的POST请求可能会导致服务器状态的改变。</li>
</ol>
<h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ul>
<li><strong>浏览器行为</strong>：GET请求在浏览器回退时是无害的，而POST请求可能会再次提交数据。</li>
<li><strong>书签</strong>：GET请求生成的URL可以被书签保存，而POST请求不可以。</li>
<li><strong>编码方式</strong>：GET请求只能进行URL编码，而POST请求支持多种编码方式</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/09/24/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F2/" class="post-title-link" itemprop="url">牛客模拟2</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-24 13:00:00" itemprop="dateCreated datePublished" datetime="2024-09-24T13:00:00+08:00">2024-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-25 08:57:52" itemprop="dateModified" datetime="2024-09-25T08:57:52+08:00">2024-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说一说常用的-Linux-命令"><a href="#说一说常用的-Linux-命令" class="headerlink" title="说一说常用的 Linux 命令"></a>说一说常用的 Linux 命令</h1><ul>
<li><p>cd         切换目录</p>
</li>
<li><p>pwd         显示当前工作目录</p>
</li>
<li><p>touch     创建空文件</p>
</li>
<li><p>mkdir     创建一个新目录</p>
<ul>
<li>-p    创建多级目录</li>
</ul>
</li>
<li><p>cp        复制文件或者目录</p>
<ul>
<li>-r    递归处理，将指定目录下的文件与子目录一并拷贝</li>
</ul>
</li>
<li><p>mv        移动文件或目录、文件或目录改名</p>
</li>
<li><p>rm         删除文件</p>
<ul>
<li>-r    同时删除该目录下的所有文件</li>
<li>-f    强制删除文件或目录</li>
</ul>
</li>
<li><p>cat        显示文本文件内容</p>
</li>
<li><p>more        分页显示文本内容，可前后翻页，空格向后翻页，b向前翻页</p>
</li>
<li><p>head        查看文本开头部分，默认十行</p>
<ul>
<li>-[num]    查看文本开头部分指定行数</li>
</ul>
</li>
<li><p>tail    查看文本结尾部分，默认十行</p>
<ul>
<li>-[num]    查看文本结尾部分指定行数</li>
<li>-f        循环滚动读取文件并动态显示在屏幕上，根据文件属性追踪    </li>
<li>-F        循环滚动读取文件并动态显示在屏幕上，文件文件名追踪</li>
</ul>
</li>
<li><p>wc        统计文本行数，字数，字符数</p>
<ul>
<li>-m    字符数</li>
<li>-w    文本字数</li>
<li>-l    文本行数</li>
</ul>
</li>
<li><p>find    &#x2F; -name 在文件系统的指定目录下查找指定的文件</p>
</li>
<li><p>grep        在指定的文件中查找指定内容的行</p>
</li>
<li><p>ln        建立链接文件</p>
</li>
<li><p>scp  远程传输文件</p>
</li>
</ul>
<h1 id="谈谈InnoDB引擎中的锁"><a href="#谈谈InnoDB引擎中的锁" class="headerlink" title="谈谈InnoDB引擎中的锁"></a>谈谈InnoDB引擎中的锁</h1><p>InnoDB是MySQL数据库中最常用的引擎之一，它采用了多版本并发控制（MVCC）来管理事务的并发访问。在InnoDB中，锁是实现MVCC的重要组件之一。</p>
<p>InnoDB中的锁可以分为共享锁和排他锁。</p>
<p>共享锁（S锁）允许多个事务同时持有同一份数据对象的锁，但是不能同时持有排他锁（X锁）。</p>
<p>排他锁（X锁）则只允许一个事务持有该数据对象的锁，其他事务无法获得该锁，直到该事务释放该锁。</p>
<p>意向锁（Intention Lock）：用于协调共享锁和排他锁之间的竞争。当一个事务获取共享锁或排他锁时，必须先获取对应的意向锁。意向锁是一种轻量级锁，不会阻塞其他事务的读取操作，只会阻塞其他事务的修改操作。</p>
<p>在InnoDB中，行级锁是最常用的锁类型。当一个事务需要修改某一行数据时，它会先获取该行的排他锁。如果该行已经被其他事务持有锁，则当前事务会被阻塞，直到该锁被释放。如果一个事务只需要读取某一行数据，它会获取该行的共享锁。多个事务可以同时持有同一行的共享锁，但是任何一个事务持有了该行的排他锁，其他事务无法再获取该行的共享锁。</p>
<p>除了行级锁外，InnoDB还支持表级锁和页级锁。表级锁会锁定整张表，而页级锁会锁定表中的一页数据。但是表级锁和页级锁可能会导致并发性能下降，因此在实际应用中尽量避免使用。</p>
<h1 id="UDP协议的特点有哪些？"><a href="#UDP协议的特点有哪些？" class="headerlink" title="UDP协议的特点有哪些？"></a>UDP协议的特点有哪些？</h1><p>  一、UDP是无连接的，即通信时不需要创建连接（发送数据结束时也没有连接可以释放）所以减小了开销和发送数据前的时延；</p>
<p>二、UDP采用最大努力交付，不保证可靠交付，因此主机不需要维护复杂的连接状态；</p>
<p>三、UDP是面向报文的，只在应用层交下来的报文前增加了首部后就向下交付IP层；</p>
<p>四、UDP是无阻塞控制的，即使网络中存在阻塞，也不会影响发送端的发送频率</p>
<p>五、UDP支持一对一、一对多、多对一、多对多的交互通信</p>
<p>六、UDP的首部开销小，只有8个字节，它比TCP的20个字节的首部要短。</p>
<h1 id="TCP-x2F-IP四层模型是什么？"><a href="#TCP-x2F-IP四层模型是什么？" class="headerlink" title="TCP&#x2F;IP四层模型是什么？"></a>TCP&#x2F;IP四层模型是什么？</h1><p>第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等。<br>第二层：传输层，主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。<br>第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）<br>第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。</p>
<h1 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h1><p>以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。</p>
<p>数据范围： 读入的数字大小满足 <img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20%2010%5E%7B1000%7D" alt="img"></p>
<p>要求：空间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(m)" alt="O(m)">，时间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(m%5E2)" alt="O(m^2)">（假设m是n的长度）</p>
<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。例如：<br>两颗二叉树是:<br>                                                                    Tree 1</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821337680/9E290CFD3730B9B08A5CEFF25799608F" alt="img"></p>
<p>​                                                                        Tree 2<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821376266/DD0A63560E770A8510049C5182E6E622" alt="img"><br>​                                                                    合并后的树为<br><img src="https://uploadfiles.nowcoder.com/images/20210928/382300087_1632821404541/9CB750F8909D5985C0D01D8B71AD58BA" alt="img"></p>
<p>数据范围：树上节点数量满足 <img src="https://www.nowcoder.com/equation?tex=0%20%5Cle%20n%20%5Cle%20500" alt="img">，树上节点的值一定在32位整型范围内。</p>
<p>进阶：空间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(1)" alt="img"> ，时间复杂度 <img src="https://www.nowcoder.com/equation?tex=O(n)" alt="img"></p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/06/28/OOP-%E9%9A%90%E8%97%8F%E4%B8%8E%E8%A6%86%E7%9B%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/28/OOP-%E9%9A%90%E8%97%8F%E4%B8%8E%E8%A6%86%E7%9B%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-28 18:16:05" itemprop="dateCreated datePublished" datetime="2024-06-28T18:16:05+08:00">2024-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-11 18:49:36" itemprop="dateModified" datetime="2024-06-11T18:49:36+08:00">2024-06-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=188550&auto=1&height=66"></iframe>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hah"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hah</p>
  <div class="site-description" itemprop="description">我没有为你伤春悲秋不配有憾事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Jenwein" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jenwein" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rgw127310@gmail.com" title="E-Mail → mailto:rgw127310@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-4 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hah</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">313k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


    </div>
</body>
</html>
