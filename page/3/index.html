<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sword1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sword2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhahr.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:type" content="website">
<meta property="og:title" content="HahのBlog">
<meta property="og:url" content="http://rhahr.top/page/3/index.html">
<meta property="og:site_name" content="HahのBlog">
<meta property="og:description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rhahr.top/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HahのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Jenwein" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HahのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/05/19/linux-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/19/linux-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">linux调度程序</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-19 12:00:00 / 修改时间：19:06:44" itemprop="dateCreated datePublished" datetime="2024-05-19T12:00:00+08:00">2024-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6/" itemprop="url" rel="index"><span itemprop="name">服务调度</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="服务程序的调度程序"><a href="#服务程序的调度程序" class="headerlink" title="服务程序的调度程序"></a>服务程序的调度程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Using:./procctl timevl program argv ...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools/bin/procctl 10 /usr/bin/tar zcvf /tmp/tmp.tgz /usr/include\n&quot;</span>);</span><br><span class="line">  	    <span class="built_in">printf</span>(<span class="string">&quot;Example:/project/tools/bin/procctl 60 /project/idc/bin/crtsurfdata /project/idc/ini/stcode.ini /tmp/idc/surfdata /log/idc/crtsurfdata.log csv,xml,json\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;本程序是服务程序的调度程序，周期性启动服务程序或shell脚本。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;timetvl 运行周期，单位：秒。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        被调度的程序运行结束后，在timetvl秒后会被procctl重新启动。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        如果被调度的程序是周期性的任务，timetvl设置为运行周期。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        如果被调度的程序是常驻内存的服务程序，timetvl设置小于5秒。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;program 被调度的程序名，必须使用全路径。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;...     被调度的程序的参数。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;注意，本程序不会被kill杀死，但可以用kill -9强行杀死。\n\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭信号和I/O，本程序不希望被打扰。</span></span><br><span class="line">    <span class="comment">// 注意：1）为了防调度程序被误杀，不处理退出信号；</span></span><br><span class="line">    <span class="comment">//      2）如果忽略了信号和关闭了I/O，将影响被调度的程序（也会忽略和信号和关闭了I/O）。 </span></span><br><span class="line">    <span class="comment">//        why？因为被调度的程序取代了子进程，子进程会继承父进程的信号处理方式和I/O。</span></span><br><span class="line">    <span class="comment">//         IO及已经关闭的fd在exec后也会保持原有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">64</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">signal</span>(i,SIG_IGN);      <span class="comment">//忽略全部信号</span></span><br><span class="line">        <span class="built_in">close</span>(i);               <span class="comment">//关闭IO（0，1，2）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成子进程，父进程退出，让程序运行在后台，由系统1号进程托管，不受shell的控制</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    生成一个子进程并立即终止父进程之后，子进程继续原来父进程的流程，</span></span><br><span class="line"><span class="comment">    成为新的&quot;父进程&quot;，是被init进程管理的孤儿进程，在之后的循环中创建的进程相当于是子进程的子进程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(fork()!=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把子进程退出的信号SIGCHLD恢复为默认行为，让父进程可以调用wait()函数等待子进程退出。</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGCHLD,SIG_DFL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个和argv一样大的指针数组，存放被调度程序名及其参数。</span></span><br><span class="line">    <span class="type">char</span>* pargv[argc];        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;argc;i++)  </span><br><span class="line">        pargv[i<span class="number">-2</span>] = argv[i];   </span><br><span class="line"></span><br><span class="line">    pargv[argc<span class="number">-2</span>]=<span class="literal">nullptr</span>;<span class="comment">//空参数表示结尾“\0”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//pargv存放的是被调度程序以及其参数</span></span><br><span class="line">    <span class="comment">// argc     0        1           2       ...</span></span><br><span class="line">    <span class="comment">// argv: ./procctl  timevl    program    argv   </span></span><br><span class="line">    <span class="comment">//pargv: program    ...         ...     argc-2=&quot;\0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fork()==<span class="number">0</span>)  <span class="comment">//子进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//用argvp[2](被调度程序)来取代子进程（由pargv来传入参数）</span></span><br><span class="line">            <span class="built_in">execv</span>(argv[<span class="number">2</span>],pargv);   </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//只有当execv调度的程序运行失败才会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//父进程等待子进程终止（被调度的程序运行结束）。</span></span><br><span class="line">            <span class="comment">//int status;       //用于保存子进程的退出状态</span></span><br><span class="line">            <span class="comment">//wait (&amp;status);   //等待子进程退出并将退出状态保存在status中</span></span><br><span class="line">            <span class="built_in">wait</span>(<span class="literal">nullptr</span>);  <span class="comment">//wait阻塞父进程以等待子进程（被调度程序）的终止/返回</span></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));       <span class="comment">//休眠timevl后回到循环继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/05/16/%E5%BC%80%E5%8F%91-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/16/%E5%BC%80%E5%8F%91-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">linux信号</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-16 12:00:00 / 修改时间：10:40:32" itemprop="dateCreated datePublished" datetime="2024-05-16T12:00:00+08:00">2024-05-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/05/14/C++-snprintf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/14/C++-snprintf/" class="post-title-link" itemprop="url">snprintf</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-14 22:00:00" itemprop="dateCreated datePublished" datetime="2024-05-14T22:00:00+08:00">2024-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-16 10:42:24" itemprop="dateModified" datetime="2024-05-16T10:42:24+08:00">2024-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/snprintf/" itemprop="url" rel="index"><span itemprop="name">snprintf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="snprintf函数"><a href="#snprintf函数" class="headerlink" title="snprintf函数"></a>snprintf函数</h1><p>snprintf 函数是 C 语言标准库中的一个函数，用于将格式化的数据写入字符串。这个函数的原型定义在 &lt;stdio.h&gt; 头文件中，其基本语法如下：</p>
<p><code>int snprintf(char *str, size_t size, const char *format, ...);</code></p>
<p>其中，str 是指向用于存储结果字符串的缓冲区的指针，size 是缓冲区的最大大小（以字节为单位），format 是格式字符串，与 printf 函数中的格式字符串相同，后面的 … 表示可变数量的额外参数，这些参数与格式字符串中的格式占位符相对应。</p>
<p>这里需要注意的是第二个参数和这个函数的返回值。</p>
<ul>
<li>如果发生编码错误，snprintf 函数会返回一个负数。</li>
<li><strong>除此之外，不论缓冲区的大小是否足够放下结果字符串，都会返回如果缓冲区足够大，应该写入的字符总数</strong>，这个返回值包括了格式化字符串中所有的字符，但<strong>不包括终止的空字符</strong>。</li>
</ul>
<p>如果缓冲区不够大，实际写入的字符数会少于这个返回值，但函数仍然会返回完整的字符总数，以便程序员可以了解需要多大的缓冲区来容纳全部数据。</p>
<p>下面是一个简单的例子，演示 snprintf 函数的使用和返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), <span class="string">&quot;Number: %d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted string: &#x27;%s&#x27;\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Return value: %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果 buffer 足够大，snprintf 会返回格式化字符串的长度，不包括终止的空字符。如果 buffer 太小，无法容纳全部格式化后的数据，则返回的值将会是如果 buffer 足够大，本应写入的字符总数</p>
<p>知道了这样的特点，我们就可以通过先调用一次snprintf来获取需要的缓冲区大小，然后将其+1之后再来进行输出结果，就像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// 首先调用 snprintf 获取所需的缓冲区大小</span></span><br><span class="line">    <span class="type">int</span> needed = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;Number: %d&quot;</span>, num);</span><br><span class="line">    <span class="comment">// 根据需要的大小分配缓冲区</span></span><br><span class="line">    buffer = <span class="built_in">malloc</span>(needed + <span class="number">1</span>); <span class="comment">// 加1是为了空字符</span></span><br><span class="line">    <span class="comment">// 现在可以安全地写入数据</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buffer, needed + <span class="number">1</span>, <span class="string">&quot;Number: %d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Formatted string: &#x27;%s&#x27;\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Needed size: %d\n&quot;</span>, needed);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps：在别的地方看到有人说这个+1是平台或编译器相关的，windows不+1而linux要+1.。。。。然而实际上测试过发现都需要+1.</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/05/05/OpenGL-learnopengl%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/05/OpenGL-learnopengl%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Learn OpenGL 入门</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-05 22:00:00" itemprop="dateCreated datePublished" datetime="2024-05-05T22:00:00+08:00">2024-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-07 12:39:04" itemprop="dateModified" datetime="2024-05-07T12:39:04+08:00">2024-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">入门</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>学习也有两个多礼拜，结束了 <a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/intro/">LearnOpenGL CN </a>  的入门部分的学习，是时候总结整理一下了，按照整体创建一个图形的一系列步骤，大体上也是渲染管线的流程。全部使用面向过程来写</p>
<blockquote>
<p>详见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137780634">猴子也能看懂的渲染管线（Render Pipeline） - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="opengl是什么"><a href="#opengl是什么" class="headerlink" title="opengl是什么"></a>opengl是什么</h2><p>OpenGL本身并不是一个API，它仅仅是一个由<a target="_blank" rel="noopener" href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范(Specification)。</p>
<p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p>
<p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p>
<p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p>
<p>世界就是一个巨大的状态机，State Machine！！！！！</p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>有关配置及窗口部分不在赘述，重在理解各个对象</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>使用OpenGL绘制图形的流程大致可以分为以下几个步骤：</p>
<ol>
<li><strong>创建OpenGL上下文（Context）</strong>：在调用任何OpenGL指令之前，首先需要创建一个OpenGL上下文。这个上下文是一个庞大的状态机，保存了OpenGL中的各种状态，是OpenGL指令执行的基础。</li>
<li><strong>设置帧缓冲区（FrameBuffer）</strong>：帧缓冲区相当于画板，它不是实际存储数据的对象，而是提供了附着点（Attachment），可以附着纹理（Texture）或渲染缓冲区（RenderBuffer）。</li>
<li><strong>准备顶点数据和缓冲区</strong>：顶点数据是图形的骨架，可以存储在顶点数组（VertexArray）中，也可以预先传入显存中的顶点缓冲区（VertexBuffer）。</li>
<li><strong>设置索引数据和缓冲区</strong>：索引数据（ElementArray）可以实现顶点的复用，提高效率。它们可以存储在索引缓冲区（ElementBuffer）中。</li>
<li><strong>编写和编译着色器程序（Shader）</strong>：现代OpenGL使用可编程渲染管线，需要编写顶点着色器（VertexShader）和片段着色器（FragmentShader），然后将它们编译成着色器程序。</li>
<li><strong>设置渲染管线和绘制命令</strong>：配置好渲染管线后，使用绘制命令如<code>glDrawArrays</code>或<code>glDrawElements</code>来执行绘制操作。</li>
<li><strong>渲染到屏幕</strong>：经过光栅化等一系列处理后，图形最终会渲染到屏幕上。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>从代码开始</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/* Initialize the library */</span></span><br><span class="line">	<span class="comment">//初始化GLFW</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//指定版本</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* glsl_version = <span class="string">&quot;#version 330 core&quot;</span>;</span><br><span class="line">   <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号(Major)</span></span><br><span class="line">   <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号(Minor)</span></span><br><span class="line">   <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//核心模式(Core-profile)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">   window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (!window)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">glfwTerminate</span>();</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">   <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"><span class="comment">//启用垂直同步</span></span><br><span class="line">   <span class="built_in">glfwSwapInterval</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误检查</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">glewInit</span>()!=GLEW_OK) </span><br><span class="line">       std::cout&lt;&lt;<span class="string">&quot;Error \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">   std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;<span class="comment">//输出当前显卡配置版本</span></span><br></pre></td></tr></table></figure>

<p>这部分在最开始，初始化glfw，指定版本（核心模式） ，创建窗口，创建上下文，启用垂直同步。</p>
<h3 id="开始！"><a href="#开始！" class="headerlink" title="开始！"></a>开始！</h3><p>开始绘制图形之前，我们需要先给OpenGL输入一些顶点数据,OpenGL仅当3D坐标在3个轴（x、y和z）上-1.0到1.0的范围内时才处理,所有在这个范围内的坐标叫做标准化设备坐标,</p>
<p>希望渲染一个三角形，就要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">		<span class="comment">//位置			     //颜色            //纹理    </span></span><br><span class="line">		<span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">1.0f</span>,     <span class="comment">// 右上角</span></span><br><span class="line">		<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>,<span class="number">0.0f</span>,     <span class="comment">// 右下角</span></span><br><span class="line">	   <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>,<span class="number">0.0f</span>,     <span class="comment">// 左下角</span></span><br><span class="line">	   <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>,<span class="number">1.0f</span>     <span class="comment">// 左上角</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> index[] = &#123;</span><br><span class="line">		<span class="comment">// 注意索引从0开始!</span></span><br><span class="line">		<span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line">		<span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,  <span class="comment">// 第一个三角形</span></span><br><span class="line">		<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,  <span class="comment">// 第二个三角形</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的两个数组分别对应的VB和IB</p>
<p>vertices存放所有的顶点，每一行代表一个<strong>顶点</strong>，每个顶点有三个<strong>顶点属性</strong>，分别为<strong>位置</strong>，<strong>颜色</strong>，<strong>纹理</strong></p>
<p><strong>位置属性负责指定顶点位置，颜色属性指定顶点颜色，纹理属性指定纹理与顶点的映射</strong></p>
<p>index存放索引，用于指定或是说告诉GPU如何使用顶点，这里表示使用第0,1,3 和第1,2,3这几个顶点绘制两个三角形，然后指定出了一个矩形</p>
<h3 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3><p>先指定一个VAO，**Vertex Array Object（顶点数组对象） ** ，用于管理和优化顶点数据的存储和访问，可以说VAO绑定期间内的其他所有的VBO和IBO的状态都会被VAO保存（状态机）</p>
<p><img src="http://cdn.rhahr.asia/vertex_array_objects_ebo.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);<span class="comment">//生成1个VA并返回id给VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//绑定VAO</span></span><br></pre></td></tr></table></figure>

<h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><p>绑定可以理解为插到一个对应的插槽上，例如这里就是将VBO绑定在GL_ARRAY_BUFFER这个插槽上，之后任何对GL_ARRAY_BUFFER的操作就相当于是对这个VBO的操作，同时也意味着，如果要对另一个VBO操作就需要将另一个VBO绑定在这个插槽上，（IBO同理）</p>
<p>顶点缓冲对象类型：GL_ARRAY_BUFFER</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);				<span class="comment">//生成1个buffer并返回id给VBO</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);	  <span class="comment">//绑定VBO到GL_ARRAY_BUFFER上</span></span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), &amp;vertices, GL_STATIC_DRAW);<span class="comment">//把用户定义的数据复制到当前绑定缓冲的函数</span></span><br><span class="line"><span class="comment">//有一些顶点数据存储在 position 中，把这些数据的大小为 6 * sizeof(float) 的部分传输到GPU（buffer）。多次使用这些数据来绘制，但不会对它们进行修改</span></span><br></pre></td></tr></table></figure>

<h3 id="IBO"><a href="#IBO" class="headerlink" title="IBO"></a>IBO</h3><p>此处的GL_ELEMENT_ARRAY_BUFFER就是另一个插槽，</p>
<p>索引缓冲对象类型：GL_ELEMENT_ARRAY_BUFFER</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> IBO;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;IBO);		<span class="comment">//生成1个buffer并返回id给IBO</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);<span class="comment">//绑定VBO到GL_ELEMENT_ARRAY_BUFFER上</span></span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(index), &amp;index, GL_STATIC_DRAW);<span class="comment">//将索引数据复制到缓冲中-告诉GPU使用这几个索引来绘制</span></span><br></pre></td></tr></table></figure>

<h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p>VBO和IBO已经告诉了GPU如何绘制这个图形，接下来给这个图形添加纹理，在开始部分的顶点属性中的<strong>位置，颜色，纹理</strong> 我们已经完成了前两个的设置，</p>
<p>我们已经知道可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p>
<p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);<span class="comment">//上下翻转，因为纹理种坐标左下角为(0,0)，可能会上下颠倒</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* data0 = <span class="built_in">stbi_load</span>(<span class="string">&quot;res/texture/bbb.png&quot;</span>, &amp;width0, &amp;height0, &amp;nrChannels0, <span class="number">4</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* data1 = <span class="built_in">stbi_load</span>(<span class="string">&quot;res/texture/aaa.png&quot;</span>, &amp;width1, &amp;height1, &amp;nrChannels1, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先接受一个图像文件的位置作为输入，接下来它需要三个int用，图像的宽度、高度和颜色通道的个数填充这三个变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="纹理绑定"><a href="#纹理绑定" class="headerlink" title="纹理绑定"></a>纹理绑定</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture0;<span class="comment">//与vbo，vao，ibo类似，都是使用id引用</span></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture0);<span class="comment">//生成纹理id并传入texture</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture0);<span class="comment">//绑定纹理</span></span><br></pre></td></tr></table></figure>
<h4 id="纹理设置"><a href="#纹理设置" class="headerlink" title="纹理设置"></a>纹理设置</h4><p>设置当前纹理的环绕&amp;过滤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前纹理的环绕</span></span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<span class="comment">//为当前绑定在GL_TEXTURE_2D上的纹理的s轴进行GL_REPEAT的环绕方式</span></span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<span class="comment">//为当前绑定在GL_TEXTURE_2D上的纹理的t轴进行GL_REPEAT的环绕方式</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//设置当前纹理的过滤</span></span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<span class="comment">//为当前绑定在GL_TEXTURE_2D上的纹理的放大行为设置GL_LINEAR_MIPMAP_LINEAR的多级渐远纹理方式</span></span><br><span class="line">	<span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理</span></span><br><span class="line"><span class="comment">	  主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产</span></span><br><span class="line"><span class="comment">	  生一个GL_INVALID_ENUM错误代码。*/</span></span><br></pre></td></tr></table></figure>
<p>现在已经有了准备好的图片数据data和设置好的纹理texture，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data0)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width0, height0, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data0);<span class="comment">//使用载入的图片数据生成纹理</span></span><br><span class="line">	</span><br><span class="line">       <span class="comment">//target，多级渐远纹理级别，纹理存储格式，最终的纹理的宽度和高度，0，原图的格式及数据类型，图像数据（stbi_load获取）</span></span><br><span class="line">	<span class="comment">//目前只有基本级别(Base-level)的纹理图像被加载了，要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）</span></span><br><span class="line">	<span class="comment">//或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</span></span><br><span class="line">	<span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<span class="comment">//这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成纹理的过程总体是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);<span class="comment">//释放图像的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="着色器代码"><a href="#着色器代码" class="headerlink" title="着色器代码"></a>着色器代码</h3><p>目前阶段的渲染管线中只需要关心顶点着色器和片段着色器，着色器语言GLSL。</p>
<p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。</p>
<p>一个示例结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现输入和输出，进行数据交流和传递。</p>
<p>顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据（VB）中直接接收输入，为了定义顶点数据该如何管理，我们使用<code>location</code>这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，<code>layout (location = 0)</code>。顶点着色器需要为它的输入提供一个额外的<code>layout</code>标识，这样我们才能把它链接到顶点数据。</p>
<p>如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* vertexshadersource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string">layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="string">layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1</span></span><br><span class="line"><span class="string">layout (location = 2) in vec2 aTexCoord; //纹理变量的属性位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec3 ourColor; // 向片段着色器输出一个颜色</span></span><br><span class="line"><span class="string">out vec2 TexCoord; // 向片段着色器输出一个纹理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//uniform mat4 transform;</span></span><br><span class="line"><span class="string">uniform mat4 model;</span></span><br><span class="line"><span class="string">uniform mat4 view;</span></span><br><span class="line"><span class="string">uniform mat4 proj;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform mat4 u_MVP;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    gl_Position = u_MVP * vec4(aPos, 1.0f);</span></span><br><span class="line"><span class="string">    ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line"><span class="string">	TexCoord = aTexCoord;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* fragmentshadersource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string">out vec4 FragColor;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec3 ourColor;</span></span><br><span class="line"><span class="string">in vec2 TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform sampler2D ourTexture0;</span></span><br><span class="line"><span class="string">uniform sampler2D ourTexture1;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    //FragColor = vec4(ourColor, 1.0);//为了片段插值提供数据</span></span><br><span class="line"><span class="string">	//FragColor = texture(ourTexture, TexCoord);//GLSL内建的texture函数来采样纹理的颜色</span></span><br><span class="line"><span class="string">	//FragColor = texture(ourTexture0, TexCoord)*vec4(ourColor,1.0);//把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色</span></span><br><span class="line"><span class="string">	FragColor = mix(texture(ourTexture0,TexCoord),texture(ourTexture1,TexCoord),0.4);//mix函数需要接受两个值作为参数,并对它们根据第三个参数进行线性插值,0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>有了着色器代码就可以开始定义着色器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的着色器对象，并返回一个可以引用它的非零值	</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader; </span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);	</span><br><span class="line"></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexshadersource, <span class="literal">NULL</span>);<span class="comment">//把这个着色器源码附加到着色器对象,要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">// 编译着色器</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentshadersource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>创建一个程序对象很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//创建一个程序并返回id</span></span><br></pre></td></tr></table></figure>

<p>把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>着色器对象链接到程序对象以后，删除着色器对象，不再需要它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。</p>
<h3 id="应用属性"><a href="#应用属性" class="headerlink" title="应用属性"></a>应用属性</h3><p><img src="https://learnopengl-cn.github.io/img/01/06/vertex_attribute_pointer_interleaved_textures.png" alt="img"></p>
<p>glVertexAttribPointer用于指定这些属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置顶点位置属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);<span class="comment">//在这里的第一个参数使vao保存了vbo中数据应该有的状态！！！！！</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置顶点颜色属性指针</span></span><br><span class="line"><span class="comment">//glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));</span></span><br><span class="line"><span class="comment">//glEnableVertexAttribArray(1);</span></span><br><span class="line"><span class="comment">//设置顶点纹理属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)吗？layout就是这里的顶点属性的标号，对应position中的顶点，从前到后为位置，颜色，纹理，所以分别为0，1，2</li>
<li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li>
<li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li>
<li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>float</code>之后，我们把步长设置为<code>3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</li>
<li>最后一个参数的类型是<code>void*</code>，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li>
</ul>
</blockquote>
<h3 id="摄影机"><a href="#摄影机" class="headerlink" title="摄影机"></a>摄影机</h3>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/29/linux-shm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/linux-shm/" class="post-title-link" itemprop="url">共享内存</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 22:00:00" itemprop="dateCreated datePublished" datetime="2024-04-29T22:00:00+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-20 17:01:40" itemprop="dateModified" datetime="2024-05-20T17:01:40+08:00">2024-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>多线程共享进程的地址空间，如果多个线程需要访问同一块内存，用全局变量就可以了。</p>
<p>在多进程中，每个进程的地址空间是独立的，不共享的，如果多个进程需要访问同一块内存，不能用全局变量，只能用共享内存。</p>
<hr>
<p>在C++和Linux系统编程中，共享内存是一种有效的进程间通信（IPC）机制，它允许两个或多个进程访问同一块物理内存区域。这种方式非常高效，因为它避免了数据在进程间的复制，直接通过内存进行数据交换。</p>
<p>共享内存的基本操作通常涉及以下几个步骤：</p>
<ol>
<li><p><strong>创建共享内存</strong>: 使用<code>shmget</code>函数创建一个新的共享内存段或访问一个已经存在的共享内存段。这个函数返回一个与共享内存段相关联的标识符（shmid）。</p>
<p><code>#include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt;  int shmid = shmget(key, size, IPC_CREAT | 0666); </code></p>
</li>
<li><p><strong>将共享内存附加到进程地址空间</strong>: 使用<code>shmat</code>函数，可以将共享内存段附加到调用进程的地址空间中，这样进程就可以像访问普通内存一样访问共享内存。</p>
<p><code>void *shm_ptr = shmat(shmid, NULL, 0); </code></p>
</li>
<li><p><strong>访问共享内存</strong>: 一旦共享内存被附加，进程就可以像使用普通指针一样使用返回的指针来访问共享内存。</p>
</li>
<li><p><strong>分离共享内存</strong>: 当进程完成对共享内存的使用后，应该使用<code>shmdt</code>函数将共享内存从进程的地址空间中分离。</p>
<p><code>shmdt(shm_ptr); </code></p>
</li>
<li><p><strong>控制共享内存</strong>: <code>shmctl</code>函数用于执行对共享内存的各种控制操作，如获取共享内存的状态，设置共享内存的状态或删除共享内存段。</p>
<p><code>shmctl(shmid, IPC_RMID, NULL); </code></p>
</li>
</ol>
<p>需要注意的是，共享内存不提供任何内置的同步机制，因此在多个进程访问同一共享内存时，需要使用其他同步方法（如信号量）来避免竞态条件和数据不一致的问题。</p>
<h2 id="linux中的共享内存"><a href="#linux中的共享内存" class="headerlink" title="linux中的共享内存"></a>linux中的共享内存</h2><h3 id="一、shmget函数"><a href="#一、shmget函数" class="headerlink" title="一、shmget函数"></a>一、shmget函数</h3><p>该函数用于创建&#x2F;获取共享内存。</p>
<p>int shmget(key_t key, size_t size, int shmflg);</p>
<p>key       共享内存的键值，是一个整数（typedef unsigned int key_t），一般采用十六进制，例如0x5005，不同共享内存的key不能相同。</p>
<p>size      共享内存的大小，以字节为单位。</p>
<p>shmflg  共享内存的访问权限，与文件的权限一样，例如0666|IPC_CREAT，0666表示全部用户对它可读写，IPC_CREAT表示如果共享内存不存在，就创建它。</p>
<p>返回值：成功返回共享内存的id（一个非负的整数），失败返回-1（系统内存不足、没有权限）</p>
<p>用ipcs -m可以查看系统的共享内存，包括：键值（key），共享内存id（shmid），拥有者（owner），权限（perms），大小（bytes）。                   </p>
<p>用ipcrm -m 共享内存id可以手工删除共享内存</p>
<h3 id="二、shmat函数"><a href="#二、shmat函数" class="headerlink" title="二、shmat函数"></a>二、shmat函数</h3><p>该函数用于把共享内存连接到当前进程的地址空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">stprocinfo</span>* m_shm;</span><br><span class="line">m_shm = (<span class="keyword">struct</span> stprocinfo*)<span class="built_in">shmat</span>(m_shmid,<span class="number">0</span>,<span class="number">0</span>))==(<span class="type">void</span>*)<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>shmid</strong>:<ul>
<li>这是由<code>shmget</code>函数返回的共享内存标识符，用于指定要附加的共享内存段。</li>
</ul>
</li>
<li><strong>shmaddr</strong>:<ul>
<li>这个参数指定共享内存附加到进程地址空间的具体地址。它有三种情况：<ul>
<li>如果<code>shmaddr</code>是<code>NULL</code>，系统会自动选择一个合适的（即任意的）地址进行附加。</li>
<li>如果<code>shmaddr</code>不是<code>NULL</code>且没有指定<code>SHM_RND</code>，共享内存会被连接到<code>shmaddr</code>所指定的地址上。</li>
<li>如果<code>shmaddr</code>非<code>NULL</code>且指定了<code>SHM_RND</code>，则共享内存会连接到<code>shmaddr</code>减去<code>shmaddr</code>模<code>SHMLBA</code>的结果所表示的地址上。<code>SHMLBA</code>是系统定义的一个常量，表示共享内存段的最低对齐地址。</li>
</ul>
</li>
</ul>
</li>
<li><strong>shmflg</strong>:<ul>
<li>这个参数用于控制共享内存的不同行为，例如：<ul>
<li>如果在<code>shmflg</code>中指定了<code>SHM_RDONLY</code>，则共享内存以只读方式连接。</li>
<li>如果没有指定<code>SHM_RDONLY</code>，则以读写方式连接。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>调用成功时返回共享内存起始地址，失败返回(void*)-1。</p>
<h3 id="三、shmdt函数"><a href="#三、shmdt函数" class="headerlink" title="三、shmdt函数"></a>三、shmdt函数</h3><p>该函数用于将共享内存从当前进程中分离，相当于shmat()函数的反操作。</p>
<p>int shmdt(const void *shmaddr);</p>
<p>shmaddr     shmat()函数返回的地址。</p>
<p>调用成功时返回0，失败时返回-1。</p>
<h3 id="四、shmctl函数"><a href="#四、shmctl函数" class="headerlink" title="四、shmctl函数"></a>四、shmctl函数</h3><p>该函数用于操作共享内存，最常用的操作是删除共享内存。</p>
<p>int shmctl(int shmid, int command, struct shmid_ds *buf);</p>
<p>shmid          shmget()函数返回的共享内存id。</p>
<p>command   操作共享内存的指令，如果要删除共享内存，填IPC_RMID。</p>
<p>buf               操作共享内存的数据结构的地址，如果要删除共享内存，填0。</p>
<p>调用成功时返回0，失败时返回-1。</p>
<p><strong>注意，用root创建的共享内存，不管创建的权限是什么，普通用户无法删除。</strong></p>
<p>共享内存是一种特殊的内存区域，它是在系统的物理内存中分配的，而不是在进程的栈或堆上。共享内存的目的是允许多个进程访问同一块内存区域，以便快速地交换数据，而不需要通过进程间通信的其他方式（如管道或消息队列）来复制数据。所以不能够使用C++的STL类型，因为类似vector会在堆上分配内存。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Using:./demo num name\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建共享内存shm并返回id</span></span><br><span class="line">    <span class="type">int</span> shmid=<span class="built_in">shmget</span>(<span class="number">0x5005</span>,<span class="built_in">sizeof</span>(Entity),<span class="number">0640</span>|IPC_CREAT);<span class="comment">//键值，大小，权限</span></span><br><span class="line">    <span class="keyword">if</span>(shmid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;shmget(0x5005)failed.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;shmid = &quot;</span>&lt;&lt;shmid&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接到当前进程</span></span><br><span class="line"><span class="comment">//返回共享内存起始地址，失败返回(void*)-1。</span></span><br><span class="line">Entity* ptr=(Entity*)<span class="built_in">shmat</span>(shmid,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//内存空间id，指定共享内存连接到当前进程中的位置，标&gt;志位</span></span><br><span class="line"><span class="keyword">if</span>(ptr == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;shmat failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;old num = &quot;</span>&lt;&lt;ptr-&gt;num&lt;&lt;<span class="string">&quot; old name = &quot;</span>&lt;&lt;ptr-&gt;name&lt;&lt;std::endl;</span><br><span class="line">ptr-&gt;num=<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">strcpy</span>(ptr-&gt;name,argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;new num = &quot;</span>&lt;&lt;ptr-&gt;num&lt;&lt;<span class="string">&quot; new name = &quot;</span>&lt;&lt;ptr-&gt;name&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分离共享内存与当前进程</span></span><br><span class="line"><span class="built_in">shmdt</span>(ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除共享内存</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid,IPC_RMID,<span class="number">0</span>)==<span class="number">-1</span>)</span><br><span class="line"> std::cout&lt;&lt;<span class="string">&quot;shmctl failed\n&quot;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/14/C++-conversionoperator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/C++-conversionoperator/" class="post-title-link" itemprop="url">类型转换运算符</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-14 12:00:00 / 修改时间：14:37:19" itemprop="dateCreated datePublished" datetime="2024-04-14T12:00:00+08:00">2024-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h1><p>类型转换运算符，它允许类对象在特定上下文中被隐式地转换为布尔值。这种语法可以提高代码的可读性和简洁性，适合用于需要检查对象是否有效或满足特定条件的情况下</p>
<p><strong>类型转换运算符</strong>（Type Conversion Operator）允许您自定义类如何转换为其他类型，从而更好地控制隐式类型转换。它是一种特殊成员函数，用于将一个类类型的值转换成其他类型。通过显式定义这样的转换，您可以明确指定在哪些情况下可以进行类型转换，以及如何执行转换。</p>
<p>以下是关于类型转换运算符的一些重要点：</p>
<ol>
<li><strong>显式类型转换</strong>：类型转换运算符允许您显式地将一个类对象转换为特定类型。这是一种用户定义的过程，可以通过两种方式来实现：<ul>
<li><strong>赋值转换</strong>：通过在括号中显式定义所需类型来执行。这也可以被视为强制转换。</li>
<li><strong>类型转换运算符</strong>：允许显式转换为特定类型。</li>
</ul>
</li>
<li><strong>隐式类型转换</strong>：由编译器自动执行，无需用户的外部触发。通常在表达式中存在多个数据类型时发生。隐式类型转换会影响基本数据类型，并允许在数值类型之间进行转换，或者与bool和某些指针进行转换。</li>
<li><strong>类型转换运算符的语法</strong>：<ul>
<li>类型转换运算符是一种特殊的成员函数，其名称以<code>operator</code>关键字开头，后面跟着要转换的目标类型。</li>
<li>它没有返回类型，但在函数体中，您需要将当前类对象转换为目标类型并返回。</li>
</ul>
</li>
</ol>
<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><p>类型转换运算符的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">target_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>target_type</code> 是要转换的目标类型，可以是基本数据类型、类类型或枚举类型。<code>const</code> 关键字表明这是一个常量成员函数，它不会修改对象的状态。</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>类型转换运算符允许对象在特定上下文中被隐式地转换为目标类型。这使得代码更加灵活，可以在不同的语境中使用对象。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong>隐式类型转换</strong>：当对象出现在需要目标类型的上下文中时，编译器会自动调用类型转换运算符进行隐式转换。</li>
<li><strong>显式类型转换</strong>：也可以通过显式调用类型转换运算符来进行类型转换，使用类似于函数调用的语法。</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><strong>避免滥用</strong>：尽管类型转换运算符提供了方便，但过度使用可能导致代码难以理解。应该仅在逻辑上合理且直观的情况下使用。</li>
<li><strong>避免歧义</strong>：类型转换运算符可能会导致代码的歧义性，应该避免与其他重载运算符产生混淆。</li>
<li><strong>注意 const</strong>：类型转换运算符通常声明为 const 成员函数，以确保它不会修改对象的状态。</li>
</ul>
<h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换运算符将对象转换为 int 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">myInt</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="type">int</span> intValue = myInt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式类型转换</span></span><br><span class="line">    <span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(myInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyInt</code> 类定义了一个将对象转换为 <code>int</code> 类型的类型转换运算符 <code>operator int()</code>。在 <code>main()</code> 函数中，我们展示了如何使用隐式和显式类型转换来将 <code>MyInt</code> 对象转换为不同类型的值。</p>
<h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p>在实际情况中，例如我们有一个作用域指针ScopePtr，类似于智能指针，其具体内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> X = <span class="number">0.0f</span>, Y = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ScopedPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">ScopedPtr</span>(T* ptr)</span><br><span class="line">		:<span class="built_in">m_Ptr</span>(ptr)&#123;&#125;</span><br><span class="line">	~<span class="built_in">ScopedPtr</span>()&#123;<span class="keyword">delete</span> m_Ptr;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* m_Ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们在使用ScopePtr的时候，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScopedPtr&lt;Entity&gt;e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure>

<p>我们会需要检验e是否是一个有效指针，直接的办法是像下面这样直接检验其指向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entity != <span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (entity) &#123;&#125;;<span class="comment">//C++标准规定，非零指针被视为“真”，而空指针被视为“假”</span></span><br></pre></td></tr></table></figure>

<p>在这里if(entity)有效是因为Entity *它只是一个指向 <code>Entity</code> 对象的裸指针，指针类型（例如 <code>Entity*</code>）可以隐式转换为布尔值。</p>
<p>如果这里是if(e)的话就会报错 “ 表达式必须包含 bool 类型(或可转换为 bool) “ ，也就是说<code>ScopedPtr&lt;Entity&gt;</code> 类型不会隐式转换为布尔值，因为它没有定义与布尔类型之间的间的隐式转换。</p>
<p>如果您想将 <code>ScopedPtr&lt;Entity&gt;</code> 转换为布尔值，您需要显式定义一个类型转换运算符或使用其他方法。</p>
<ol>
<li>其他方法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr != <span class="literal">NULL</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在类中添加该检验方法</p>
<ol start="2">
<li>类型转换运算符</li>
</ol>
<p>在类中定义这个类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">IsValid</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>这也就是以为着允许ScopePtr类型转换为bool类型，是添加了一种隐式转换的规则，如果你查看unique_ptr的定义就会发现其中也有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">get</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>需要注意的是，这样的语法因为是为了隐式转换，所以会带来语义不清晰的问题，程序重要的可读性大大下降，例如：我们有一个Timer类是用来计算时间的，通过GetSeconds和GetMilliseconds可以得到花费时间的秒&#x2F;毫秒</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> Clock= std::chrono::high_resolution_clock;</span><br><span class="line">	<span class="keyword">using</span> TimePoint = std::chrono::time_point&lt;Clock&gt;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123; m_Start = Clock::<span class="built_in">now</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; m_Stop = Clock::<span class="built_in">now</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetSeconds</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;microseconds&gt;(m_Stop - m_Start).<span class="built_in">count</span>() * <span class="number">0.001f</span> * <span class="number">0.001f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetMilliseconds</span> <span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;microseconds&gt;(m_Stop - m_Start).<span class="built_in">count</span>() * <span class="number">0.001f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::chrono::high_resolution_clock::time_point start, end;</span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetSeconds</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TimePoint m_Start,m_Stop;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Timer timer;</span><br><span class="line">	timer.<span class="built_in">Start</span>();</span><br><span class="line">	timer.<span class="built_in">Stop</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="type">double</span> time0 = timer;</span><br><span class="line">	<span class="type">double</span> time1 = timer.<span class="built_in">GetSeconds</span>();</span><br><span class="line">	<span class="type">double</span> time2 = timer.<span class="built_in">GetMilliseconds</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且我们使用了类型转换运算符operator double()const { return GetSeconds(); }，这样的话我们在使用timer的时候可以直接像下面main中的time0一样，直接将Timer类型转换为double类型，虽然看着简洁了，但是我们无法从中获取一些应该的信息，也许我们可以考虑在time0上添加一行注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是秒</span></span><br></pre></td></tr></table></figure>

<p>相比于time1和time2这种直接在实际方法名称即可标注作用的版本来说，很呆，所以不能滥用</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/10/linux-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/linux-process/" class="post-title-link" itemprop="url">linux进程创建</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-10T12:00:00+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:06:09" itemprop="dateModified" datetime="2024-05-19T19:06:09+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h3><p><code>fork</code> 是 Unix 和类 Unix（比如 Linux）操作系统中用来创建新进程的一个系统调用。当一个进程（通常称为父进程）调用 <code>fork</code> 时，它创建了一个新的进程（称为子进程）。子进程几乎是父进程的完整副本：它包含了父进程的数据、代码、堆和栈的复制。</p>
<p>下面详细解释下 <code>fork</code> 的行为和用法：</p>
<ol>
<li><strong>如何工作：</strong><ul>
<li><code>fork</code> 创建一个与当前进程几乎完全相同的新进程。</li>
<li>子进程获得与父进程相同的数据副本（但是它拥有自己的数据空间）。</li>
<li>两个进程（父子）继续从 <code>fork</code> 调用返回的地方独立运行。</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li>父进程中，<code>fork</code> 返回新创建的子进程的进程标识符（PID），如果 <code>fork</code> 调用失败，则返回 -1。</li>
<li>在子进程中，<code>fork</code> 返回 0 表示成功创建。</li>
<li>这种方式允许父进程和子进程检测谁是谁，并决定后续的行动。</li>
</ul>
</li>
<li><strong>后续操作：</strong><ul>
<li>一旦 <code>fork</code> 成功，两个进程就可能做一些完全不同的事情。</li>
<li>子进程常常通过 <code>exec</code> 系列函数替换其进程映像来执行与父进程不同的程序。</li>
<li>父进程可能继续创建更多的子进程，或者等待子进程的完成。</li>
</ul>
</li>
<li><strong>资源共享：</strong><ul>
<li><code>fork</code> 后，父子进程在初期共享相同的物理内存页，这是一种称为写时复制（Copy-On-Write, COW）的优化技术。</li>
<li>如果一个进程尝试修改共享的内存，操作系统会为这个进程创建这个内存页的私有副本，保证不同进程的内存空间是隔离的。</li>
</ul>
</li>
<li><strong>文件描述符：</strong><ul>
<li><strong>子进程会继承父进程的文件描述符。如果父进程打开了文件或网络连接，子进程会共有这些资源的访问。</strong></li>
<li>文件描述符计数会增加，确保除非所有相关进程都关闭了文件描述符，否则资源不会释放。</li>
</ul>
</li>
<li><strong>进程状态：</strong><ul>
<li><strong>子进程会继承父进程的进程状态。这包括信号处理方式、进程优先级以及控制终端等。</strong></li>
</ul>
</li>
<li><strong>用例和限制：</strong><ul>
<li><code>fork</code> 被广泛用于创建后台进程或者守护进程。</li>
<li><code>fork</code> 在创建新进程时有一定资源消耗，尽管有 COW 技术，频繁的 <code>fork</code> 和执行可能会降低系统性能。</li>
</ul>
</li>
</ol>
<p>总结来讲，<code>fork</code> 是 Unix 系统进程创建中最基本和最重要的操作之一。通过 <code>fork</code> 调用，系统能够基于现存的进程创建新进程，这是构建多进程应用的基石。</p>
<h3 id="信号和I-x2F-O的继承"><a href="#信号和I-x2F-O的继承" class="headerlink" title="信号和I&#x2F;O的继承"></a><strong>信号和I&#x2F;O的继承</strong></h3><p>进程的切换及创建主要是由fork和exec族函数实现的，一个是创建出子进程，另一个是用一个新的进程来取代当前进程</p>
<ul>
<li><strong>I&#x2F;O状态</strong>：在<code>exec</code>执行后，所有已经关闭的文件描述符（fd）会保持关闭状态。如果文件描述符在<code>exec</code>执行前没有被关闭，它们默认会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志或者在<code>exec</code>之前显式地关闭它们。</li>
<li><strong>信号处理</strong>：<code>fork</code>创建的子进程会继承父进程的信号处理方式。但是，当<code>exec</code>系列函数执行时，大多数信号的处理方式会被重置为默认值（<code>SIG_DFL</code>），除非信号处理方式被设置为忽略（<code>SIG_IGN</code>），这种情况下会被保留。这是因为新程序可能没有定义原先的信号处理函数，所以继承的信号处理函数地址可能在新程序中没有意义。</li>
<li><strong>信号屏蔽字</strong>：<code>fork</code>之后，子进程会继承父进程的信号屏蔽字，即使在<code>exec</code>之后，这个信号屏蔽字也会被保留。</li>
<li><strong>文件描述符</strong>：默认情况下，所有打开的文件描述符在<code>execv</code>执行后都会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志，或者在<code>execv</code>之前显式地关闭它们。在你的代码中，由于使用了<code>close(i)</code>关闭了所有文件描述符，这些操作会影响到<code>execv</code>执行的新程序，因为新程序将不会继承这些已经关闭的文件描述符。</li>
</ul>
<h3 id="写时拷贝（COW）"><a href="#写时拷贝（COW）" class="headerlink" title="写时拷贝（COW）"></a>写时拷贝（COW）</h3><p>Copy-On-Write（写时复制）是操作系统在进行进程创建和内存管理时用到的一种优化技术。写时复制允许操作系统在必要时才复制内存数据，而不是在每次进程创建时都进行复制，从而提高效率和节省资源。</p>
<p>具体来说，在一个进程执行 <code>fork()</code> 系统调用创建子进程时，操作系统并不立即将父进程的内存数据完全复制一份给子进程。相反，它会让父进程和子进程共享同一片物理内存区域，并<strong>设置这些内存区域为只读</strong>。这时，父子进程实际上是读取同一份数据。</p>
<p>当其中一个进程<strong>尝试修改这些共享的内存数据时</strong>，操作系统会使用写时复制技术进行处理。在修改动作发生的那一刻，操作系统会<strong>创建一个新的内存页面的副本，然后将修改应用于这个副本上，同时更新该进程的内存页表</strong>，确保它指向这个新的、已修改的内存页。其它未被修改的部分仍然保持共享状态。这个过程对于进程本身是透明的，进程不会意识到内存的这种管理方式。</p>
<p>写时复制技术的优点包括：</p>
<ol>
<li><strong>节约内存</strong>：只有在必要的情况下才复制内存页面，因而节约了大量内存资源。</li>
<li><strong>提高效率</strong>：由于初始时不需要复制整个进程空间，<code>fork()</code> 调用可以迅速完成。</li>
<li><strong>优化响应时间</strong>：复制操作是按需进行的，这可以减少进程创建或页面写入时的延迟。</li>
<li><strong>方便内存管理</strong>：当多个进程读取相同的数据时，内存利用率更高。</li>
</ol>
<p>写时复制技术最常见的用途之一就是在 <code>fork()</code> 调用中。它也被虚拟化技术广泛采用，比如在虚拟机和容器技术中，来优化多个虚拟环境共享宿主机资源时的效率和性能。</p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><p>进程映像（Process Image）指的是一个进程在操作系统中所拥有的，与其运行相关的所有资源和信息的集合。这包括但不限于：</p>
<ol>
<li><strong>程序代码</strong>（text segment）：执行的机器语言代码。</li>
<li><strong>数据段</strong>（data segment）：包括全局变量、静态变量等。</li>
<li><strong>堆</strong>（heap）：动态分配的内存，如 C 语言中通过 <code>malloc</code> 分配得到的内存。</li>
<li><strong>栈</strong>（stack）：函数调用时使用的内存，包括局部变量、函数参数、返回地址等。</li>
<li><strong>执行上下文</strong>（context）：包括程序计数器（PC）、寄存器、系统状态字等，这些是CPU执行指令时的当前状态信息。</li>
<li><strong>文件描述符表</strong>：该进程打开的所有文件和网络连接的索引。</li>
<li><strong>环境变量</strong>：例如 PATH、HOME 等。</li>
<li><strong>信号处理方式</strong>：该进程对不同信号设置的处理函数。</li>
<li><strong>控制终端信息</strong>：与进程关联的终端信息。</li>
<li><strong>用户和组ID</strong>：进程运行所在的用户和组权限。</li>
</ol>
<p>进程映像实际上定义了一个进程的运营状态，它能够让操作系统知道如何管理和执行一个进程。当进程通过 <code>fork</code> 被复制时，这个映像也被复制（通过写时复制技术，Copy-On-Write），创建一个新的进程。当执行 <code>exec</code> 类系统调用时，当前进程的程序码和数据段会被新的内容替换，但是其它的部分，如打开的文件描述符等会保留下来。这样的设计允许进程在创造出新的执行流的同时，保持资源使用和环境设置的连续性。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>如果父进程比子进程先退出，子进程将被1号进程（init）托管（这也是一种让程序在后台运行的方法）–孤儿进程。</p>
<h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>僵尸进程（Zombie Process）是指已经结束执行但其进程描述符仍然存在的进程。这种情况发生在子进程已经完成执行并退出，但其父进程尚未通过<code>wait()</code>或<code>waitpid()</code>系统调用来读取子进程的退出状态。在这种情况下，子进程的进程ID和退出状态仍然保存在系统中，以便父进程可以查询。</p>
<p>僵尸进程不占用除了进程表项之外的任何资源，不会消耗CPU时间，也不会占用内存空间。然而，因为每个进程都需要一个唯一的进程ID，如果系统中存在大量的僵尸进程，它们可能会耗尽可用的进程ID，从而阻止新的进程被创建。</p>
<h3 id="僵尸进程的避免："><a href="#僵尸进程的避免：" class="headerlink" title="僵尸进程的避免："></a>僵尸进程的避免：</h3><ol>
<li>子进程退出的时候，内核会向父进程发头SIGCHLD信号，如果父进程用signal(SIGCHLD,SIG_IGN)通知<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8?fromModule=lemma_inlink">内核</a>，表示自己对子进程的退出不感兴趣，那么子进程退出后会立即释放数据结构。</li>
<li>父进程通过wait()&#x2F;waitpid()等函数等待子进程结束，在子进程退出之前，父进程将被阻塞待。</li>
<li>如果父进程很忙，可以捕获SIGCHLD信号，在信号处理函数中调用wait()&#x2F;waitpid()。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="type">int</span> sts;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="comment">//sleep(100);</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="number">0</span>; *p=<span class="number">10</span>;<span class="comment">//会造成内存泄漏</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中：</p>
<ul>
<li><code>fork()</code>函数用于创建一个新的子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程。</li>
<li>父进程执行<code>wait()</code>函数，该函数阻塞父进程直到任一子进程结束。<code>wait()</code>返回结束子进程的PID，并通过<code>sts</code>参数传出子进程的退出状态。</li>
<li><code>WIFEXITED(sts)</code>宏检查子进程是否正常退出。如果是，<code>WEXITSTATUS(sts)</code>宏可以获取子进程的退出代码。</li>
<li><code>WTERMSIG(sts)</code>宏用于获取终止子进程的信号编号，如果子进程是因为信号而非正常退出的话。</li>
<li>子进程中的代码尝试对一个空指针进行写操作，这将导致运行时错误（段错误），并使子进程异常终止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> sig)</span>   <span class="comment">// 子进程退出的信号处理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sts;</span><br><span class="line">  <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD,func);  <span class="comment">// 捕获子进程退出的信号。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;父进程忙着执行任务。\n&quot;</span>;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// int *p=0; *p=10;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>main</code>函数中的<code>fork()</code>调用创建了一个子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程，父进程进入一个无限循环，模拟持续的工作。如果<code>fork()</code>返回0，说明当前是子进程，子进程休眠5秒后退出，并返回状态码1。</p>
<p>父进程通过<code>signal()</code>函数注册了一个信号处理函数<code>func</code>，该函数会在子进程退出时被调用。在<code>func</code>函数中，<code>wait()</code>函数被用来等待子进程结束，并获取其退出状态。根据退出状态，<code>func</code>函数会打印子进程是正常退出还是异常退出，以及相应的退出状态码或终止信号。</p>
<p>这个程序演示了如何在父进程中处理子进程的退出，确保资源得到正确释放，并获取子进程的退出信息</p>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><h4 id="wait函数-1"><a href="#wait函数-1" class="headerlink" title="wait函数"></a>wait函数</h4><p>是一个系统调用，它使父进程暂停执行，直到一个子进程结束或者该进程接收到一个指定的信号为止。如果父进程没有子进程或者它的子进程已经结束，则<code>wait</code>函数会立即返回。</p>
<p><code>wait</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; </span><br></pre></td></tr></table></figure>

<p>这个函数接受一个参数：</p>
<ul>
<li><p>status:</p>
<ul>
<li>这是一个指向整数的指针，用于存储子进程退出时的状态信息。如果你对子进程的退出状态不感兴趣，可以将这个参数设置为<code>NULL</code>。</li>
</ul>
</li>
</ul>
<p><code>wait</code>函数的返回值是：</p>
<ul>
<li>成功时返回子进程的进程ID。</li>
<li>如果调用进程没有子进程，返回-1，并且<code>errno</code>会被设置为<code>ECHILD</code>。</li>
</ul>
<p>当子进程结束时，它会返回一些状态信息，这些信息可以通过<code>status</code>参数获取。为了解析这些状态信息，通常会使用一些宏，例如：</p>
<ul>
<li><code>WIFEXITED(status)</code>：如果子进程正常结束，则返回非零值。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED</code>非零，这个宏可以获取子进程的返回值。</li>
</ul>
<p>这些宏帮助父进程确定子进程是如何结束的，例如，是正常退出还是因为收到了信号而结束。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/549981187"><code>wait</code>函数通常与<code>fork</code>函数一起使用，<code>fork</code>用于创建新的进程，而<code>wait</code>用于回收子进程的资源，防止子进程成为僵尸进程。</a></p>
<h4 id="多个子进程"><a href="#多个子进程" class="headerlink" title="多个子进程"></a>多个子进程</h4><p>当一个父进程使用<code>wait</code>函数等待子进程结束时，如果没有指定特定的子进程ID，<code>wait</code>会等待任何一个子进程结束。一旦有任何一个子进程结束，<code>wait</code>函数就会返回该子进程的PID，并且如果提供了一个非空指针作为参数，它还会返回子进程的退出状态。</p>
<p>如果父进程需要等待特定的子进程，或者想要同时管理多个子进程的结束，它可以使用<code>waitpid</code>函数。<code>waitpid</code>允许父进程指定一个特定的子进程ID来等待，或者通过传递特定的参数来等待任何子进程或某个进程组的子进程。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">例如，如果父进程想要等待任何一个子进程结束，它可以调用<code>waitpid(-1, &amp;status, 0);</code>。如果父进程想要非阻塞地检查子进程的状态，它可以使用<code>WNOHANG</code>选项，如<code>waitpid(-1, &amp;status, WNOHANG);</code>，这样父进程不会被阻塞，即使没有子进程结束</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">1</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mindtechnist/p/17243761.html">2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59008960/article/details/123625060">3</a>。</p>
<p>在处理多个子进程时，通常的做法是在一个循环中调用<code>waitpid</code>，并检查返回值来确定哪个子进程结束了。如果<code>waitpid</code>返回0，表示没有子进程已经结束；如果返回-1，表示出错，通常是因为没有更多的子进程要等待了</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程（Orphan Process）是指那些父进程已经结束或被终止，但子进程仍然在运行的进程。孤儿进程不会被系统立即终止，而是会被init进程（通常是系统中的第一个进程，PID为1）所收养。init进程会负责这些孤儿进程的管理工作，并在它们结束时收集它们的状态信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()!=<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="孤儿进程的特点："><a href="#孤儿进程的特点：" class="headerlink" title="孤儿进程的特点："></a>孤儿进程的特点：</h3><ul>
<li><strong>父进程终止</strong>：当一个进程结束时，它的所有子进程将成为孤儿进程。</li>
<li><strong>被init进程收养</strong>：孤儿进程会被系统的init进程收养，这意味着它们的父进程ID（PPID）将变为1。</li>
<li><strong>资源回收</strong>：当孤儿进程最终结束运行时，init进程会回收它们使用的资源，并清理它们的状态信息。</li>
</ul>
<h3 id="孤儿进程的产生："><a href="#孤儿进程的产生：" class="headerlink" title="孤儿进程的产生："></a>孤儿进程的产生：</h3><p>通常，孤儿进程的产生是由于父进程在执行完毕或因为某些原因被终止，而没有等待（通过<code>wait</code>或<code>waitpid</code>系统调用）子进程结束。</p>
<h3 id="孤儿进程的影响："><a href="#孤儿进程的影响：" class="headerlink" title="孤儿进程的影响："></a>孤儿进程的影响：</h3><p>孤儿进程通常不会对系统造成负面影响，因为它们会被init进程妥善管理。然而，如果有大量的孤儿进程被创建且长时间运行，它们可能会占用不必要的系统资源。</p>
<h3 id="孤儿进程与僵尸进程的区别："><a href="#孤儿进程与僵尸进程的区别：" class="headerlink" title="孤儿进程与僵尸进程的区别："></a>孤儿进程与僵尸进程的区别：</h3><p>孤儿进程与僵尸进程不同。僵尸进程是已经结束但其状态信息尚未被父进程收集的进程。如果父进程没有调用<code>wait</code>或<code>waitpid</code>来收集子进程的状态信息，子进程将成为僵尸进程。相比之下，孤儿进程是那些父进程已经结束，但子进程仍在运行的进程。</p>
<h3 id="孤儿进程的处理："><a href="#孤儿进程的处理：" class="headerlink" title="孤儿进程的处理："></a>孤儿进程的处理：</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/654235321">在大多数情况下，孤儿进程不需要特别处理，因为它们会被init进程自动收养和管理。但是，如果开发者希望避免产生孤儿进程，可以通过编程确保父进程在子进程结束之前一直运行，或者确保父进程适时地调用<code>wait</code>或<code>waitpid</code>来等待子进程结束</a></p>
<h2 id="多进程与信号"><a href="#多进程与信号" class="headerlink" title="多进程与信号"></a>多进程与信号</h2><p>在多进程的服务程序中，如果子进程收到退出信号，子进程自行退出，如果父进程收到退出信号，则应该先向全部的子进程发送退出信号，然后自己再退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略全部的信号，不希望被打扰。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">65</span>;i++) <span class="built_in">signal</span>(i,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置信号,在shell状态下可用 &quot;kill 进程号&quot; 或 &quot;Ctrl+c&quot; 正常终止些进程</span></span><br><span class="line">  <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGTERM,FathEXIT); <span class="built_in">signal</span>(SIGINT,FathEXIT);  <span class="comment">// SIGTERM 15 SIGINT 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) <span class="comment">// 父进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">5</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 子进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 子进程需要重新设置信号。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGTERM,ChldEXIT);   <span class="comment">// 子进程的退出函数与父进程不一样。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGINT ,SIG_IGN);    <span class="comment">// 子进程不需要捕获SIGINT信号。</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在运行中。\n&quot;</span>; <span class="built_in">sleep</span>(<span class="number">3</span>); <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;父进程退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);     <span class="comment">// 向全部的子进程发送15的信号，通知它们退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（全局的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（只释放子进程的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>除了fork，操作系统中还有其他几种创建进程的方式，尤其在Unix-like系统中常见的有：</p>
<ol>
<li>**vfork()**：<ul>
<li><code>vfork()</code> 和 <code>fork()</code> 非常相似，但它不会复制父进程的页表。</li>
<li><code>vfork()</code> 的目的是父进程和子进程共享相同的物理内存。</li>
<li>子进程会在父进程的上下文中运行，直到它调用 <code>exec()</code> 或 <code>exit()</code>。</li>
<li>它的使用不如 <code>fork()</code> 那么广泛，因为如果不正确使用，很容易导致问题。</li>
</ul>
</li>
<li>**clone()**：<ul>
<li><code>clone()</code> 是 Linux 提供的一种更加灵活的创建进程的方式。</li>
<li>它允许调用者指定共享哪些资源，如文件系统、信号处理器、用户命名空间等。</li>
<li><code>clone()</code> 可以用来实现线程，因为线程是共享资源的轻量级进程。</li>
</ul>
</li>
<li><strong>exec() 系列函数</strong>：<ul>
<li><code>exec()</code> 并不是用来直接创建新的进程，而是用于在当前进程中加载一个新的可执行文件，替换当前进程映像。</li>
<li>通常与 <code>fork()</code> 配合使用，子进程会通过 <code>fork()</code> 创建后立即调用 <code>exec()</code> 来运行不同的程序。</li>
</ul>
</li>
<li><strong>posix_spawn() 和 posix_spawnp()</strong>:<ul>
<li>这两个函数是 POSIX 标准提供的用于创建进程的函数。</li>
<li>他们结合了 <code>fork()</code> 和 <code>exec()</code> 的步骤，可能在某些系统上比单独调用这两个步骤更高效。</li>
</ul>
</li>
</ol>
<p>与 <code>fork()</code> 的区别主要在于：</p>
<ul>
<li><strong>资源共享</strong>：<ul>
<li><code>fork()</code> 会复制父进程的页表，子进程会获得父进程数据的一个副本；</li>
<li><code>vfork()</code> 和父进程共享数据部分，直至 <code>exec()</code> 或 <code>exit()</code> 被调用；</li>
<li><code>clone()</code> 可以详细指定共享何种资源，非常灵活。</li>
</ul>
</li>
<li><strong>创建目的</strong>：<ul>
<li><code>fork()</code> 创建的子进程通常会执行不同的任务或者进一步使用 <code>exec()</code> 加载新的程序；</li>
<li><code>vfork()</code> 主要是为了快速创建子进程以执行新程序，强调共享父进程空间；</li>
<li><code>clone()</code> 除了能创建进程外，还经常用来实现线程。</li>
</ul>
</li>
<li><strong>效率和用途</strong>：<ul>
<li><code>posix_spawn()</code> 提供了更高层次的接口，可能在某些系统上提供比 <code>fork()</code> 更高效的操作，它的用途更接近于 <code>fork()</code> 后跟随 <code>exec()</code> 的常见用法。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/10/linux-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/linux-shell/" class="post-title-link" itemprop="url">常见命令</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-10T12:00:00+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 20:07:33" itemprop="dateModified" datetime="2024-06-03T20:07:33+08:00">2024-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/shell/" itemprop="url" rel="index"><span itemprop="name">shell</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>这些命令通常是由Shell程序执行的。Shell是一个命令行解释器，它提供了一个用户界面来执行操作系统的命令</p>
<h3 id="用户与组"><a href="#用户与组" class="headerlink" title="用户与组"></a>用户与组</h3><p><strong>用户管理命令</strong>:</p>
<ul>
<li><p>添加新用户:</p>
<p><code>useradd -m -g users -s /bin/bash 新用户名 </code></p>
<p>这个命令会创建一个新用户，并指定其主目录(<code>-m</code>)，用户组(<code>-g users</code>)和登录Shell(<code>/bin/bash</code>)。</p>
</li>
<li><p>删除用户:</p>
<p><code>userdel -r 用户名 </code></p>
<p>这个命令会删除用户以及用户的主目录(<code>-r</code>表示删除用户时同时删除其主目录)。</p>
</li>
<li><p>修改用户属性:</p>
<p><code>usermod -l 新用户名 -d /home/新目录 -m 旧用户名 </code></p>
<p>这个命令会更改用户的登录名(<code>-l</code>)，移动用户的家目录到新位置(<code>-d</code>和<code>-m</code>选项)。</p>
</li>
<li><p>设置用户密码:</p>
<p><code>passwd 用户名 </code></p>
<p>这个命令会提示你为指定用户设置密码。</p>
</li>
</ul>
<p><strong>用户组管理命令</strong>:</p>
<ul>
<li><p>添加用户组:</p>
<p><code>groupadd 新用户组名 </code></p>
<p>这个命令会创建一个新的用户组。</p>
</li>
<li><p>删除用户组:</p>
<p><code>groupdel 用户组名 </code></p>
<p>这个命令会删除一个用户组。</p>
</li>
<li><p>修改用户组信息:</p>
<p><code>groupmod -n 新用户组名 旧用户组名 </code></p>
<p>这个命令会更改用户组的名字。</p>
</li>
</ul>
<p><strong>查询命令</strong>:</p>
<ul>
<li><p>查询当前登录用户信息:</p>
<p><code>whoami </code></p>
<p>这个命令会显示当前登录的用户名。</p>
</li>
<li><p>查询指定用户信息:</p>
<p><code>id 用户名 </code></p>
<p>这个命令会显示指定用户的UID、GID以及所属的用户组。</p>
</li>
<li><p>查询所有用户信息:</p>
<p><code>cat /etc/passwd </code></p>
<p>这个命令会显示系统中所有用户的信息。</p>
</li>
<li><p>查询所有用户组信息:</p>
<p><code>getent group </code></p>
<p>这个命令会显示系统中所有用户组的信</p>
</li>
<li><p>将一个用户附加到另一个组中<code>-a</code>表示append（追加），<code>-G</code>后面跟着你想要添加用户的组名。</p>
<p><code>usermod -a -G 组名 用户名</code></p>
<p>例如，如果你想将用户<code>john</code>添加到<code>developers</code>组中，你可以使用如下命令：</p>
<p><code>usermod -a -G developers john </code></p>
<p>这个命令不会影响<code>john</code>在其他组中的成员资格。如果你想一次将用户添加到多个组中，可以用逗号分隔组名，如下所示：</p>
<p><code>usermod -a -G group1,group2,group3 john</code></p>
</li>
</ul>
<p><strong>组中删除用户</strong></p>
<p>从组中删除用户有几种方法。以下是两种常用的命令：</p>
<ol>
<li><p><strong>使用gpasswd命令</strong>: 这个命令可以从特定的组中删除用户。使用方法如下：</p>
<p><code>sudo gpasswd -d 用户名 组名 </code></p>
<p>例如，如果你想从<code>developers</code>组中删除用户<code>john</code>，你可以使用：</p>
<p><code>sudo gpasswd -d john developers </code></p>
</li>
<li><p><strong>编辑&#x2F;etc&#x2F;group文件</strong>: 你也可以直接编辑<code>/etc/group</code>文件来手动从组中删除用户。这个方法需要你有足够的权限来编辑系统文件。你可以使用<code>vi</code>、<code>nano</code>或其他文本编辑器来编辑这个文件。例如：</p>
<p><code>sudo vi /etc/group </code></p>
<p>然后找到相应的组，并删除用户旁边的用户名。</p>
</li>
<li><p><strong>使用usermod命令</strong>: 如果你想从所有组中删除用户，只保留其主组，可以使用<code>usermod</code>命令。这个命令会重新设置用户所属的次要组。使用方法如下：</p>
<p><code>sudo usermod -G 主组名 用户名 </code></p>
<p>例如，如果你想让用户<code>john</code>只属于其主组<code>users</code>，可以使用：</p>
<p><code>sudo usermod -G users john</code></p>
</li>
</ol>
<h3 id="目录文件权限"><a href="#目录文件权限" class="headerlink" title="目录文件权限"></a>目录文件权限</h3><p><strong>更改权限 - chmod</strong>:</p>
<ul>
<li><p><code>chmod</code> 命令用于更改文件或目录的权限。权限分为三组：所有者（u）、组（g）和其他用户（o）。</p>
</li>
<li><p>例如，要给所有用户读取权限，可以使用：</p>
<p><code>chmod a+r 文件名 </code></p>
</li>
<li><p>要移除所有用户的执行权限，可以使用：</p>
<p><code>chmod a-x 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的权限，可以使用<code>-R</code>选项：</p>
<p><code>chmod -R a+r 目录名 </code></p>
</li>
<li><p>使用数字表示法设置特定权限，如744（所有者读写执行，组读，其他用户读）：</p>
<p><code>chmod 744 文件名 </code></p>
</li>
</ul>
<p><strong>更改所有者 - chown</strong>:</p>
<ul>
<li><p><code>chown</code> 命令用于更改文件或目录的所有者。</p>
</li>
<li><p>例如，要将文件的所有者更改为新用户，可以使用：</p>
<p><code>chown 新用户 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的所有者，可以使用<code>-R</code>选项：</p>
<p><code>chown -R 新用户 目录名 </code></p>
</li>
</ul>
<p><strong>更改组 - chgrp</strong>:</p>
<ul>
<li><p><code>chgrp</code> 命令用于更改文件或目录的组。</p>
</li>
<li><p>例如，要将文件的组更改为新组，可以使用：</p>
<p><code>chgrp 新组 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的组，可以使用<code>-R</code>选项：</p>
<p><code>chgrp -R 新组 目录名 </code></p>
</li>
</ul>
<p><strong>查看权限 - ls -l</strong>:</p>
<ul>
<li><p>使用 <code>ls -l</code> 命令可以查看文件或目录的当前权限。</p>
</li>
<li><p>例如，要查看文件的权限，可以使用：</p>
<p><code>ls -l 文件名</code></p>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>查看进程 - ps</strong>:</p>
<p><code>ps</code></p>
<p>命令用于显示当前系统中的活动进程。</p>
<p><code>ps aux </code></p>
<p>这个命令会显示所有进程的详细信息，包括CPU和内存的使用情况。</p>
<p><strong>实时监控进程 - top</strong>:</p>
<p><code>top</code></p>
<p>命令提供一个实时更新的视图，显示系统中进程的状态。</p>
<p><code>top </code></p>
<p>这个命令会显示进程的PID、用户、优先级、CPU使用率、内存使用率等信息。</p>
<p><strong>结束进程 - kill</strong>:</p>
<p><code>kill</code></p>
<p>命令用于发送信号给进程，通常用于结束进程。</p>
<p><code>kill PID </code></p>
<p>这个命令会向指定的进程ID发送一个终止信号。</p>
<p><strong>改变进程优先级 - nice 和 renice</strong>:</p>
<p><code>nice</code></p>
<p>命令用于启动一个进程并设置其优先级。</p>
<p><code>nice -n 10 command </code></p>
<p>这个命令会以优先级10启动指定的命令。</p>
<p><code>renice</code></p>
<p>命令用于改变已经运行的进程的优先级。</p>
<p><code>renice 10 PID </code></p>
<p>这个命令会将指定进程ID的优先级改为10。</p>
<p><strong>在后台运行进程 - bg</strong>:</p>
<p><code>bg</code></p>
<p>命令用于将一个已经停止的进程放到后台运行。</p>
<p><code>bg %jobnumber </code></p>
<p>这个命令会将指定的作业号的进程放到后台。</p>
<p><strong>将进程带到前台 - fg</strong>:</p>
<p><code>fg</code></p>
<p>命令用于将后台进程带到前台。</p>
<p><code>fg %jobnumber </code></p>
<p>这个命令会将指定的作业号的进程带到前台。</p>
<p><strong>查找进程 - pgrep 和 pkill</strong>:</p>
<p><code>pgrep</code></p>
<p>命令用于查找匹配条件的进程ID。</p>
<p><code>pgrep process_name </code></p>
<p>这个命令会列出所有名为</p>
<p><code>process_name</code></p>
<p>的进程的ID。</p>
<p><code>pkill</code></p>
<p>命令用于发送信号给匹配条件的进程，通常用于结束进程。</p>
<p><code>pkill process_name </code></p>
<p>这个命令会结束所有名为</p>
<p><code>process_name</code></p>
<p>的进程。</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/09/linux-signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/linux-signal/" class="post-title-link" itemprop="url">linux信号</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-09T12:00:00+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:12:35" itemprop="dateModified" datetime="2024-05-19T19:12:35+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kill-x2F-killall"><a href="#kill-x2F-killall" class="headerlink" title="kill&#x2F;killall"></a>kill&#x2F;killall</h1><p><code>kill</code> 和 <code>killall</code> 命令都是用于终止进程的工具，但它们的应用场景和方式有所不同：</p>
<ol>
<li><strong>kill 命令</strong>：<ul>
<li><code>kill</code> 命令用于发送信号给指定的进程。</li>
<li>通常，如果没有指定信号，<code>kill</code> 会发送 <code>SIGTERM</code>（信号 15），这是一个请求进程优雅终止的信号。</li>
<li>如果进程没有响应 <code>SIGTERM</code>，可以使用 <code>SIGKILL</code>（信号 9），这是一个强制终止进程的信号，进程无法忽略。</li>
<li>命令格式：<code>kill [信号] 进程ID</code>。例如，<code>kill -9 1234</code> 会强制终止进程 ID 为 1234 的进程。</li>
</ul>
</li>
<li><strong>killall 命令</strong>：<ul>
<li><code>killall</code> 命令用于终止所有与给定名称相匹配的进程。</li>
<li>它不需要进程 ID，而是根据进程名称操作。</li>
<li>如果进程名不完整或不正确，<code>killall</code> 可能会报错或不执行任何操作。</li>
<li>命令格式：<code>killall [信号] 进程名称</code>。例如，<code>killall -9 nginx</code> 会强制终止所有名为 <code>nginx</code> 的进程。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1847239">使用 <code>kill</code> 命令时，你需要知道进程的 ID，而使用 <code>killall</code> 时，你只需要知道进程的名称。<code>kill</code> 命令在你需要精确控制哪个进程被终止时更为合适，而 <code>killall</code> 在你想要快速停止所有同名进程时更加方便。然而，使用 <code>killall</code> 时需要小心，以免误杀其他同名进程</a></p>
<p><code>kill</code> 和 <code>killall</code> 命令在技术上是用来向进程发送信号的。在 Unix-like 系统中，信号是进程间通信的一种方式，可以用来告知进程发生了某个事件。每种信号都有预定义的含义，比如：</p>
<ul>
<li><code>SIGTERM</code>（默认信号，通常是 15）：请求进程优雅地终止。</li>
<li><code>SIGKILL</code>（信号 9）：立即强制终止进程。</li>
</ul>
<p>当我们说“杀死进程”时，通常是指发送 <code>SIGKILL</code> 信号，因为这个信号会导致进程立即停止执行。但是，进程可以捕获和处理其他信号（除了 <code>SIGKILL</code> 和 <code>SIGSTOP</code>），这意味着进程可以决定如何响应大多数信号，包括是否终止。</p>
<p>所以，你可以将 <code>kill</code> 和 <code>killall</code> 看作是向进程发送各种信号的工具，而不仅仅是终止它们。这些命令的灵活性允许系统管理员以多种方式与进程交互，包括但不限于终止进程。</p>
<p>文末会有一些常用信号。</p>
<p>以下代码执行后会一直循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 是一个信号处理函数，当接收到信号时会被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;get signal:&quot;</span>&lt;&lt;signum&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">signal</span>(signum,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func1 是另一个信号处理函数，用于处理 SIGALRM（定时器信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;alarm do \n&quot;</span>;</span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2 是第三个信号处理函数，用于处理 SIGINT（中断信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span> <span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;holt shit,sb&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;really?\n&quot;</span>;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;OK QAQ\n&quot;</span>;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">1</span>,func);<span class="comment">// 为 SIGHUP 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">15</span>,func);<span class="comment">// 为 SIGTERM 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">2</span>,func2); <span class="comment">// 为 SIGINT 信号设置 func2 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">3</span>,SIG_IGN); <span class="comment">// 忽略 SIGQUIT 信号</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>); <span class="comment">// 设置一个 5 秒后的定时器</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">14</span>,func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot; do \n&quot;</span>; <span class="comment">// 主循环中打印消息</span></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>请注意，程序中的 <code>func2</code> 函数包含不雅的语言，这在正式编程实践中是不推荐的。此外，<code>exit(0)</code> 在 <code>func2</code> 中被调用，这将导致程序在接收到 <code>SIGINT</code> 信号时立即退出。而 <code>func1</code> 函数在处理 <code>SIGALRM</code> 信号时重新设置了定时器，这将导致每 5 秒打印一次 “alarm do \n” 并再次设置定时器。<code>func</code> 函数在接收到 <code>SIGHUP</code> 或 <code>SIGTERM</code> 信号后，会将信号的处理方式恢复为默认。最后，<code>SIGQUIT</code> 信号被程序忽略。</p>
<h1 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h1><p>常见的信号及其含义：</p>
<ul>
<li><code>SIGHUP</code> (1): 终端挂断或父进程终止时发送。</li>
<li><code>SIGINT</code> (2): 当用户按下中断键（通常是 Ctrl-C）时发送。</li>
<li><code>SIGQUIT</code> (3): 当用户按下退出键（通常是 Ctrl-\）时发送。</li>
<li><code>SIGILL</code> (4): 非法指令。</li>
<li><code>SIGABRT</code> (6): 由 <code>abort</code> 系统调用产生。</li>
<li><code>SIGFPE</code> (8): 浮点异常。</li>
<li><code>SIGKILL</code> (9): 强制终止进程，不能被捕获或忽略。</li>
<li><code>SIGSEGV</code> (11): 无效的内存引用。</li>
<li><code>SIGPIPE</code> (13): 向一个没有读端的管道写数据时发送。</li>
<li><code>SIGALRM</code> (14): 由 <code>alarm</code> 系统调用产生的定时器信号。</li>
<li><code>SIGTERM</code> (15): 请求终止进程，可以被捕获和处理。</li>
<li><code>SIGUSR1</code> (10) 和 <code>SIGUSR2</code> (12): 用户定义信号。</li>
<li><code>SIGCHLD</code> (17): 子进程停止或终止时发送。</li>
<li><code>SIGCONT</code> (18): 使停止的进程继续执行。</li>
<li><code>SIGSTOP</code> (19): 停止进程的执行，不能被捕获或忽略。</li>
<li><code>SIGTSTP</code> (20): 由用户发送的停止信号（通常是 Ctrl-Z）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61882365">除了这些，还有许多其他信号，如 <code>SIGBUS</code>、<code>SIGPOLL</code>、<code>SIGPROF</code>、<code>SIGSYS</code>、<code>SIGTRAP</code> 等，以及一系列的实时信号 <code>SIGRTMIN</code> 到 <code>SIGRTMAX</code>。实时信号支持排队，不会丢失，而传统信号可能会丢失</a></p>
<h3 id="补"><a href="#补" class="headerlink" title="补"></a>补</h3><p>signal(SIGPIPE, SIG_IGN); 是一个系统调用，用于处理信号。这里的 SIGPIPE 是一个信号，通常在进程向一个已经关闭的管道或者socket写入数据时发出。而 SIG_IGN 是一个宏，表示忽略信号的处理程序。</p>
<p>具体来说，signal(SIGPIPE, SIG_IGN); 的作用是告诉系统忽略 SIGPIPE 信号。如果不忽略这个信号，当进程试图写入一个已经没有读端的管道时，默认行为是终止进程。通过设置 SIG_IGN，进程可以继续运行，不会因为 SIGPIPE 而被意外终止。</p>
<p>这里有一些注意事项：</p>
<p>●   signal 函数是一个较老的接口，现在通常推荐使用 sigaction 函数，因为它提供了更好的控制能力，并且在某些系统上不需要重置处理程序 。</p>
<p>●   除了 SIGKILL 和 SIGSTOP 之外，大多数信号都可以被忽略。SIGKILL 和 SIGSTOP 是两个不能被捕获或忽略的信号。</p>
<p>如果想恢复 SIGPIPE 信号的默认处理行为，可以使用</p>
<p> signal(SIGPIPE, SIG_DFL);，</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-file/" class="post-title-link" itemprop="url">linux文件操作</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 12:00:00 / 修改时间：20:52:47" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/file/" itemprop="url" rel="index"><span itemprop="name">file</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ol>
<li>目录显示与切换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line"><span class="comment">//文件目录操作</span></span><br><span class="line"><span class="comment">//pwd：显示当前路径</span></span><br><span class="line"><span class="type">char</span> path1[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">getcwd</span>(path1,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path1= &quot;</span>&lt;&lt;path1&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pwd2：显示当前路径</span></span><br><span class="line"><span class="type">char</span> *path2=<span class="built_in">get_current_dir_name</span>();</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path2= &quot;</span>&lt;&lt;path2&lt;&lt;std::endl;</span><br><span class="line"><span class="built_in">free</span>(path2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cd:切换当前工作路径</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path3=<span class="string">&quot;/home/jenwein/dev/zgjcpp&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chdir</span>(path3)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;success to dir: &quot;</span>;</span><br><span class="line"><span class="built_in">getcwd</span>(path,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;path&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mkdir：创建目录文件夹</span></span><br><span class="line"><span class="comment">//arg1-目录名 arg2-访问权限 成功返回0</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>,<span class="number">0755</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;makedir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to makedir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmdir：删除文件夹</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">rmdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;rmdir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to rmdir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>读取文件&#x2F;目录信息</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Using ./t2 &quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DIR *dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dir=<span class="built_in">opendir</span>(argv[<span class="number">1</span>]))==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>* <span class="built_in">stdinfo</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>((stdinfo=<span class="built_in">readdir</span>(dir))==<span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;filename = &quot;</span>&lt;&lt;stdinfo-&gt;d_name&lt;&lt;<span class="string">&quot;, filetype = &quot;</span>&lt;&lt;(<span class="type">int</span>)stdinfo-&gt;d_type&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closedir</span>(dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>错误显示</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于系统调用的函数才会设置errno，其值只有在库函数调用发生错误时才会被设置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> iret=<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/bbb/aaa&quot;</span>,<span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;iret= &quot;</span>&lt;&lt;iret&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;errno&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;<span class="comment">//显示错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示最近一次系统错误的详细信息</span></span><br><span class="line"><span class="comment">//perror(strerror(errno));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;150;i++)</span></span><br><span class="line"><span class="comment">std::cout&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;strerror(i)&lt;&lt;std::endl;//打印所有linux中错误代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>其他操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;std::cout&lt;&lt;<span class="string">&quot;Using ./file (file or dir) (option:newpath)&quot;</span>&lt;&lt;std::endl; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access查看文件权限，主要用于判断文件或目录是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK)!=<span class="number">0</span>)</span><br><span class="line">&#123;std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; not exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件的stat的各属性，名称，权限，修改时间。。。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;<span class="comment">//struct for dir or file ins</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stat</span>(argv[<span class="number">1</span>],&amp;st)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;stat(&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;): &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a file (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a dir (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rename file/dir 重命名文件</span></span><br><span class="line"><span class="keyword">if</span>(argc=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">rename</span>(argv[<span class="number">1</span>],argv[<span class="number">2</span>])==<span class="number">0</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rename success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove file/dir 删除文件</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;want rm the last dir/file?(y/n)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">std::cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">remove</span>(argv[<span class="number">3</span>])==<span class="number">0</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rm success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;file to rm sth\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=188550&auto=1&height=66"></iframe>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hah"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hah</p>
  <div class="site-description" itemprop="description">我没有为你伤春悲秋不配有憾事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Jenwein" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jenwein" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rgw127310@gmail.com" title="E-Mail → mailto:rgw127310@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-4 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hah</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">303k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


    </div>
</body>
</html>
