<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sword1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sword2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhahr.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:type" content="website">
<meta property="og:title" content="HahのBlog">
<meta property="og:url" content="http://rhahr.top/page/5/index.html">
<meta property="og:site_name" content="HahのBlog">
<meta property="og:description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rhahr.top/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HahのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Jenwein" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HahのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-array/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 17:38:52" itemprop="dateCreated datePublished" datetime="2024-03-19T17:38:52+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-16 18:47:42" itemprop="dateModified" datetime="2024-03-16T18:47:42+08:00">2024-03-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> S&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> ValueType = <span class="keyword">typename</span> T::ValueType;</span><br><span class="line">	<span class="keyword">using</span> PointerType = ValueType*;</span><br><span class="line">	<span class="keyword">using</span> ReferenceType = ValueType&amp;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ArrayIterator</span>(PointerType ptr)</span><br><span class="line">		:<span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	ArrayIterator&amp; <span class="keyword">operator</span>++()<span class="comment">//前缀(++it/先自增后，返回自增后的版本)</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_Ptr++;     <span class="comment">//it.m_Ptr++</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//return it(it=*this),this是当前对象的指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	ArrayIterator <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//后缀（it++先返回当前it，再对其自增）参数并没有实际的意义，它只是用来区分前缀和后缀版本的</span></span><br><span class="line">	&#123;</span><br><span class="line">		ArrayIterator it = *<span class="keyword">this</span>;<span class="comment">//将当前的迭代器指向保存到一个副本</span></span><br><span class="line">		++(*<span class="keyword">this</span>);<span class="comment">//将当前迭代器自增使其指向下一个元素</span></span><br><span class="line">		<span class="keyword">return</span> it;<span class="comment">//返回原迭代器，且由于实际的it是副本，原*this已经被改变所以不能返回引用，因为引用将会指向已经改变的状态</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ArrayIterator&amp; <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Ptr--;    </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ArrayIterator <span class="keyword">operator</span>--(<span class="type">int</span>)<span class="comment">//参数并没有实际的意义，它只是用来区分前缀和后缀版本的</span></span><br><span class="line">	&#123;</span><br><span class="line">		ArrayIterator it = *<span class="keyword">this</span>;</span><br><span class="line">		--(*<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ReferenceType <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *(m_Ptr+index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PointerType <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ReferenceType <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *m_Ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ArrayIterator&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  m_Ptr == other.m_Ptr ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ArrayIterator&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>  m_Ptr != other.m_Ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PointerType m_Ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> S&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> ValueType = T;</span><br><span class="line">	<span class="keyword">using</span> Iterator = ArrayIterator&lt;Array&lt;T, S&gt;, S&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> S; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供两个版本的operator[]重载函数是为了支持对常量和非常量对象的操作</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T* <span class="title">Data</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> T* <span class="title">Data</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//创建一个Iterator类型的匿名对象，并且使用m_Data来初始化这个对象。在这个过程中，Iterator的构造函数会接收m_Data作为参数，这通常是数组的首地址，然后设置迭代器内部的指针m_Ptr指向这个地址。这样，当begin()方法被调用时，它就返回了一个指向数组起始位置的迭代器，从而允许遍历数组。</span></span><br><span class="line">		<span class="keyword">return</span> ArrayIterator&lt;Array&lt;T, S&gt;, S&gt;(m_Data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Iterator</span>(m_Data+S);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T m_Data[S];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/19/C++-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/C++-Map/" class="post-title-link" itemprop="url">std::map/std::unordered_map</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-19 12:00:00 / 修改时间：17:38:26" itemprop="dateCreated datePublished" datetime="2024-03-19T12:00:00+08:00">2024-03-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h1><p><code>std::map</code>和<code>std::unordered_map</code>是C++标准库中的两种非常有用的容器，它们都可以存储键值对，但在内部实现和性能特性上有所不同。</p>
<p><strong>std::map:</strong></p>
<ul>
<li><code>std::map</code>是一个基于红黑树的平衡二叉搜索树实现的关联容器。</li>
<li>它存储的元素是按照键来排序的，因此可以非常快速地进行查找、插入和删除操作。</li>
<li><code>std::map</code>中的键是唯一的，不能有重复的键。</li>
<li>它的主要优点是，可以保证元素按照特定顺序存储，通常是按照键的升序。</li>
<li>查找操作的时间复杂度为O(log n)，其中n是容器中元素的数量。</li>
</ul>
<p><strong>std::unordered_map:</strong></p>
<ul>
<li><code>std::unordered_map</code>是基于哈希表实现的关联容器。</li>
<li>它不保证元素的顺序，因此不能依赖于元素的任何排序。</li>
<li><code>std::unordered_map</code>中的键也是唯一的，不能有重复的键。</li>
<li>它的主要优点是，在理想情况下，查找、插入和删除操作的时间复杂度可以接近O(1)。</li>
<li>但是，由于哈希冲突的存在，这些操作的时间复杂度可能会变差，尤其是当哈希函数分布不均匀时。</li>
</ul>
<p>在选择使用<code>std::map</code>还是<code>std::unordered_map</code>时，需要考虑你的应用场景。如果你需要保持元素的顺序，则应该使用<code>std::map</code>。如果你更关心查找效率，并且不在乎元素的顺序，那么<code>std::unordered_map</code>可能是更好的选择。</p>
<p>下面是一个简单的例子，展示了如何使用这两种容器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::map</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; orderedMap;</span><br><span class="line">    orderedMap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    orderedMap[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    orderedMap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素将按照键的顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : orderedMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::unordered_map</span></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; unorderedMap;</span><br><span class="line">unorderedMap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line">unorderedMap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">unorderedMap[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的存储顺序是不确定的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : unorderedMap) &#123;</span><br><span class="line">    std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>std::map</code>会按照键的顺序输出<code>1 =&gt; one</code>, <code>2 =&gt; two</code>, <code>3 =&gt; three</code>，而<code>std::unordered_map</code>的输出顺序则是不确定的</p>
<h2 id="std-unordered-map-1"><a href="#std-unordered-map-1" class="headerlink" title="std::unordered_map"></a>std::unordered_map</h2><p>前面提到了，std::unordered_map就是哈希表，什么是哈希表，看看newbing的解释：</p>
<p>想象一下，你有一个巨大的图书馆，你需要一种方法快速找到任何一本书。如果你把所有的书按照书名的字母顺序排列，那么即使图书馆很大，你也可以通过书名快速找到书。但是，如果每次你想找一本书都要从头到尾查找，那就太慢了。这就是哈希表发挥作用的地方。</p>
<p><strong>哈希表</strong>就像是一个有很多小抽屉的巨大书架。每个抽屉都有一个特定的编号，而这个编号是由<strong>哈希函数</strong>决定的。哈希函数就像是一个魔法转换器，你告诉它你想找的书名，它就给你一个抽屉的编号。这样，你就可以直接去那个编号的抽屉找书，而不用查看每一本书。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈希函数例子: </span><br><span class="line">书名: <span class="string">&quot;哈利波特&quot;</span> </span><br><span class="line">哈希函数转换 -&gt; 抽屉编号: <span class="number">5</span> </span><br></pre></td></tr></table></figure>

<p>你只需要记住这个编号，就可以直接找到书，这样查找速度就非常快了。</p>
<p>但是，有时候会出现这样的情况：两本不同的书名被哈希函数转换成了同一个抽屉编号。这就是所谓的<strong>哈希冲突</strong>。比如说，”哈利波特”和”指环王”都被转换成了编号5。这时候，我们需要一种方法来解决这个问题，通常的做法是在同一个抽屉里再加一个小盒子，这样”哈利波特”可以放在一个盒子里，”指环王”放在另一个盒子里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈希冲突例子: </span><br><span class="line">书名: <span class="string">&quot;哈利波特&quot;</span> -&gt; 抽屉编号: <span class="number">5</span> -&gt; 小盒子: A </span><br><span class="line">书名: <span class="string">&quot;指环王&quot;</span> -&gt; 抽屉编号: <span class="number">5</span> -&gt; 小盒子: B </span><br></pre></td></tr></table></figure>

<p>这样，即使两本书的编号相同，你也可以通过小盒子的标记来区分它们。</p>
<p>实际上就是哈希表中的每一个节点是一个键值对，一个键和一个值（key-value pair）通过键映射到值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;keytype,valuetype&gt;test;</span><br></pre></td></tr></table></figure>

<p>而中间这个<strong>映射过程是哈希函数的工作</strong>,哈希函数是一种将输入数据（无论大小）转换成固定大小输出的函数，通常输出是一个整数，这个输出称为哈希值或哈希码。哈希函数的设计目标是尽可能快地计算出哈希值，并且尽量减少不同输入产生相同输出值的情况, <del>字太多了不想看，以后回来更不想看</del> </p>
<p>这么理解：&#x3D;&#x3D;哈希函数可以看作是一种自定义的查找规则，它将输入转换成一个哈希值，这个哈希值通常用作在哈希表中查找对应内容的索引。&#x3D;&#x3D;</p>
<ul>
<li><strong>对于基本数据类型和标准库中的类型</strong>，C++标准库提供了默认的哈希函数。这些默认的哈希函数通常是为了提供一个简单且高效的方式来将数据转换成一个整数值，这个整数值就是哈希值。例如，对于整数类型，哈希函数可能就是简单地返回其本身的值；对于字符串类型，哈希函数会计算字符串中字符的某种组合，以生成一个唯一的整数值。</li>
<li>但是，如果<strong>你想在<code>std::unordered_map</code>中使用自定义类型作为键</strong>，你需要提供一个合适的哈希函数和相等性判断函数。这通常是通过特化<code>std::hash</code>模板和提供<code>operator==</code>来完成的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CityRecord</span></span><br><span class="line">&#123;</span><br><span class="line">	std::string CityName;</span><br><span class="line">	<span class="type">uint64_t</span> Population;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//哈希函数接受键(key)然后通过内部定义规则返回为一个值---哈希值</span></span><br><span class="line"><span class="comment">//哈希函数可以看作是一种自定义的查找规则，它将输入转换成一个哈希值，这个哈希值通常用作在哈希表中查找对应内容的索引</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;<span class="comment">//模板特化</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hash</span>&lt;CityRecord&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 重载 operator() 来定义哈希函数</span></span><br><span class="line">		<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> CityRecord&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">// 使用标准库中的 std::hash&lt;std::string&gt; 来计算 &#x27;CityName&#x27; 成员的哈希值作为返回值</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">hash</span>&lt;std::string&gt;()(key.CityName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个特化的哈希函数允许CityRecord被用作std::unordered_map的键。当你插入或查找包含MyStruct键的元素时，std::unordered_map会使用这个哈希函数来确定元素应该存储在哈希表的哪个位置。</span></span><br></pre></td></tr></table></figure>

<p>刚开始看到这里已经分不清哈希值和键是什么关系了，在开头的例子中我们已经学会了unordered_map的基本使用，查找或者插入操作在现在这个例子中是这样的：</p>
<p> <code>std::map&lt;std::string, CityRecord&gt;cityMap;</code><br> <code>cityMap[&quot;ShanXi&quot;] = CityRecord&#123; &quot;ShanXi&quot;,50000 &#125;;</code> </p>
<p> 在这里我们对ShanXi这个键映射了一个值50000，这里的有一个需要注意的点，就是插入操作符”[ ]”。</p>
<h3 id="操作符”-”"><a href="#操作符”-”" class="headerlink" title="操作符”[ ]”"></a>操作符”[ ]”</h3><p>写过数据结构的都知道，常常要为一个操作符或函数提供不同的版本来适配const和非const，但是这个方括号操作符并没有const版本，为什么呢？</p>
<p><code>operator[]</code>：如果键不存在，它会创建一个新的键值对，并将值初始化为该类型的默认值。例如，如果值类型是<code>int</code>，新创建的键值对的值将被初始化为<code>0</code>。const表示常量不可修改，而”[ ]”本身就是修改的行为，所以没有const版本，对应的容器内有个at方法</p>
<p><code>.at()</code>：这个方法只用来访问已存在的键值对。如果你尝试使用<code>.at()</code>访问一个不存在的键，它会抛出一个<code>std::out_of_range</code>异常。<code>.at()</code>方法不会创建新的键值对因此，你可以认为<code>.at()</code>是一个更安全的方法，因为它不会意外地插入新的键值对。如果你需要确保不修改<code>unordered_map</code>，应该使用<code>.at()</code>方法。</p>
<h3 id="回到之前的内容"><a href="#回到之前的内容" class="headerlink" title="回到之前的内容"></a>回到之前的内容</h3><p>当你向<code>std::unordered_map</code>插入一个键值对或者查找一个键时，发生的步骤大致如下：</p>
<ol>
<li>哈希函数接收键作为输入。</li>
<li>哈希函数计算并返回一个哈希值。</li>
<li>哈希表根据这个哈希值决定元素应该存储或查找的桶的位置。</li>
</ol>
<p>这个过程使得查找和插入操作非常快速，因为它避免了遍历整个容器。哈希值是内部使用的，而作为用户，你通常不需要直接处理哈希值，你只需要关心键和值。</p>
<p>方才那个hash模板特化的代码属是抽象， <code>hash&lt;&gt;()()</code> 这这这，大不合适，但是也不理解了，会用即可，</p>
<ol>
<li><code>hash&lt;int&gt;()</code>和<code>hash&lt;std::string&gt;()</code>是创建一个<code>std::hash</code>类型的临时对象，这个对象专门用来计算<code>int</code>类型和<code>std::string</code>类型的哈希值。</li>
<li>紧跟在后面的<code>()</code>是对这个临时对象的函数调用操作符，它将 <code>key.CityName</code> 作为参数传入，计算它们的哈希值。</li>
</ol>
<p>让我们分解一下这个表达式：</p>
<ul>
<li><code>std::hash&lt;int&gt;()</code>创建了一个用于计算整数哈希值的<code>std::hash</code>对象。</li>
<li><code>std::hash&lt;int&gt;()(key.CityName)</code>调用这个对象的<code>operator()</code>，传入<code>key.CityName</code>作为参数，返回<code>key.CityName</code>的哈希值。</li>
</ul>
<p>总之：无论是普通类型还是自定义类型的键，在<code>std::unordered_map</code>中，键都会通过内部的哈希函数转换为哈希值。然后，这个哈希值被用来在哈希表的内部结构中定位和访问对应的值</p>
<p>最后关于解决哈希冲突，开放寻址法（Open Addressing）和链表法（Chaining）是解决哈希表中哈希冲突的两种常见方法。它们的主要区别在于处理冲突的方式不同。</p>
<p><strong>开放寻址法</strong>：</p>
<ul>
<li>当插入的元素发生冲突时，即该位置已被占用，开放寻址法会寻找哈希表中的下一个空闲位置。</li>
<li>实现方式包括线性探测、二次探测和双重散列等。</li>
<li>开放寻址法的优点是实现简单，数据存储在一个连续的数组中，可以利用CPU缓存加快访问速度。</li>
<li>缺点是删除操作复杂，容易产生聚集问题，导致性能下降。</li>
</ul>
<p><strong>链表法</strong>：</p>
<ul>
<li>每个哈希表的槽位对应一个链表。所有散列值相同的元素都会被添加到相同槽位对应的链表中。</li>
<li>当发生冲突时，元素会被直接添加到链表的末尾。</li>
<li>链表法的优点是处理冲突简单，扩展容易，不会产生聚集问题。</li>
<li>缺点是链表的指针需要额外的内存空间，且链表的遍历可能会因为CPU缓存不命中而较慢。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的哈希表实现</span></span><br><span class="line">std::unordered_map&lt;<span class="type">char</span>, std::list&lt;std::string&gt;&gt; library;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加书籍到哈希表</span></span><br><span class="line">library[<span class="string">&#x27;A&#x27;</span>].<span class="built_in">push_back</span>(<span class="string">&quot;Algorithms&quot;</span>);</span><br><span class="line">library[<span class="string">&#x27;A&#x27;</span>].<span class="built_in">push_back</span>(<span class="string">&quot;Artificial Intelligence&quot;</span>);</span><br><span class="line">library[<span class="string">&#x27;D&#x27;</span>].<span class="built_in">push_back</span>(<span class="string">&quot;Data Structures&quot;</span>);</span><br><span class="line">library[<span class="string">&#x27;C&#x27;</span>].<span class="built_in">push_back</span>(<span class="string">&quot;Computer Networks&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找书籍</span></span><br><span class="line"><span class="type">char</span> bucket = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 假设我们想找以&#x27;A&#x27;开头的书</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; book : library[bucket]) &#123;</span><br><span class="line">    std::cout &lt;&lt; book &lt;&lt; std::endl; <span class="comment">// 将打印出桶中的所有书籍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>std::list&lt;std::string&gt;</code> 链表法</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/12/C++-NULL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/12/C++-NULL/" class="post-title-link" itemprop="url">NULL和nullptr</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-12 12:00:00 / 修改时间：19:08:27" itemprop="dateCreated datePublished" datetime="2024-03-12T12:00:00+08:00">2024-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>在C++中，<code>NULL</code>和<code>nullptr</code>都用于表示空指针，但它们之间存在一些重要的区别：</p>
<ul>
<li><code>NULL</code>是一个宏，通常被定义为整数0。在C++中，<code>NULL</code>可能会导致类型歧义，因为它可以被视为整数而不仅仅是指针。</li>
<li><code>nullptr</code>是C++11中引入的一个关键字，它的类型是<code>std::nullptr_t</code>。<code>nullptr</code>专门用于表示空指针，它可以隐式转换为任何指针类型，但不会转换为整数类型，这避免了与整数的歧义。</li>
</ul>
<p>例如，如果你有两个重载的函数，一个接受整数类型参数，另一个接受指针类型参数，使用<code>NULL</code>可能会导致调用整数类型的版本，而使用<code>nullptr</code>则会明确调用指针类型的版本。这就是<code>nullptr</code>相较于<code>NULL</code>的一个优势。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>*)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用NULL可能会调用func(int)版本，因为NULL可以被视为整数0 </span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);  </span><br><span class="line"><span class="comment">// 使用nullptr将明确调用func(char*)版本 </span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>); </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1282295/what-is-the-nullptr-keyword-and-why-is-it-better-than-null">此外，<code>nullptr</code>不仅清晰地表达了程序员的意图，即表示空指针，而且还提供了更好的类型安全性。</a></p>
<p>额外内容：</p>
<ol>
<li>Entity() &#x3D; default;</li>
</ol>
<p>在C++中，<code>Entity()=default;</code>是C++11标准中引入的一种语法，用于告诉编译器使用默认生成的构造函数。这意味着你不需要为这个构造函数编写任何特定的实现代码，编译器会为你生成一个标准的构造函数。</p>
<p>这个功能特别有用，因为在某些情况下，如果你已经提供了其他构造函数，编译器不会自动生成默认构造函数。使用<code>=default</code>可以确保即使在这些情况下，你也有一个默认的构造函数。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6502828/what-does-default-mean-after-a-class-function-declaration">此外，使用<code>=default</code>可以保持类的某些属性，比如让类保持为聚合类型或者平凡类型。如果你想让你的类保持为聚合类型或者平凡类型，你就需要使用<code>=default</code>，而不是提供一个空的构造函数实现</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6502828/what-does-default-mean-after-a-class-function-declaration">1</a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20828907/the-new-syntax-default-in-c11">2</a>。</p>
<p>简而言之，<code>Entity()=default;</code>的作用是：</p>
<ul>
<li>告诉编译器生成默认的构造函数。</li>
<li>确保即使定义了其他构造函数，类也有一个默认构造函数。</li>
<li>保持类的聚合或平凡类型的特性。</li>
</ul>
<ol start="2">
<li><code>offsetof</code></li>
</ol>
<p>“offset of”宏在C和C++编程中用来确定结构体(struct)或类中成员变量的内存偏移量。简单地说，它会给出从结构体或类的开始地址到特定成员的字节偏移量。这个宏通常在与底层硬件进行交互、进行内存操作时非常有用，例如，在需要对结构体中的字段进行指针运算时。</p>
<p>当你有一个结构体类型，并且想知道其中某个成员相对于结构体起始位置的偏移量时，你可以使用”offset of”宏。这样可以帮助你计算指向该成员的指针，或者在进行序列化和反序列化操作时确定字段的位置。</p>
<p>宏通常定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp;(((type *)0)-&gt;member))</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>type</code>是你的结构体或类的类型，而<code>member</code>是你想获取偏移量的成员变量的名称。宏的工作原理是将一个假想的对象的地址设为零然后取成员的地址。由于假想对象的起始地址是0，所以成员地址实际上就是偏移量。注意，在C++中，更倾向于使用<code>std::offsetof</code>，因为这是一个标准库特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Entity* m_Parent;</span><br><span class="line">	std::string m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EntityData</span></span><br><span class="line">&#123;</span><br><span class="line">	EntityData* m_Parent;</span><br><span class="line">	std::string m_Name;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">Entity_GetName</span><span class="params">(<span class="type">const</span> EntityData*self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> self-&gt;m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Entity_Print</span><span class="params">(EntityData* self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Entity* entity=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//	std::cout &lt;&lt; entity-&gt;GetName();</span></span><br><span class="line">	 entity-&gt;<span class="built_in">Print</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="type">uint64_t</span> offset = <span class="built_in">offsetof</span>(EntityData, m_Name);</span><br><span class="line">	</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;offset of m_Name is &quot;</span> &lt;&lt; offset&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	EntityData* entitydata = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//	std::cout &lt;&lt; entitydata-&gt;GetName();</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/11/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/11/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">二分查找</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-11 19:00:02" itemprop="dateCreated datePublished" datetime="2024-03-11T19:00:02+08:00">2024-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 17:35:10" itemprop="dateModified" datetime="2024-03-12T17:35:10+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">排序</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>483</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 二分查找的速度比简单查找快得多。<br> O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。<br> 算法运行时间并不以秒为单位。<br> 算法运行时间是从其增速的角度度量的。<br> 算法运行时间用大O表示法表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">binary_search</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span>&amp; target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> high = vec.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span>* mid = <span class="keyword">new</span> <span class="type">int</span>;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (low&lt;=high)</span><br><span class="line">	&#123;</span><br><span class="line">		*mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (target &gt; vec[*mid])</span><br><span class="line">		low = *mid;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; vec[*mid])</span><br><span class="line">		high = *mid;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (target == vec[*mid])</span><br><span class="line">		<span class="keyword">return</span> *mid;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;not find&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/11/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/11/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">快速排序</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-11 19:00:02" itemprop="dateCreated datePublished" datetime="2024-03-11T19:00:02+08:00">2024-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-12 17:45:12" itemprop="dateModified" datetime="2024-03-12T17:45:12+08:00">2024-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">排序</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39181839/article/details/109478094">快速排序算法—图文详解，一篇就够了！_快速排序算法图解-CSDN博客</a></p>
<p>快速排序，递归+分治,就是c语言中的qsort</p>
<p>C++中std::sort并不是简单的快速排序，它对快速排序进行了优化。此外，它还结合了插入排序和推排序。系统会根据数据形式和数据量自动选择合适的排序方法。它每次排序中不只选择一种方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。</p>
<p>自己实现快速排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> low,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &gt;= high)<span class="keyword">return</span>;<span class="comment">// 递归基</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> pivot = vec[low];<span class="comment">//记录基准值pivot</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i = low, j = high;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//从右向左找</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; vec[j] &gt;= pivot) j--;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) vec[i++] = vec[j];</span><br><span class="line">		<span class="comment">//从左向右找</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; vec[i] &lt;= pivot) i++;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)vec[j++] = vec[i];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时left=right，用pivot替换这个位置的数字</span></span><br><span class="line">	vec[i] = pivot;<span class="comment">// 将基准值放到正确的位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">quicksort</span>(vec, low, i - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></span><br><span class="line">	<span class="built_in">quicksort</span>(vec, i + <span class="number">1</span>, high); <span class="comment">// 递归排序右子数组</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printvector</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : vec)</span><br><span class="line">		std::cout &lt;&lt; value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; vector=&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">quicksort</span>(vector,<span class="number">0</span>,vector.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">Printvector</span>(vector);</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己写的qsort比C++的std::sort快一点点（debug）</p>
<p><img src="http://cdn.rhahr.icu/ca726a383dea8ea75f31a79c71fc86c.png"></p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/09/C++-Perfect%20Forwarding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/09/C++-Perfect%20Forwarding/" class="post-title-link" itemprop="url">Perfect Forwarding</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-09 19:00:02 / 修改时间：18:51:33" itemprop="dateCreated datePublished" datetime="2024-03-09T19:00:02+08:00">2024-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>完美转发是指在模板函数中将接收到的参数无损地转发到另一个函数的能力。这是通过<code>std::forward</code>来实现的，它是一个特殊的模板函数，用于保持原始参数的值类别（左值或右值）。</p>
<p>当你在模板函数中使用<code>std::forward&lt;Args&gt;(args)...</code>时，它会根据每个参数的原始值类别来转发这些参数。如果原始参数是左值，那么转发后它仍然是左值；如果原始参数是右值，那么转发后它也是右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;     </span><br><span class="line"><span class="comment">// 使用std::forward来完美转发参数   </span></span><br><span class="line"><span class="built_in">another_function</span>(std::forward&lt;Args&gt;(args)...); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这种机制非常重要，因为它允许你编写通用代码，同时保持参数的优化（比如避免不必要的拷贝）。完美转发是现代C++中实现高效和灵活代码的关键技术之一。接下来一个一个解释。</p>
<h2 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h2><p>万能引用，形如<code>T&amp;&amp; args</code> 乍一看这不就是右值引用吗，错啦~，这里还是写完整一点好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; args)</span> </span>&#123;     </span><br></pre></td></tr></table></figure>

<p>上边的例子中</p>
<p>右值引用是一个具体的类型才是右值引用，例如 <code>int&amp;&amp; a</code> ,万能引用则类型是由推导可知的</p>
<p> 确实看起来像是一个右值引用，但它实际上是一个万能引用。这是因为 <code>T</code> 是一个模板参数，而不是一个具体的类型。当模板函数或方法中出现 <code>T&amp;&amp;</code> 时，其中的 <code>T</code> 是通过类型推导得到的，所以 <strong><code>T&amp;&amp;</code> 可以根据传入参数的类型变成左值引用或右值引用。</strong> 这就是万能引用的作用</p>
<p>在模板类中，如果 <code>pushback</code> 函数被调用并传入一个右值，那么 <code>T</code> 将被推导为非引用类型，使得 <code>T&amp;&amp;</code> 成为一个右值引用。如果传入一个左值，<code>T</code> 将被推导为左值引用类型，使得 <code>T&amp;&amp;</code> 实际上成为一个左值引用。这就是万能引用的特性，它可以绑定到左值和右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发 arg</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理左值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你调用 <code>relay(a);</code> 并且 <code>a</code> 是一个左值时，<code>T</code> 推导为 <code>int&amp;</code>，使得 <code>T&amp;&amp;</code> 实际上变成了 <code>int&amp; &amp;&amp;</code>。根据<strong>引用折叠</strong>规则，这最终会折叠成 <code>int&amp;</code>，所以 <code>arg</code> 是一个左值引用。<code>std::forward&lt;T&gt;(arg)</code> 此时会按照左值处理 <code>arg</code>。</p>
<p>当你调用 <code>relay(10);</code> 并且 <code>10</code> 是一个右值时，<code>T</code> 推导为 <code>int</code>，使得 <code>T&amp;&amp;</code> 实际上是 <code>int&amp;&amp;</code>，一个真正的右值引用。<code>std::forward&lt;T&gt;(arg)</code> 此时会按照右值处理 <code>arg</code>。</p>
<p>这就是为什么 <code>T&amp;&amp; arg</code> 不总是右值引用，它取决于传入参数的类型。这种机制允许 <code>relay</code> 函数完美转发它的参数，无论它们是左值还是右值。</p>
<blockquote>
<p>实际上在移动语义中，也是一样的，如果类型是模板类型则会自动推导，但是传参进来的不管是左值还是右值都无所谓，因为有std::move</p>
</blockquote>
<p>那么什么是引用折叠呢？</p>
<h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>引用折叠是C++中的一个规则，它处理在模板和类型推导中出现的多层引用的情况。在C++中，你不能直接创建引用的引用，比如 <code>int&amp;&amp; &amp;</code> 或 <code>int&amp; &amp;&amp;</code>。但在模板和自动类型推导中，这样的情况是可能发生的。引用折叠规则决定了这些多层引用如何被解析为单一的引用。</p>
<p>引用折叠的规则很简单：</p>
<ul>
<li>如果在任何引用对中至少有一个是左值引用（<code>&amp;</code>），那么结果就是左值引用（<code>&amp;</code>）。</li>
<li>如果两个引用都是右值引用（<code>&amp;&amp;</code>），那么结果就是右值引用（<code>&amp;&amp;</code>）。</li>
</ul>
<p>例如</p>
<ul>
<li><code>int&amp; &amp;&amp;</code> 折叠为 <code>int&amp;</code></li>
<li><code>int&amp;&amp; &amp;</code> 折叠为 <code>int&amp;</code></li>
<li><code>int&amp; &amp;</code> 折叠为 <code>int&amp;</code></li>
<li><code>int&amp;&amp; &amp;&amp;</code> 折叠为 <code>int&amp;&amp;</code></li>
</ul>
<h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>简洁补一下forward</p>
<p><code>std::forward</code> 是 C++11 引入的一个模板函数，它用于实现所谓的完美转发。完美转发允许你将函数的参数以原始的左值或右值形式传递给其他函数，这意味着保持参数的原始值类别（lvalue 或 rvalue）不变。</p>
<p>当我们定义一个模板函数用于转发参数时，通常我们会希望保持原始参数的左值&#x2F;右值性质，并且将其转发给另一个函数。假设我们定义如下函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">another_function</span>(arg);  <span class="comment">// 这里的arg永远是左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>T&amp;&amp;</code> 是通用引用，它可以匹配任意左值或右值。但是问题在于，传给 <code>another_function</code> 的 <code>arg</code> 无论原始参数是左值还是右值，在 <code>wrapper</code> 函数内部，<code>arg</code> 始终是左值。这就是我们需要 <code>std::forward</code> 的地方。</p>
<p><code>std::forward</code> 的作用就是，保持原有参数的左值&#x2F;右值性质，并正确地转发给另一个函数。所以上述代码应当修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">another_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在无论 <code>arg</code> 是左值还是右值，<code>std::forward&lt;T&gt;(arg)</code> 都能保持其原有性质，并正确地转发给 <code>another_function</code> 函数。这就是所谓的”完美转发”。</p>
<p>总结一下，<code>std::forward</code> 是C++中实现”完美转发”的重要工具，它能够保持函数参数的原有性质（包括左值、右值特性），并且将其转发给另一个函数。</p>
<h2 id="完美转发-x3D-x3D"><a href="#完美转发-x3D-x3D" class="headerlink" title="完美转发&#x3D;&#x3D;"></a>完美转发&#x3D;&#x3D;</h2><p>万能引用可以保持传入参数的属性不变，乍一看很鸡肋，刚才的例子中直接在main中调用process不也就直接调用了对应的左值右值版本的函数了吗，为什么还要调用 relay这个万能引用版本呢?</p>
<p> 回想起之前学的可变参数模板就派上用场了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">emplaceback</span><span class="params">(Args&amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Size &gt;= m_Capacity)</span><br><span class="line">			<span class="built_in">ReAlloca</span>(m_Capacity + m_Capacity / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">new</span>(&amp;m_Data[m_Size]) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="comment">//展开： std::forward&lt;Args&gt;(args1),std::forward&lt;Args&gt;(args2),...</span></span><br><span class="line">		<span class="keyword">return</span> m_Data[m_Size++];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>完美转发 &#x3D; 万能引用 + std::forward</p>
<p>第六行placement new语法new(memory) Type(Args),此处意为不使用new分配内存而是直接在m_Data[m_Size]（m_Data最后一个数据位置+1）处就地构造一个T类型的参数，参数是万能引用传过来的参数包args，参数包的可变数量可变类型的参数正好合适用完美转发来处理</p>
<p>总之在我看来，完美转发就是通过万能引用来接受传入的参数并根据引用折叠规则来转换成想要的类型后，通过std::forward 正确的转发出去</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/09/C++-new%20and%20delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/09/C++-new%20and%20delete/" class="post-title-link" itemprop="url">new & delete</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-09 19:00:02" itemprop="dateCreated datePublished" datetime="2024-03-09T19:00:02+08:00">2024-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-11 13:50:56" itemprop="dateModified" datetime="2024-03-11T13:50:56+08:00">2024-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h2><p><code>new</code>和<code>delete</code>是用于动态内存管理的两个重要运算符。它们分别用于在堆上分配和释放内存，同时也负责调用对象的构造函数和析构函数。</p>
<ul>
<li><code>new</code>用于分配内存并调用构造函数初始化对象。</li>
<li><code>delete</code>用于释放由<code>new</code>分配的内存，并调用析构函数清理资源。</li>
<li>使用<code>new</code>分配的每块内存都应该用对应的<code>delete</code>释放，以避免内存泄漏</li>
</ul>
<p><strong>new操作符</strong>是C++语言内置的，用于分配内存并调用构造函数来创建对象。当你使用<code>new</code>时，它会执行两个主要步骤：</p>
<ol>
<li>调用<code>operator new</code>函数来分配足够的内存。</li>
<li>在分配的内存上调用对象的构造函数来初始化对象。</li>
</ol>
<p>例如，以下代码使用了<code>new</code>操作符来创建一个<code>string</code>对象：</p>
<p><code>std::string* ps = new std::string(&quot;Hello, World!&quot;); </code></p>
<p>区别于C中的malloc和free <code>malloc</code>和<code>free</code>是C语言中用于动态内存分配的函数,</p>
<p><strong>malloc和free</strong>：</p>
<ul>
<li><code>malloc</code>用于分配一定大小的内存块，并返回一个指向该内存的指针。它不会调用构造函数，所以不会初始化对象。</li>
<li><code>free</code>用于释放<code>malloc</code>分配的内存。它不会调用析构函数，所以不会清理对象。</li>
<li><code>malloc</code>的返回类型是<code>void*</code>，所以在使用前需要强制转换到适当的类型。</li>
</ul>
<p><strong>new和delete</strong>：</p>
<ul>
<li><code>new</code>用于分配内存并自动调用构造函数来初始化对象。</li>
<li><code>delete</code>用于释放<code>new</code>分配的内存，并自动调用析构函数来清理对象。</li>
<li><code>new</code>返回的是正确的类型指针，不需要类型转换。</li>
</ul>
<p><strong>区别</strong>：</p>
<ol>
<li><strong>类型安全</strong>：<code>new</code>是类型安全的，会返回正确的类型指针；而<code>malloc</code>返回<code>void*</code>，需要强制类型转换。</li>
<li><strong>初始化</strong>：<code>new</code>会自动调用构造函数初始化对象；<code>malloc</code>仅分配内存，不初始化。</li>
<li><strong>异常处理</strong>：<code>new</code>在内存分配失败时会抛出异常；<code>malloc</code>在失败时返回<code>NULL</code>。</li>
<li><strong>配对使用</strong>：使用<code>new</code>分配的内存必须用<code>delete</code>释放；使用<code>malloc</code>分配的内存必须用<code>free</code>释放。</li>
<li><strong>重载</strong>：<code>new</code>和<code>delete</code>可以被重载；<code>malloc</code>和<code>free</code>不能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用malloc分配内存</span></span><br><span class="line"><span class="type">int</span>* myArray = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用free释放内存</span></span><br><span class="line"><span class="built_in">free</span>(myArray);</span><br></pre></td></tr></table></figure>

<h2 id="operator-new-amp-operator-delete"><a href="#operator-new-amp-operator-delete" class="headerlink" title="operator new&amp;operator delete"></a>operator new&amp;operator delete</h2><p>先说operator new和new的区别，<code>new</code>和<code>delete</code>是操作符，它们不仅负责内存的分配和释放，还会调用对象的构造函数和析构函数。而<code>operator new</code>和<code>operator delete</code>是全局函数，它们只负责内存的分配和释放，不涉及任何构造或析构过程。简单来说，当你创建和删除一个对象时：</p>
<ul>
<li><p>使用new操作符，它会：</p>
<ol>
<li>调用<code>operator new</code>来分配内存。</li>
<li>在分配的内存上调用构造函数来初始化对象。</li>
<li>返回一个指向新对象的指针。</li>
</ol>
</li>
<li><p>使用delete操作符，它会：</p>
<ol>
<li><p>调用对象的析构函数。</p>
</li>
<li><p>调用<code>operator delete</code>来释放内存。</p>
</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50886514/article/details/115796743">因此，<code>new</code>和<code>delete</code>操作符与<code>operator new</code>和<code>operator delete</code>函数的主要区别在于对象的生命周期管理。<code>new</code>和<code>delete</code>操作符会管理对象的创建和销毁，而<code>operator new</code>和<code>operator delete</code>函数只管理内存。</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50886514/article/details/115796743">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/354046948">2</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ToBeBetterProgramer/articles/3451770.html">3</a></p>
<p>  <a target="_blank" rel="noopener" href="https://codeantenna.com/a/ZgDMWyDczx">这也是为什么你可以重载<code>operator new</code>和<code>operator delete</code>来自定义内存分配和释放的行为，但不能重载<code>new</code>和<code>delete</code>操作符本身。它们的行为是固定的，总是包括调用构造函数和析构函数。</a></p>
<p><strong><code>operator new</code>是一个用于内存分配的函数。</strong>当你使用<code>new</code>关键字创建对象时，<code>new</code>操作符会调用<code>operator new</code>函数来分配足够的内存。这个函数通常返回一个指向未初始化内存的<code>void*</code>指针。<code>operator new</code>可以被重载，这意味着你可以自定义内存分配的行为。</p>
<p>所以说功能上来说 new &#x3D; operator new+构造函数 </p>
<p>例如，你可以这样调用<code>operator new</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *rawMemory = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(MyClass)); </span><br></pre></td></tr></table></figure>

<p>这会分配足够的内存来存储<code>MyClass</code>类型的对象。然后，<code>new</code>操作符会在这块分配的内存上调用构造函数来初始化对象。</p>
<p><em>::operator new是全局的operator new如果没有重载版本，那么默认就是全局版本</em></p>
<blockquote>
<p>刚开始理解不了，operator本身就是重载的意思，类似于operator+，难道operator new不是重载new吗，如果说operator new可以重载不应该是operator operator new这样才对</p>
<p>解释：当我们说”重载运算符”时，通常是指像<code>operator+</code>或<code>operator==</code>这样的运算符。然而，<code>operator new</code>和<code>operator delete</code>是特殊的情况，它们是与内存分配和释放相关的函数，而不是传统意义上的运算符。</p>
<p><code>operator new</code>和<code>operator delete</code>的命名方式可能会让人误以为它们是重载了<code>new</code>和<code>delete</code>运算符，但实际上它们是独立的函数。你可以重载这些函数来改变默认的内存分配和释放行为，但这并不影响<code>new</code>和<code>delete</code>运算符本身的语义。</p>
<p>因此，当我们说”重载<code>operator new</code>“时，我们是指提供一个新的函数定义来替代默认的内存分配行为。这不同于重载如<code>operator+</code>这样的运算符，后者涉及到改变已有运算符的行为。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/slgkaifa/p/6887887.html">此外，还有一种特殊的<code>operator new</code>称为placement new，它允许在已经分配的内存上构造对象。</a></p>
<h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p><code>placement new</code>是C++中的一个特殊功能，它允许你在已经分配的内存上构造一个对象。这与普通的<code>new</code>操作符不同，后者会自动分配内存然后在该内存上构造对象。<code>placement new</code>的用途通常是为了在特定的内存位置上创建对象，这可以用于优化性能，避免不必要的内存分配和释放，或者用于在特定的硬件地址上构造对象。</p>
<p>使用<code>placement new</code>时，你需要提供一个指向已分配内存的指针。这里是一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 必须包含这个头文件  char buffer[sizeof(MyClass)]; // 分配一块足够大的内存 MyClass *pMyClass = new (buffer) MyClass; // 在buffer指向的内存上构造对象 </span></span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>buffer</code>是一个字符数组，我们在它的地址上使用<code>placement new</code>构造了一个<code>MyClass</code>类型的对象。注意，因为<code>placement new</code>不分配内存，所以你必须确保提供的内存足够大且适当对齐，以容纳你想要构造的对象类型。</p>
<p>重要的是要记住，使用<code>placement new</code>创建的对象不应该使用普通的<code>delete</code>来销毁，因为这会尝试释放你提供的内存，而这块内存可能不是通过普通的<code>new</code>分配的。相反，你应该显式地调用对象的析构函数来销毁它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pMyClass-&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 显式调用析构函数 </span></span><br></pre></td></tr></table></figure>

<p>这样做之后，你可以自由地重新使用或释放那块内存，但这个管理过程是由程序员负责的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/228001107">placement new机制 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="显式调用析构"><a href="#显式调用析构" class="headerlink" title="显式调用析构"></a>显式调用析构</h2><p>显式调用析构函数是指直接使用对象的析构函数名来销毁对象，而不是等待对象的作用域结束时自动调用析构函数。这通常用于与placement new一起，手动管理对象的生命周期。</p>
<p>显式调用析构函数的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 对于动态分配的对象 </span></span><br><span class="line">myObject.~<span class="built_in">MyClass</span>(); <span class="comment">// 对于栈分配的对象 </span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>MyClass</code>是类名，<code>~MyClass()</code>是析构函数。通过这种方式，可以在对象的生命周期内的任何时刻销毁对象。</p>
<p><strong>需要注意的是，显式调用析构函数通常只在特殊情况下使用，例如在使用placement new时，或者在使用自定义内存管理策略时。在大多数情况下，应该避免显式调用析构函数，因为它可能导致对象被销毁两次，从而引发未定义行为。</strong></p>
<p>​    如果使用placement new在预分配的内存上构造了一个对象，你需要在不再需要该对象时显式调用其析构函数来销毁它，然后释放内存。这是因为placement new不会在对象的作用域结束时自动调用析构函数。</p>
<p>如果使用<code>placement new</code>和显式调用析构函数的组合来管理对象的生命周期，那么当对象的作用域结束时，编译器不会再次自动调用析构函数。这是因为编译器只会自动调用那些以普通方式（非placement new）构造的对象的析构函数。</p>
<p>当手动调用析构函数后，对象已经被销毁，所以编译器不会再尝试销毁它。因此，不会出现二次销毁的情况。但是需要确保在调用析构函数之后，也使用正确的方法释放内存（例如，如果使用<code>operator new</code>分配内存，则应使用<code>operator delete</code>释放内存）。</p>
<p>这种手动管理对象生命周期的方法需要谨慎使用，因为如果忘记调用析构函数或释放内存，就可能导致资源泄漏或其他未定义行为。所以，这通常只在特殊情况下使用，比如在自定义内存管理或优化性能时。</p>
<p>新问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">popback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            m_Size--;</span><br><span class="line">            m_Data[m_Size].~<span class="built_in">T</span>(); <span class="comment">// 显式调用析构函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++) &#123;</span><br><span class="line">            m_Data[i].~<span class="built_in">T</span>(); <span class="comment">// 显式调用析构函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_Size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>.~T();</code> <code>~T()</code>表示调用类型<code>T</code>的析构函数。这是泛型编程的一部分，允许<code>Vector</code>类处理任何类型的对象。当<code>T</code>是一个类类型时，这个调用将执行该类的析构函数，负责清理资源。当<code>T</code>是一个内置类型时(int,float,string…)，这个调用不会有任何效果，但仍然是合法的。</p>
<p>也就是说，如果此处的T是另一个类类型例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x = <span class="number">0.0f</span>, y = <span class="number">0.0f</span>, z = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="built_in">Vector3</span>();</span><br><span class="line">    ~<span class="built_in">Vector3</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么.~T()就相当于是调用Vector3来销毁对象，之后还需要operator delete 来释放内存块。</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/09/C++-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/09/C++-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">可变参数模板/函数</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-09 19:00:02 / 修改时间：18:08:46" itemprop="dateCreated datePublished" datetime="2024-03-09T19:00:02+08:00">2024-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>跟着cherno手写基本的Vector数据结构式遇到的，好像是个C++11的基本语法？第一次见。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt;<span class="comment">//模板参数包</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">emplaceback</span><span class="params">(Args&amp;&amp;...args)</span><span class="comment">//函数参数包</span></span></span><br><span class="line"><span class="function">	</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>可变数量的参数，也称为可变参数模板，允许你创建可以接受任意数量参数的函数模板。这是通过使用参数包（parameter pack）来实现的，它是一个特殊的模板参数，可以接受零个或多个模板参数。</p>
<p>在函数模板中，当你看到<code>Args&amp;&amp;...args</code>这样的语法时，它表示函数可以接受任意数量的参数，并且每个参数都可以是不同的类型。这里的<code>&amp;&amp;</code>是一个万能引用（universal reference），它可以绑定到左值或右值。参数包<code>args...</code>可以在函数体内展开，这样每个参数都可以被单独处理。</p>
<p>参数包的语法使用省略号（<code>...</code>），在可变参数模板中代表了参数的集合。这允许模板接受任意数量和类型的参数。在模板定义中，省略号用于声明参数包；在模板实现中，省略号用于展开参数包。</p>
<p>这里有两个主要的用途：</p>
<ol>
<li><p><strong>声明参数包</strong>： 在模板定义中，<code>typename... Args</code> 或 <code>class... Args</code> 表示一个模板参数包，<code>Args</code> 可以是任意数量的类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123; <span class="comment">/* ... */</span> &#125;; </span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span></span><br><span class="line"><span class="function"> <span class="type">void</span> <span class="title">myFunction</span><span class="params">(Args... args)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">/* ... */</span> &#125;; </span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>展开参数包</strong>： 在模板实现中，你可以使用省略号来展开参数包，这样每个参数都会被处理,<code>args...</code> 展开参数包，将其转换为一个逗号分隔的列表，用于传递参数或在初始化列表中。。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(Args... args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">// 使用折叠表达式展开参数包     </span></span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在这个例子中，<code>myFunction</code> 可以接受任意数量和类型的参数，<code>args...</code> 在函数体内被展开，每个参数都被发送到 <code>std::cout</code>。</p>
<p>我是这么理解的</p>
<p> <code>...</code> 是参数本身，<code>Args</code> 是当前传入的参数对应的类型的一个通用名，也就是<code>...</code> 代表可变数量，<code> Args</code> 代表可变参数，合起来就是可变数量可变参数的模板，这些是传参部分，在对参数的处理部分使用折叠表达式来对参数包<code> ...</code> 来展开后进行相应的处理</p>
<h2 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h2><p><em>看这部分前请先了解文末的折叠表达式</em></p>
<p>在使用部分看开头那个完整的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">emplaceback</span><span class="params">(Args&amp;&amp;...args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_Size &gt;= m_Capacity)</span><br><span class="line">			<span class="built_in">ReAlloca</span>(m_Capacity + m_Capacity / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">new</span>(&amp;m_Data[m_Size]) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">		<span class="keyword">return</span> m_Data[m_Size++];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到</p>
<ol>
<li>placemen new—<code>new(memory) Type(Args)</code></li>
<li>完美转发        —<code>std::forward&lt;type&gt;(args) </code></li>
<li>万能引用         —<code>Args&amp;&amp;...args</code></li>
</ol>
<p>这些详见</p>
<blockquote>
<p>[万能引用，完美转发 | HahのBlog (rhahr.top)](<a target="_blank" rel="noopener" href="https://www.rhahr.top/2024/03/09/C++-Perfect">https://www.rhahr.top/2024/03/09/C++-Perfect</a> Forwarding&#x2F;) </p>
</blockquote>
<p> <code>std::forward&lt;Args&gt;(args)...</code> 这里展开就像是</p>
<p><code> std::forward&lt;Args&gt;(args1),std::forward&lt;Args&gt;(args2)</code>  </p>
<p>更清晰点，如果参数包里有两个参数A类型的a，B类型的b那么就是</p>
<p><code>std::forward&lt;A&gt;(a),std::forward&lt;B&gt;(b)</code>  </p>
<h1 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h1><p>折叠表达式是 C++17 中引入的，它允许我们对可变参数模板中的参数包进行操作。参数包就是那些用省略号（<code>...</code>）表示的一系列参数。</p>
<p>想象一下，你有一堆书要叠起来。你可以从左到右（左折叠），也可以从右到左（右折叠）开始叠。在 C++ 中，这个“叠书”的动作就是用某个操作符（比如加号 <code>+</code>）来“叠加”参数包中的所有参数。</p>
<p>这里有几个例子：</p>
<ul>
<li><strong>加法折叠</strong>：如果你想把所有的参数加起来，你可以写成 <code>(args + ...)</code>，这就是一个右折叠，因为它从右边开始叠加参数。如果你写成 <code>(... + args)</code>，这就是一个左折叠，因为它从左边开始叠加参数。</li>
<li><strong>逻辑与折叠</strong>：如果你想检查一系列布尔值是否都为真，你可以使用逻辑与操作符 <code>&amp;&amp;</code> 并写成 <code>(... &amp;&amp; args)</code>。这会检查每个参数，只要有一个为假，整个表达式就为假。</li>
<li><strong>逗号折叠</strong>：逗号操作符 <code>(,)</code> 可以用来执行一系列操作，然后返回最后一个操作的结果。例如，<code>(cout &lt;&lt; args..., endl)</code> 会打印所有参数，然后打印一个换行符。</li>
</ul>
<p>1、一元右折叠(unary right fold)<br>　　( pack op … )<br>　　一元右折叠(E op …)展开之后变为 E1 op (… op (EN-1 op EN))<br>2、一元左折叠(unary left fold)<br>　　( … op pack )<br>　　一元左折叠(… op E)展开之后变为 ((E1 op E2) op …) op EN<br>3、二元右折叠(binary right fold)<br>　　( pack op … op init )<br>　　二元右折叠(E op … op I)展开之后变为 E1 op (… op (EN−1 op (EN op I)))<br>4、二元左折叠(binary left fold)<br>　　( init op … op pack )</p>
<p>　　二元左折叠(I op … op E)展开之后变为 (((I op E1) op E2) op …) op EN</p>
<p>语法形式中的op代表运算符，pack代表参数包，init代表初始值。<br>初始值在右边的为右折叠，展开之后从右边开始折叠。而初始值在左边的为左折叠，展开之后从左边开始折叠。<br>不指定初始值的为一元折叠表达式，而指定初始值的为二元折叠表达式。<br>当一元折叠表达式中的参数包为空时，只有三个运算符（&amp;&amp; || 以及逗号）有缺省值，其中&amp;&amp;的缺省值为true,||的缺省值为false，逗号的缺省值为void()。</p>
<blockquote>
<p>这篇文章写的很详细了<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/670871464">理解C++折叠表达式（Fold Expression） - 知乎 (zhihu.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在之前的例子中这就可以看作是<code>((((std::cout&lt;&lt;args1)&lt;&lt;args2)&lt;&lt;...)&lt;&lt;argsN)&lt;&lt;&quot;\n&quot;</code> 这里的\n相当于是一个初始值</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/04/C++-%E5%86%85%E5%AD%98%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/04/C++-%E5%86%85%E5%AD%98%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">内存跟踪</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-04 19:00:02 / 修改时间：19:14:58" itemprop="dateCreated datePublished" datetime="2024-03-04T19:00:02+08:00">2024-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存跟踪"><a href="#内存跟踪" class="headerlink" title="内存跟踪"></a>内存跟踪</h2><p>通过跟踪 <code>new</code> 和 <code>delete</code> 操作符的调用来统计内存分配和释放的情况，对于分析内存泄漏或优化内存使用情况很有帮助。对，很有帮助。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体用于跟踪内存分配的统计信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>; <span class="comment">// 总分配量</span></span><br><span class="line">    <span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;      <span class="comment">// 总释放量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前内存使用量</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态实例，用于跟踪整个程序的内存分配情况</span></span><br><span class="line"><span class="type">static</span> AllocationMetrics s_AllocationMetrics;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 new 操作符，跟踪内存分配</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_AllocationMetrics.TotalAllocated += size; <span class="comment">// 更新总分配量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size); <span class="comment">// 调用标准库的 malloc 函数进行内存分配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 delete 操作符，跟踪内存释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_AllocationMetrics.TotalFreed += size; <span class="comment">// 更新总释放量</span></span><br><span class="line">    <span class="built_in">free</span>(memory); <span class="comment">// 调用标准库的 free 函数释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例对象结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印当前内存使用情况</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintMemoryUsage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory Usage: &quot;</span> &lt;&lt; s_AllocationMetrics.<span class="built_in">CurrentUsage</span>() &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PrintMemoryUsage</span>(); <span class="comment">// 打印初始内存使用情况</span></span><br><span class="line">    std::string string = <span class="string">&quot;Cherno&quot;</span>; <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="built_in">PrintMemoryUsage</span>(); <span class="comment">// 打印内存使用情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Object&gt; obj = std::<span class="built_in">make_unique</span>&lt;Object&gt;(); <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="built_in">PrintMemoryUsage</span>(); <span class="comment">// 打印内存使用情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintMemoryUsage</span>(); <span class="comment">// 打印内存使用情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/04/C++-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/04/C++-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" class="post-title-link" itemprop="url">移动语义</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-04 19:00:02" itemprop="dateCreated datePublished" datetime="2024-03-04T19:00:02+08:00">2024-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-09 16:11:02" itemprop="dateModified" datetime="2024-03-09T16:11:02+08:00">2024-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>在C++中，左值（lvalue）和右值（rvalue）是与表达式相关的概念，用于描述表达式的属性。简单来说：</p>
<ul>
<li><strong>左值（lvalue）</strong>是一个标识符，它表示一个具体的内存位置。左值可以出现在赋值语句的左边或右边，可以取地址，并且具有持久性。例如，变量、数组元素、返回左值引用的函数调用等都是左值。</li>
<li><strong>右值（rvalue）</strong>是一个临时值，它没有持久的内存位置。右值通常出现在赋值语句的右边，不能取地址。例如，常量、字面量、临时对象等都是右值。</li>
</ul>
<p>在C++11之后，右值引入了移动语义和右值引用。右值引用允许我们对右值进行更高效的操作，例如移动语义可以将资源从一个对象转移到另一个对象，而不是进行昂贵的复制操作。</p>
<p><strong><u>可以将左值引用和右值引用看作是引用传递的两种方法，它们针对不同的场景和需求提供了不同的引用方式。左值引用用于传递可修改的对象，而右值引用用于支持移动语义和临时对象的操作。</u></strong></p>
<p>简单的来看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>; <span class="comment">// x是一个左值，因为它表示一个具体的内存位置</span></span><br><span class="line"><span class="type">int</span> y = x; <span class="comment">// x是一个左值，因此它可以被复制给另一个变量，y也是一个左值</span></span><br><span class="line"><span class="type">int</span> z = x + y; <span class="comment">// x + y是一个右值，因为它是一个临时值，没有持久的内存位置</span></span><br></pre></td></tr></table></figure>

<p>如果有个函数<code>void SetValue(int&amp; value)&#123;&#125;</code> 在引用传递时，&#x3D;&#x3D;非常量左值引用(“&amp;”)只能接受左值，const type&amp;兼容临时的右值和实际存在的左值变量.右值引用仅能接受右值(“&amp;”)&#x3D;&#x3D;  ,也就是</p>
<p><code>SetValue(10);//右值不能给左值引用赋值  SetValue(i);</code></p>
<p>更简单的一个左值引用<code>int&amp; a = 10;</code> 错误。这里可以理解为引用也就是起别名，只能给其他有名字的变量起别名,所以要不就右值引用  <code>int&amp;&amp; a=10</code>要不就常量左值引用<code>const int&amp; a=10</code>  而常量左值引用相当于编译器先创建了一个临时变量然后把他赋值给那个引用像是:int temp&#x3D;10, int&amp; a&#x3D;temp,不可避免地创建了左值但是也同时支持了左值和右值</p>
<blockquote>
<p>int&amp;&amp; a&#x3D;10中”a” 是个名字，因此它是一个左值。但是它的类型是一个右值引用，也就是说它可以绑定到一个右值上。</p>
</blockquote>
<p>再看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	std::string firstName = <span class="string">&quot;Yan&quot;</span>;</span><br><span class="line">	std::string lastName = <span class="string">&quot;Chernikov&quot;</span>;</span><br><span class="line">	std::string fullName = firstName + lastName;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">PrintName</span>(fullName);<span class="comment">//需要用左值引用来接受左值</span></span><br><span class="line">	<span class="built_in">PrintName</span>(firstName + lastName);</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易能看出来这里等号左边的都是左值，右边的都是右值，写一个打印名字的方法PrintName，通过引用传递的两种方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(std::string&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来检测是否是临时对象，如果是临时对象就可以简单的使用它的资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span><span class="comment">//const type&amp;兼容临时的右值和实际存在的左值变量,</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; std::endl;，</span><br><span class="line">	std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提供了一个右值引用和一个const左值引用但即使这样如果有右值引用的版本则对应情况还是会右值引用</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>学习之前可以先复习一下深拷贝</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.rhahr.top/2024/01/16/C++-CopyConstruction/">复制(深拷贝与浅拷贝)及拷贝构造 | HahのBlog (rhahr.top)</a></p>
</blockquote>
<p>移动语义本质上是通过改变资源的所有权来避免内存的深度拷贝，和浅拷贝很像很像，但是他们的主要区别：</p>
<p><strong>所有权</strong>：浅拷贝不改变对象的所有权，而移动语义会将所有权从源对象转移到目标对象。(窃取)</p>
<p><strong>副作用</strong>：如果我们多次进行浅拷贝，不会对源对象产生任何影响，因为它不改变对象的所有权。然而，由于移动语义会改变对象的所有权，所以在移动操作后源对象就不能再被使用了。</p>
<p><strong>性能</strong>：在某些情况下，如处理大量数据或实现某些数据结构（如std::vector）时，移动语义由于避免了不必要的拷贝，所以它的性能通常优于浅拷贝。</p>
<ul>
<li><p>移动语义是C++11引入的一种优化策略，其背后的目标是消除在复制大对象时可能出现的开销。它允许我们将正在其生命周期结束时的资源(通常是临时对象，也被称为右值)的所有权转移到另一个对象，而不是通过复制来新建资源。</p>
</li>
<li><p>我们使用移动构造函数来实现这种优化。移动构造函数接受一个右值引用，并将资源从源对象”移动”到目标对象，这避免了创建并初始化新对象的开销。在资源被移动之后，源对象会被析构。</p>
</li>
</ul>
<p>总的来说，尽管他们在某种程度上都是在复制数据，但是移动语义和浅拷贝在所有权、副作用和性能等方面都有本质的区别。</p>
<p>就像下面这个例子，如果不使用移动语义，会发生什么。先创建一个复制字符串的类，整体上实现了直接构造Creat和拷贝构造Copied(深拷贝)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">//普通构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>*string)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Copied!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">String</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> []m_Data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint32_t</span> i=<span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_Data[i]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Data;</span><br><span class="line">	<span class="type">uint32_t</span> m_Size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> String&amp;name)</span><br><span class="line">		:<span class="built_in">m_Name</span>(name)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name.<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">	entity.<span class="built_in">PrintName</span>();</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先说结果，运行结果为：</p>
<p><code>Created! \n Copied! \n Destroyed! \n Hello \n Destroyed!</code></p>
<p>打印了两次Destroyed!</p>
<p>在main中Entity一个实例，entity然后通过Entity的构造函数构造m_Name,其实在<code>Entity entity(&quot;Hello&quot;);</code> 这里应该写为<code>Entity entity(String(&quot;Hello&quot;));</code> 也就是说会创建一个临时String对象，所以先Create，然后在Entity中Copied给m_Name，结束后会destroyed，在main函数结束时entity也会被销毁从而触发 String 对象的析构函数，释放 m_Name 对象所占用的内存，所以也会destroy.</p>
<p>分析一下深拷贝了一次，顺便导致多delete了一次，所以会有损耗，这就需要移动语义</p>
<p>也就是创建移动构造函数，在String中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动构造</span></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span><span class="comment">//右值引用，</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = other.m_Data;<span class="comment">//简单的指针赋值,也就是资源所有权转移</span></span><br><span class="line">		other.m_Size = <span class="number">0</span>;</span><br><span class="line">		other.m_Data = <span class="literal">nullptr</span>;<span class="comment">//将临时对象 other 的指针设为nullptr，以确保它不再指向任何有效的内存地址。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>移动构造是通过右值引用，所以要调用移动构造，在Entity内再写一个新版本的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">		:<span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name))<span class="comment">//(String&amp;&amp;)name</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以移动构造了</p>
<p>Ps：这里有个注意，String&amp;&amp; name意思是声明一个右值引用并绑定左值name，所以说name还是个左值（所有的变量都是左值），所以就在初始化列表中还需要std::move来将其转换为右值。（右值被引用后回延长生存期）</p>
<p>整体来说，移动语义也就是将本来是通过复制来传递的数据通过std::move声明右值(临时对象)后，通过移动构造函数右值引用传递延长右值生存期，进入函数转移所有权后再销毁</p>
<blockquote>
<p>GPT3.5：移动语义是C++11引入的一种机制，它允许将资源的所有权从一个对象转移到另一个对象，而不是进行昂贵的深拷贝。通常情况下，移动语义应用于右值引用（临时对象），通过 <code>std::move</code> 将左值转换为右值引用，从而延长临时对象的生命周期。然后，通过移动构造函数或移动赋值运算符，将资源的所有权从临时对象转移到新对象，以避免不必要的数据复制和资源分配。最后，在临时对象的析构函数中释放资源，确保资源在正确的时间被释放。</p>
<p>因此，移动语义提供了一种更高效的对象传递和资源管理方式，可以提高程序的性能和效率。</p>
</blockquote>
<hr>
<p>＋补充：如果类型不是明确的类型而是推导得出的类型，也就是模板类型这种,右值引用是一个明确的类型，而万能引用涉及到类型推导,万能引用void func(T&amp;&amp; arg)</p>
<blockquote>
<p>详见</p>
</blockquote>
<hr>
<p>剩下的明天搞  !<del>o</del>!</p>
<hr>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p><code>std::move</code> 是一个 C++ 标准库中的函数模板，用于将其参数转换为右值引用。它的主要作用是告诉编译器将一个左值强制转换为右值引用，从而允许移动语义的使用，而不会移动任何的数据。也就相当于是(String&amp;&amp;),是一种cast，但是(String&amp;&amp;)无法识别一些auto类型而std::move可以,</p>
<h2 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h2><p>在之前的内容中实现了移动构造函数，不过移动构造是在创建对象时调用的，如果要对已存在的对象使用移动语义就要使用赋值运算符，也就是在String中添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动赋值运算符</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other)<span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;other)<span class="comment">//检查当前对象是否与传入的右值引用相同。如果当前对象和传入的右值引用不是同一个对象（防止自我赋值），则执行下面的操作。</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]m_Data;<span class="comment">//释放当前对象已有的资源，以确保在移动赋值之前不会发生内存泄漏。</span></span><br><span class="line"></span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = other.m_Data;</span><br><span class="line">		other.m_Size = <span class="number">0</span>;</span><br><span class="line">		other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回当前对象的引用。这样做是为了支持链式赋值操作。</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>重载&#x3D;来实现，返回的是一个String&amp;，同样是右值引用。再main中通过如下代码进行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   String apple = (<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">String dest;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;apple: &quot;</span>;</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;dest: &quot;</span>;</span><br><span class="line">dest.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">dest = std::<span class="built_in">move</span>(apple);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;apple: &quot;</span>;</span><br><span class="line">apple.<span class="built_in">Print</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;dest: &quot;</span>;</span><br><span class="line">dest.<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://cdn.rhahr.icu/938bc8b99569bfc02ed7dd9f168a24f.png"></p>
<p>不过比移动构造来说添加了一些内容：</p>
<p>移动前先检查当前对象是否与传入的右值引用相同。如果当前对象和传入的右值引用不是同一个对象，也就是防止<code>dest=std::move(dest)</code> 这种自我赋值</p>
<p>然后就要先delete[]m_Data,当你在使用移动赋值运算符时，通常是将一个临时对象（右值）的资源转移到当前对象中。这意味着你希望当前对象放弃原有的资源，并接管右值引用的资源。如果你不在赋值之前释放当前对象的资源，那么当前对象持有的资源将被泄漏，因为它将不再被引用，却没有被正确释放</p>
<p>最后再返回当前对象的引用即可</p>
<p>注意：</p>
<p> <code>String dest=std::move(string);</code> 移动构造，</p>
<p> <code>dest = std::move(apple);</code> 移动赋值运算符。</p>
<p>第一次创建对象是用构造函数已经有了对象要对对象赋值则是用赋值运算符可以看作是</p>
<p> <code>dest.operator=(std::move(apple))</code>,”.operator&#x3D;”整体是个函数</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=188550&auto=1&height=66"></iframe>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hah"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hah</p>
  <div class="site-description" itemprop="description">我没有为你伤春悲秋不配有憾事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Jenwein" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jenwein" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rgw127310@gmail.com" title="E-Mail → mailto:rgw127310@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-4 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hah</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">280k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


    </div>
</body>
</html>
