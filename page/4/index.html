<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sword1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sword2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhahr.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:type" content="website">
<meta property="og:title" content="HahのBlog">
<meta property="og:url" content="http://rhahr.top/page/4/index.html">
<meta property="og:site_name" content="HahのBlog">
<meta property="og:description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rhahr.top/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HahのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Jenwein" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HahのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/29/vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/vim/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-29 15:58:28 / 修改时间：18:47:11" itemprop="dateCreated datePublished" datetime="2024-04-29T15:58:28+08:00">2024-04-29</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2>
      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/14/C++-conversionoperator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/C++-conversionoperator/" class="post-title-link" itemprop="url">类型转换运算符</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-14 12:00:00 / 修改时间：14:37:19" itemprop="dateCreated datePublished" datetime="2024-04-14T12:00:00+08:00">2024-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h1><p>类型转换运算符，它允许类对象在特定上下文中被隐式地转换为布尔值。这种语法可以提高代码的可读性和简洁性，适合用于需要检查对象是否有效或满足特定条件的情况下</p>
<p><strong>类型转换运算符</strong>（Type Conversion Operator）允许您自定义类如何转换为其他类型，从而更好地控制隐式类型转换。它是一种特殊成员函数，用于将一个类类型的值转换成其他类型。通过显式定义这样的转换，您可以明确指定在哪些情况下可以进行类型转换，以及如何执行转换。</p>
<p>以下是关于类型转换运算符的一些重要点：</p>
<ol>
<li><strong>显式类型转换</strong>：类型转换运算符允许您显式地将一个类对象转换为特定类型。这是一种用户定义的过程，可以通过两种方式来实现：<ul>
<li><strong>赋值转换</strong>：通过在括号中显式定义所需类型来执行。这也可以被视为强制转换。</li>
<li><strong>类型转换运算符</strong>：允许显式转换为特定类型。</li>
</ul>
</li>
<li><strong>隐式类型转换</strong>：由编译器自动执行，无需用户的外部触发。通常在表达式中存在多个数据类型时发生。隐式类型转换会影响基本数据类型，并允许在数值类型之间进行转换，或者与bool和某些指针进行转换。</li>
<li><strong>类型转换运算符的语法</strong>：<ul>
<li>类型转换运算符是一种特殊的成员函数，其名称以<code>operator</code>关键字开头，后面跟着要转换的目标类型。</li>
<li>它没有返回类型，但在函数体中，您需要将当前类对象转换为目标类型并返回。</li>
</ul>
</li>
</ol>
<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><p>类型转换运算符的语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">target_type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>target_type</code> 是要转换的目标类型，可以是基本数据类型、类类型或枚举类型。<code>const</code> 关键字表明这是一个常量成员函数，它不会修改对象的状态。</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>类型转换运算符允许对象在特定上下文中被隐式地转换为目标类型。这使得代码更加灵活，可以在不同的语境中使用对象。</p>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><ul>
<li><strong>隐式类型转换</strong>：当对象出现在需要目标类型的上下文中时，编译器会自动调用类型转换运算符进行隐式转换。</li>
<li><strong>显式类型转换</strong>：也可以通过显式调用类型转换运算符来进行类型转换，使用类似于函数调用的语法。</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li><strong>避免滥用</strong>：尽管类型转换运算符提供了方便，但过度使用可能导致代码难以理解。应该仅在逻辑上合理且直观的情况下使用。</li>
<li><strong>避免歧义</strong>：类型转换运算符可能会导致代码的歧义性，应该避免与其他重载运算符产生混淆。</li>
<li><strong>注意 const</strong>：类型转换运算符通常声明为 const 成员函数，以确保它不会修改对象的状态。</li>
</ul>
<h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInt</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换运算符将对象转换为 int 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyInt <span class="title">myInt</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 隐式类型转换</span></span><br><span class="line">    <span class="type">int</span> intValue = myInt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式类型转换</span></span><br><span class="line">    <span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(myInt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>MyInt</code> 类定义了一个将对象转换为 <code>int</code> 类型的类型转换运算符 <code>operator int()</code>。在 <code>main()</code> 函数中，我们展示了如何使用隐式和显式类型转换来将 <code>MyInt</code> 对象转换为不同类型的值。</p>
<h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p>在实际情况中，例如我们有一个作用域指针ScopePtr，类似于智能指针，其具体内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> X = <span class="number">0.0f</span>, Y = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ScopedPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">ScopedPtr</span>(T* ptr)</span><br><span class="line">		:<span class="built_in">m_Ptr</span>(ptr)&#123;&#125;</span><br><span class="line">	~<span class="built_in">ScopedPtr</span>()&#123;<span class="keyword">delete</span> m_Ptr;&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function">T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> T* <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* m_Ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们在使用ScopePtr的时候，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScopedPtr&lt;Entity&gt;e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br></pre></td></tr></table></figure>

<p>我们会需要检验e是否是一个有效指针，直接的办法是像下面这样直接检验其指向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entity != <span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (entity) &#123;&#125;;<span class="comment">//C++标准规定，非零指针被视为“真”，而空指针被视为“假”</span></span><br></pre></td></tr></table></figure>

<p>在这里if(entity)有效是因为Entity *它只是一个指向 <code>Entity</code> 对象的裸指针，指针类型（例如 <code>Entity*</code>）可以隐式转换为布尔值。</p>
<p>如果这里是if(e)的话就会报错 “ 表达式必须包含 bool 类型(或可转换为 bool) “ ，也就是说<code>ScopedPtr&lt;Entity&gt;</code> 类型不会隐式转换为布尔值，因为它没有定义与布尔类型之间的间的隐式转换。</p>
<p>如果您想将 <code>ScopedPtr&lt;Entity&gt;</code> 转换为布尔值，您需要显式定义一个类型转换运算符或使用其他方法。</p>
<ol>
<li>其他方法：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsValid</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Ptr != <span class="literal">NULL</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在类中添加该检验方法</p>
<ol start="2">
<li>类型转换运算符</li>
</ol>
<p>在类中定义这个类型转换运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">IsValid</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>这也就是以为着允许ScopePtr类型转换为bool类型，是添加了一种隐式转换的规则，如果你查看unique_ptr的定义就会发现其中也有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">get</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>需要注意的是，这样的语法因为是为了隐式转换，所以会带来语义不清晰的问题，程序重要的可读性大大下降，例如：我们有一个Timer类是用来计算时间的，通过GetSeconds和GetMilliseconds可以得到花费时间的秒&#x2F;毫秒</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> Clock= std::chrono::high_resolution_clock;</span><br><span class="line">	<span class="keyword">using</span> TimePoint = std::chrono::time_point&lt;Clock&gt;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123; m_Start = Clock::<span class="built_in">now</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123; m_Stop = Clock::<span class="built_in">now</span>(); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetSeconds</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;microseconds&gt;(m_Stop - m_Start).<span class="built_in">count</span>() * <span class="number">0.001f</span> * <span class="number">0.001f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetMilliseconds</span> <span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;microseconds&gt;(m_Stop - m_Start).<span class="built_in">count</span>() * <span class="number">0.001f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::chrono::high_resolution_clock::time_point start, end;</span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetSeconds</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TimePoint m_Start,m_Stop;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Timer timer;</span><br><span class="line">	timer.<span class="built_in">Start</span>();</span><br><span class="line">	timer.<span class="built_in">Stop</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="type">double</span> time0 = timer;</span><br><span class="line">	<span class="type">double</span> time1 = timer.<span class="built_in">GetSeconds</span>();</span><br><span class="line">	<span class="type">double</span> time2 = timer.<span class="built_in">GetMilliseconds</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且我们使用了类型转换运算符operator double()const { return GetSeconds(); }，这样的话我们在使用timer的时候可以直接像下面main中的time0一样，直接将Timer类型转换为double类型，虽然看着简洁了，但是我们无法从中获取一些应该的信息，也许我们可以考虑在time0上添加一行注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是秒</span></span><br></pre></td></tr></table></figure>

<p>相比于time1和time2这种直接在实际方法名称即可标注作用的版本来说，很呆，所以不能滥用</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/10/linux-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/linux-process/" class="post-title-link" itemprop="url">linux进程创建</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-10T12:00:00+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:06:09" itemprop="dateModified" datetime="2024-05-19T19:06:09+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h3><p><code>fork</code> 是 Unix 和类 Unix（比如 Linux）操作系统中用来创建新进程的一个系统调用。当一个进程（通常称为父进程）调用 <code>fork</code> 时，它创建了一个新的进程（称为子进程）。子进程几乎是父进程的完整副本：它包含了父进程的数据、代码、堆和栈的复制。</p>
<p>下面详细解释下 <code>fork</code> 的行为和用法：</p>
<ol>
<li><strong>如何工作：</strong><ul>
<li><code>fork</code> 创建一个与当前进程几乎完全相同的新进程。</li>
<li>子进程获得与父进程相同的数据副本（但是它拥有自己的数据空间）。</li>
<li>两个进程（父子）继续从 <code>fork</code> 调用返回的地方独立运行。</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li>父进程中，<code>fork</code> 返回新创建的子进程的进程标识符（PID），如果 <code>fork</code> 调用失败，则返回 -1。</li>
<li>在子进程中，<code>fork</code> 返回 0 表示成功创建。</li>
<li>这种方式允许父进程和子进程检测谁是谁，并决定后续的行动。</li>
</ul>
</li>
<li><strong>后续操作：</strong><ul>
<li>一旦 <code>fork</code> 成功，两个进程就可能做一些完全不同的事情。</li>
<li>子进程常常通过 <code>exec</code> 系列函数替换其进程映像来执行与父进程不同的程序。</li>
<li>父进程可能继续创建更多的子进程，或者等待子进程的完成。</li>
</ul>
</li>
<li><strong>资源共享：</strong><ul>
<li><code>fork</code> 后，父子进程在初期共享相同的物理内存页，这是一种称为写时复制（Copy-On-Write, COW）的优化技术。</li>
<li>如果一个进程尝试修改共享的内存，操作系统会为这个进程创建这个内存页的私有副本，保证不同进程的内存空间是隔离的。</li>
</ul>
</li>
<li><strong>文件描述符：</strong><ul>
<li><strong>子进程会继承父进程的文件描述符。如果父进程打开了文件或网络连接，子进程会共有这些资源的访问。</strong></li>
<li>文件描述符计数会增加，确保除非所有相关进程都关闭了文件描述符，否则资源不会释放。</li>
</ul>
</li>
<li><strong>进程状态：</strong><ul>
<li><strong>子进程会继承父进程的进程状态。这包括信号处理方式、进程优先级以及控制终端等。</strong></li>
</ul>
</li>
<li><strong>用例和限制：</strong><ul>
<li><code>fork</code> 被广泛用于创建后台进程或者守护进程。</li>
<li><code>fork</code> 在创建新进程时有一定资源消耗，尽管有 COW 技术，频繁的 <code>fork</code> 和执行可能会降低系统性能。</li>
</ul>
</li>
</ol>
<p>总结来讲，<code>fork</code> 是 Unix 系统进程创建中最基本和最重要的操作之一。通过 <code>fork</code> 调用，系统能够基于现存的进程创建新进程，这是构建多进程应用的基石。</p>
<h3 id="信号和I-x2F-O的继承"><a href="#信号和I-x2F-O的继承" class="headerlink" title="信号和I&#x2F;O的继承"></a><strong>信号和I&#x2F;O的继承</strong></h3><p>进程的切换及创建主要是由fork和exec族函数实现的，一个是创建出子进程，另一个是用一个新的进程来取代当前进程</p>
<ul>
<li><strong>I&#x2F;O状态</strong>：在<code>exec</code>执行后，所有已经关闭的文件描述符（fd）会保持关闭状态。如果文件描述符在<code>exec</code>执行前没有被关闭，它们默认会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志或者在<code>exec</code>之前显式地关闭它们。</li>
<li><strong>信号处理</strong>：<code>fork</code>创建的子进程会继承父进程的信号处理方式。但是，当<code>exec</code>系列函数执行时，大多数信号的处理方式会被重置为默认值（<code>SIG_DFL</code>），除非信号处理方式被设置为忽略（<code>SIG_IGN</code>），这种情况下会被保留。这是因为新程序可能没有定义原先的信号处理函数，所以继承的信号处理函数地址可能在新程序中没有意义。</li>
<li><strong>信号屏蔽字</strong>：<code>fork</code>之后，子进程会继承父进程的信号屏蔽字，即使在<code>exec</code>之后，这个信号屏蔽字也会被保留。</li>
<li><strong>文件描述符</strong>：默认情况下，所有打开的文件描述符在<code>execv</code>执行后都会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志，或者在<code>execv</code>之前显式地关闭它们。在你的代码中，由于使用了<code>close(i)</code>关闭了所有文件描述符，这些操作会影响到<code>execv</code>执行的新程序，因为新程序将不会继承这些已经关闭的文件描述符。</li>
</ul>
<h3 id="写时拷贝（COW）"><a href="#写时拷贝（COW）" class="headerlink" title="写时拷贝（COW）"></a>写时拷贝（COW）</h3><p>Copy-On-Write（写时复制）是操作系统在进行进程创建和内存管理时用到的一种优化技术。写时复制允许操作系统在必要时才复制内存数据，而不是在每次进程创建时都进行复制，从而提高效率和节省资源。</p>
<p>具体来说，在一个进程执行 <code>fork()</code> 系统调用创建子进程时，操作系统并不立即将父进程的内存数据完全复制一份给子进程。相反，它会让父进程和子进程共享同一片物理内存区域，并<strong>设置这些内存区域为只读</strong>。这时，父子进程实际上是读取同一份数据。</p>
<p>当其中一个进程<strong>尝试修改这些共享的内存数据时</strong>，操作系统会使用写时复制技术进行处理。在修改动作发生的那一刻，操作系统会<strong>创建一个新的内存页面的副本，然后将修改应用于这个副本上，同时更新该进程的内存页表</strong>，确保它指向这个新的、已修改的内存页。其它未被修改的部分仍然保持共享状态。这个过程对于进程本身是透明的，进程不会意识到内存的这种管理方式。</p>
<p>写时复制技术的优点包括：</p>
<ol>
<li><strong>节约内存</strong>：只有在必要的情况下才复制内存页面，因而节约了大量内存资源。</li>
<li><strong>提高效率</strong>：由于初始时不需要复制整个进程空间，<code>fork()</code> 调用可以迅速完成。</li>
<li><strong>优化响应时间</strong>：复制操作是按需进行的，这可以减少进程创建或页面写入时的延迟。</li>
<li><strong>方便内存管理</strong>：当多个进程读取相同的数据时，内存利用率更高。</li>
</ol>
<p>写时复制技术最常见的用途之一就是在 <code>fork()</code> 调用中。它也被虚拟化技术广泛采用，比如在虚拟机和容器技术中，来优化多个虚拟环境共享宿主机资源时的效率和性能。</p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><p>进程映像（Process Image）指的是一个进程在操作系统中所拥有的，与其运行相关的所有资源和信息的集合。这包括但不限于：</p>
<ol>
<li><strong>程序代码</strong>（text segment）：执行的机器语言代码。</li>
<li><strong>数据段</strong>（data segment）：包括全局变量、静态变量等。</li>
<li><strong>堆</strong>（heap）：动态分配的内存，如 C 语言中通过 <code>malloc</code> 分配得到的内存。</li>
<li><strong>栈</strong>（stack）：函数调用时使用的内存，包括局部变量、函数参数、返回地址等。</li>
<li><strong>执行上下文</strong>（context）：包括程序计数器（PC）、寄存器、系统状态字等，这些是CPU执行指令时的当前状态信息。</li>
<li><strong>文件描述符表</strong>：该进程打开的所有文件和网络连接的索引。</li>
<li><strong>环境变量</strong>：例如 PATH、HOME 等。</li>
<li><strong>信号处理方式</strong>：该进程对不同信号设置的处理函数。</li>
<li><strong>控制终端信息</strong>：与进程关联的终端信息。</li>
<li><strong>用户和组ID</strong>：进程运行所在的用户和组权限。</li>
</ol>
<p>进程映像实际上定义了一个进程的运营状态，它能够让操作系统知道如何管理和执行一个进程。当进程通过 <code>fork</code> 被复制时，这个映像也被复制（通过写时复制技术，Copy-On-Write），创建一个新的进程。当执行 <code>exec</code> 类系统调用时，当前进程的程序码和数据段会被新的内容替换，但是其它的部分，如打开的文件描述符等会保留下来。这样的设计允许进程在创造出新的执行流的同时，保持资源使用和环境设置的连续性。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>如果父进程比子进程先退出，子进程将被1号进程（init）托管（这也是一种让程序在后台运行的方法）–孤儿进程。</p>
<h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>僵尸进程（Zombie Process）是指已经结束执行但其进程描述符仍然存在的进程。这种情况发生在子进程已经完成执行并退出，但其父进程尚未通过<code>wait()</code>或<code>waitpid()</code>系统调用来读取子进程的退出状态。在这种情况下，子进程的进程ID和退出状态仍然保存在系统中，以便父进程可以查询。</p>
<p>僵尸进程不占用除了进程表项之外的任何资源，不会消耗CPU时间，也不会占用内存空间。然而，因为每个进程都需要一个唯一的进程ID，如果系统中存在大量的僵尸进程，它们可能会耗尽可用的进程ID，从而阻止新的进程被创建。</p>
<h3 id="僵尸进程的避免："><a href="#僵尸进程的避免：" class="headerlink" title="僵尸进程的避免："></a>僵尸进程的避免：</h3><ol>
<li>子进程退出的时候，内核会向父进程发头SIGCHLD信号，如果父进程用signal(SIGCHLD,SIG_IGN)通知<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8?fromModule=lemma_inlink">内核</a>，表示自己对子进程的退出不感兴趣，那么子进程退出后会立即释放数据结构。</li>
<li>父进程通过wait()&#x2F;waitpid()等函数等待子进程结束，在子进程退出之前，父进程将被阻塞待。</li>
<li>如果父进程很忙，可以捕获SIGCHLD信号，在信号处理函数中调用wait()&#x2F;waitpid()。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="type">int</span> sts;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="comment">//sleep(100);</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="number">0</span>; *p=<span class="number">10</span>;<span class="comment">//会造成内存泄漏</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中：</p>
<ul>
<li><code>fork()</code>函数用于创建一个新的子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程。</li>
<li>父进程执行<code>wait()</code>函数，该函数阻塞父进程直到任一子进程结束。<code>wait()</code>返回结束子进程的PID，并通过<code>sts</code>参数传出子进程的退出状态。</li>
<li><code>WIFEXITED(sts)</code>宏检查子进程是否正常退出。如果是，<code>WEXITSTATUS(sts)</code>宏可以获取子进程的退出代码。</li>
<li><code>WTERMSIG(sts)</code>宏用于获取终止子进程的信号编号，如果子进程是因为信号而非正常退出的话。</li>
<li>子进程中的代码尝试对一个空指针进行写操作，这将导致运行时错误（段错误），并使子进程异常终止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> sig)</span>   <span class="comment">// 子进程退出的信号处理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sts;</span><br><span class="line">  <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD,func);  <span class="comment">// 捕获子进程退出的信号。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;父进程忙着执行任务。\n&quot;</span>;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// int *p=0; *p=10;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>main</code>函数中的<code>fork()</code>调用创建了一个子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程，父进程进入一个无限循环，模拟持续的工作。如果<code>fork()</code>返回0，说明当前是子进程，子进程休眠5秒后退出，并返回状态码1。</p>
<p>父进程通过<code>signal()</code>函数注册了一个信号处理函数<code>func</code>，该函数会在子进程退出时被调用。在<code>func</code>函数中，<code>wait()</code>函数被用来等待子进程结束，并获取其退出状态。根据退出状态，<code>func</code>函数会打印子进程是正常退出还是异常退出，以及相应的退出状态码或终止信号。</p>
<p>这个程序演示了如何在父进程中处理子进程的退出，确保资源得到正确释放，并获取子进程的退出信息</p>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><h4 id="wait函数-1"><a href="#wait函数-1" class="headerlink" title="wait函数"></a>wait函数</h4><p>是一个系统调用，它使父进程暂停执行，直到一个子进程结束或者该进程接收到一个指定的信号为止。如果父进程没有子进程或者它的子进程已经结束，则<code>wait</code>函数会立即返回。</p>
<p><code>wait</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; </span><br></pre></td></tr></table></figure>

<p>这个函数接受一个参数：</p>
<ul>
<li><p>status:</p>
<ul>
<li>这是一个指向整数的指针，用于存储子进程退出时的状态信息。如果你对子进程的退出状态不感兴趣，可以将这个参数设置为<code>NULL</code>。</li>
</ul>
</li>
</ul>
<p><code>wait</code>函数的返回值是：</p>
<ul>
<li>成功时返回子进程的进程ID。</li>
<li>如果调用进程没有子进程，返回-1，并且<code>errno</code>会被设置为<code>ECHILD</code>。</li>
</ul>
<p>当子进程结束时，它会返回一些状态信息，这些信息可以通过<code>status</code>参数获取。为了解析这些状态信息，通常会使用一些宏，例如：</p>
<ul>
<li><code>WIFEXITED(status)</code>：如果子进程正常结束，则返回非零值。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED</code>非零，这个宏可以获取子进程的返回值。</li>
</ul>
<p>这些宏帮助父进程确定子进程是如何结束的，例如，是正常退出还是因为收到了信号而结束。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/549981187"><code>wait</code>函数通常与<code>fork</code>函数一起使用，<code>fork</code>用于创建新的进程，而<code>wait</code>用于回收子进程的资源，防止子进程成为僵尸进程。</a></p>
<h4 id="多个子进程"><a href="#多个子进程" class="headerlink" title="多个子进程"></a>多个子进程</h4><p>当一个父进程使用<code>wait</code>函数等待子进程结束时，如果没有指定特定的子进程ID，<code>wait</code>会等待任何一个子进程结束。一旦有任何一个子进程结束，<code>wait</code>函数就会返回该子进程的PID，并且如果提供了一个非空指针作为参数，它还会返回子进程的退出状态。</p>
<p>如果父进程需要等待特定的子进程，或者想要同时管理多个子进程的结束，它可以使用<code>waitpid</code>函数。<code>waitpid</code>允许父进程指定一个特定的子进程ID来等待，或者通过传递特定的参数来等待任何子进程或某个进程组的子进程。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">例如，如果父进程想要等待任何一个子进程结束，它可以调用<code>waitpid(-1, &amp;status, 0);</code>。如果父进程想要非阻塞地检查子进程的状态，它可以使用<code>WNOHANG</code>选项，如<code>waitpid(-1, &amp;status, WNOHANG);</code>，这样父进程不会被阻塞，即使没有子进程结束</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">1</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mindtechnist/p/17243761.html">2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59008960/article/details/123625060">3</a>。</p>
<p>在处理多个子进程时，通常的做法是在一个循环中调用<code>waitpid</code>，并检查返回值来确定哪个子进程结束了。如果<code>waitpid</code>返回0，表示没有子进程已经结束；如果返回-1，表示出错，通常是因为没有更多的子进程要等待了</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程（Orphan Process）是指那些父进程已经结束或被终止，但子进程仍然在运行的进程。孤儿进程不会被系统立即终止，而是会被init进程（通常是系统中的第一个进程，PID为1）所收养。init进程会负责这些孤儿进程的管理工作，并在它们结束时收集它们的状态信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()!=<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="孤儿进程的特点："><a href="#孤儿进程的特点：" class="headerlink" title="孤儿进程的特点："></a>孤儿进程的特点：</h3><ul>
<li><strong>父进程终止</strong>：当一个进程结束时，它的所有子进程将成为孤儿进程。</li>
<li><strong>被init进程收养</strong>：孤儿进程会被系统的init进程收养，这意味着它们的父进程ID（PPID）将变为1。</li>
<li><strong>资源回收</strong>：当孤儿进程最终结束运行时，init进程会回收它们使用的资源，并清理它们的状态信息。</li>
</ul>
<h3 id="孤儿进程的产生："><a href="#孤儿进程的产生：" class="headerlink" title="孤儿进程的产生："></a>孤儿进程的产生：</h3><p>通常，孤儿进程的产生是由于父进程在执行完毕或因为某些原因被终止，而没有等待（通过<code>wait</code>或<code>waitpid</code>系统调用）子进程结束。</p>
<h3 id="孤儿进程的影响："><a href="#孤儿进程的影响：" class="headerlink" title="孤儿进程的影响："></a>孤儿进程的影响：</h3><p>孤儿进程通常不会对系统造成负面影响，因为它们会被init进程妥善管理。然而，如果有大量的孤儿进程被创建且长时间运行，它们可能会占用不必要的系统资源。</p>
<h3 id="孤儿进程与僵尸进程的区别："><a href="#孤儿进程与僵尸进程的区别：" class="headerlink" title="孤儿进程与僵尸进程的区别："></a>孤儿进程与僵尸进程的区别：</h3><p>孤儿进程与僵尸进程不同。僵尸进程是已经结束但其状态信息尚未被父进程收集的进程。如果父进程没有调用<code>wait</code>或<code>waitpid</code>来收集子进程的状态信息，子进程将成为僵尸进程。相比之下，孤儿进程是那些父进程已经结束，但子进程仍在运行的进程。</p>
<h3 id="孤儿进程的处理："><a href="#孤儿进程的处理：" class="headerlink" title="孤儿进程的处理："></a>孤儿进程的处理：</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/654235321">在大多数情况下，孤儿进程不需要特别处理，因为它们会被init进程自动收养和管理。但是，如果开发者希望避免产生孤儿进程，可以通过编程确保父进程在子进程结束之前一直运行，或者确保父进程适时地调用<code>wait</code>或<code>waitpid</code>来等待子进程结束</a></p>
<h2 id="多进程与信号"><a href="#多进程与信号" class="headerlink" title="多进程与信号"></a>多进程与信号</h2><p>在多进程的服务程序中，如果子进程收到退出信号，子进程自行退出，如果父进程收到退出信号，则应该先向全部的子进程发送退出信号，然后自己再退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略全部的信号，不希望被打扰。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">65</span>;i++) <span class="built_in">signal</span>(i,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置信号,在shell状态下可用 &quot;kill 进程号&quot; 或 &quot;Ctrl+c&quot; 正常终止些进程</span></span><br><span class="line">  <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGTERM,FathEXIT); <span class="built_in">signal</span>(SIGINT,FathEXIT);  <span class="comment">// SIGTERM 15 SIGINT 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) <span class="comment">// 父进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">5</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 子进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 子进程需要重新设置信号。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGTERM,ChldEXIT);   <span class="comment">// 子进程的退出函数与父进程不一样。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGINT ,SIG_IGN);    <span class="comment">// 子进程不需要捕获SIGINT信号。</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在运行中。\n&quot;</span>; <span class="built_in">sleep</span>(<span class="number">3</span>); <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;父进程退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);     <span class="comment">// 向全部的子进程发送15的信号，通知它们退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（全局的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（只释放子进程的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>除了fork，操作系统中还有其他几种创建进程的方式，尤其在Unix-like系统中常见的有：</p>
<ol>
<li>**vfork()**：<ul>
<li><code>vfork()</code> 和 <code>fork()</code> 非常相似，但它不会复制父进程的页表。</li>
<li><code>vfork()</code> 的目的是父进程和子进程共享相同的物理内存。</li>
<li>子进程会在父进程的上下文中运行，直到它调用 <code>exec()</code> 或 <code>exit()</code>。</li>
<li>它的使用不如 <code>fork()</code> 那么广泛，因为如果不正确使用，很容易导致问题。</li>
</ul>
</li>
<li>**clone()**：<ul>
<li><code>clone()</code> 是 Linux 提供的一种更加灵活的创建进程的方式。</li>
<li>它允许调用者指定共享哪些资源，如文件系统、信号处理器、用户命名空间等。</li>
<li><code>clone()</code> 可以用来实现线程，因为线程是共享资源的轻量级进程。</li>
</ul>
</li>
<li><strong>exec() 系列函数</strong>：<ul>
<li><code>exec()</code> 并不是用来直接创建新的进程，而是用于在当前进程中加载一个新的可执行文件，替换当前进程映像。</li>
<li>通常与 <code>fork()</code> 配合使用，子进程会通过 <code>fork()</code> 创建后立即调用 <code>exec()</code> 来运行不同的程序。</li>
</ul>
</li>
<li><strong>posix_spawn() 和 posix_spawnp()</strong>:<ul>
<li>这两个函数是 POSIX 标准提供的用于创建进程的函数。</li>
<li>他们结合了 <code>fork()</code> 和 <code>exec()</code> 的步骤，可能在某些系统上比单独调用这两个步骤更高效。</li>
</ul>
</li>
</ol>
<p>与 <code>fork()</code> 的区别主要在于：</p>
<ul>
<li><strong>资源共享</strong>：<ul>
<li><code>fork()</code> 会复制父进程的页表，子进程会获得父进程数据的一个副本；</li>
<li><code>vfork()</code> 和父进程共享数据部分，直至 <code>exec()</code> 或 <code>exit()</code> 被调用；</li>
<li><code>clone()</code> 可以详细指定共享何种资源，非常灵活。</li>
</ul>
</li>
<li><strong>创建目的</strong>：<ul>
<li><code>fork()</code> 创建的子进程通常会执行不同的任务或者进一步使用 <code>exec()</code> 加载新的程序；</li>
<li><code>vfork()</code> 主要是为了快速创建子进程以执行新程序，强调共享父进程空间；</li>
<li><code>clone()</code> 除了能创建进程外，还经常用来实现线程。</li>
</ul>
</li>
<li><strong>效率和用途</strong>：<ul>
<li><code>posix_spawn()</code> 提供了更高层次的接口，可能在某些系统上提供比 <code>fork()</code> 更高效的操作，它的用途更接近于 <code>fork()</code> 后跟随 <code>exec()</code> 的常见用法。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/10/linux-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/linux-shell/" class="post-title-link" itemprop="url">常见命令</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-10T12:00:00+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 20:07:33" itemprop="dateModified" datetime="2024-06-03T20:07:33+08:00">2024-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/shell/" itemprop="url" rel="index"><span itemprop="name">shell</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>这些命令通常是由Shell程序执行的。Shell是一个命令行解释器，它提供了一个用户界面来执行操作系统的命令</p>
<h3 id="用户与组"><a href="#用户与组" class="headerlink" title="用户与组"></a>用户与组</h3><p><strong>用户管理命令</strong>:</p>
<ul>
<li><p>添加新用户:</p>
<p><code>useradd -m -g users -s /bin/bash 新用户名 </code></p>
<p>这个命令会创建一个新用户，并指定其主目录(<code>-m</code>)，用户组(<code>-g users</code>)和登录Shell(<code>/bin/bash</code>)。</p>
</li>
<li><p>删除用户:</p>
<p><code>userdel -r 用户名 </code></p>
<p>这个命令会删除用户以及用户的主目录(<code>-r</code>表示删除用户时同时删除其主目录)。</p>
</li>
<li><p>修改用户属性:</p>
<p><code>usermod -l 新用户名 -d /home/新目录 -m 旧用户名 </code></p>
<p>这个命令会更改用户的登录名(<code>-l</code>)，移动用户的家目录到新位置(<code>-d</code>和<code>-m</code>选项)。</p>
</li>
<li><p>设置用户密码:</p>
<p><code>passwd 用户名 </code></p>
<p>这个命令会提示你为指定用户设置密码。</p>
</li>
</ul>
<p><strong>用户组管理命令</strong>:</p>
<ul>
<li><p>添加用户组:</p>
<p><code>groupadd 新用户组名 </code></p>
<p>这个命令会创建一个新的用户组。</p>
</li>
<li><p>删除用户组:</p>
<p><code>groupdel 用户组名 </code></p>
<p>这个命令会删除一个用户组。</p>
</li>
<li><p>修改用户组信息:</p>
<p><code>groupmod -n 新用户组名 旧用户组名 </code></p>
<p>这个命令会更改用户组的名字。</p>
</li>
</ul>
<p><strong>查询命令</strong>:</p>
<ul>
<li><p>查询当前登录用户信息:</p>
<p><code>whoami </code></p>
<p>这个命令会显示当前登录的用户名。</p>
</li>
<li><p>查询指定用户信息:</p>
<p><code>id 用户名 </code></p>
<p>这个命令会显示指定用户的UID、GID以及所属的用户组。</p>
</li>
<li><p>查询所有用户信息:</p>
<p><code>cat /etc/passwd </code></p>
<p>这个命令会显示系统中所有用户的信息。</p>
</li>
<li><p>查询所有用户组信息:</p>
<p><code>getent group </code></p>
<p>这个命令会显示系统中所有用户组的信</p>
</li>
<li><p>将一个用户附加到另一个组中<code>-a</code>表示append（追加），<code>-G</code>后面跟着你想要添加用户的组名。</p>
<p><code>usermod -a -G 组名 用户名</code></p>
<p>例如，如果你想将用户<code>john</code>添加到<code>developers</code>组中，你可以使用如下命令：</p>
<p><code>usermod -a -G developers john </code></p>
<p>这个命令不会影响<code>john</code>在其他组中的成员资格。如果你想一次将用户添加到多个组中，可以用逗号分隔组名，如下所示：</p>
<p><code>usermod -a -G group1,group2,group3 john</code></p>
</li>
</ul>
<p><strong>组中删除用户</strong></p>
<p>从组中删除用户有几种方法。以下是两种常用的命令：</p>
<ol>
<li><p><strong>使用gpasswd命令</strong>: 这个命令可以从特定的组中删除用户。使用方法如下：</p>
<p><code>sudo gpasswd -d 用户名 组名 </code></p>
<p>例如，如果你想从<code>developers</code>组中删除用户<code>john</code>，你可以使用：</p>
<p><code>sudo gpasswd -d john developers </code></p>
</li>
<li><p><strong>编辑&#x2F;etc&#x2F;group文件</strong>: 你也可以直接编辑<code>/etc/group</code>文件来手动从组中删除用户。这个方法需要你有足够的权限来编辑系统文件。你可以使用<code>vi</code>、<code>nano</code>或其他文本编辑器来编辑这个文件。例如：</p>
<p><code>sudo vi /etc/group </code></p>
<p>然后找到相应的组，并删除用户旁边的用户名。</p>
</li>
<li><p><strong>使用usermod命令</strong>: 如果你想从所有组中删除用户，只保留其主组，可以使用<code>usermod</code>命令。这个命令会重新设置用户所属的次要组。使用方法如下：</p>
<p><code>sudo usermod -G 主组名 用户名 </code></p>
<p>例如，如果你想让用户<code>john</code>只属于其主组<code>users</code>，可以使用：</p>
<p><code>sudo usermod -G users john</code></p>
</li>
</ol>
<h3 id="目录文件权限"><a href="#目录文件权限" class="headerlink" title="目录文件权限"></a>目录文件权限</h3><p><strong>更改权限 - chmod</strong>:</p>
<ul>
<li><p><code>chmod</code> 命令用于更改文件或目录的权限。权限分为三组：所有者（u）、组（g）和其他用户（o）。</p>
</li>
<li><p>例如，要给所有用户读取权限，可以使用：</p>
<p><code>chmod a+r 文件名 </code></p>
</li>
<li><p>要移除所有用户的执行权限，可以使用：</p>
<p><code>chmod a-x 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的权限，可以使用<code>-R</code>选项：</p>
<p><code>chmod -R a+r 目录名 </code></p>
</li>
<li><p>使用数字表示法设置特定权限，如744（所有者读写执行，组读，其他用户读）：</p>
<p><code>chmod 744 文件名 </code></p>
</li>
</ul>
<p><strong>更改所有者 - chown</strong>:</p>
<ul>
<li><p><code>chown</code> 命令用于更改文件或目录的所有者。</p>
</li>
<li><p>例如，要将文件的所有者更改为新用户，可以使用：</p>
<p><code>chown 新用户 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的所有者，可以使用<code>-R</code>选项：</p>
<p><code>chown -R 新用户 目录名 </code></p>
</li>
</ul>
<p><strong>更改组 - chgrp</strong>:</p>
<ul>
<li><p><code>chgrp</code> 命令用于更改文件或目录的组。</p>
</li>
<li><p>例如，要将文件的组更改为新组，可以使用：</p>
<p><code>chgrp 新组 文件名 </code></p>
</li>
<li><p>要递归地更改目录及其子目录的组，可以使用<code>-R</code>选项：</p>
<p><code>chgrp -R 新组 目录名 </code></p>
</li>
</ul>
<p><strong>查看权限 - ls -l</strong>:</p>
<ul>
<li><p>使用 <code>ls -l</code> 命令可以查看文件或目录的当前权限。</p>
</li>
<li><p>例如，要查看文件的权限，可以使用：</p>
<p><code>ls -l 文件名</code></p>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>查看进程 - ps</strong>:</p>
<p><code>ps</code></p>
<p>命令用于显示当前系统中的活动进程。</p>
<p><code>ps aux </code></p>
<p>这个命令会显示所有进程的详细信息，包括CPU和内存的使用情况。</p>
<p><strong>实时监控进程 - top</strong>:</p>
<p><code>top</code></p>
<p>命令提供一个实时更新的视图，显示系统中进程的状态。</p>
<p><code>top </code></p>
<p>这个命令会显示进程的PID、用户、优先级、CPU使用率、内存使用率等信息。</p>
<p><strong>结束进程 - kill</strong>:</p>
<p><code>kill</code></p>
<p>命令用于发送信号给进程，通常用于结束进程。</p>
<p><code>kill PID </code></p>
<p>这个命令会向指定的进程ID发送一个终止信号。</p>
<p><strong>改变进程优先级 - nice 和 renice</strong>:</p>
<p><code>nice</code></p>
<p>命令用于启动一个进程并设置其优先级。</p>
<p><code>nice -n 10 command </code></p>
<p>这个命令会以优先级10启动指定的命令。</p>
<p><code>renice</code></p>
<p>命令用于改变已经运行的进程的优先级。</p>
<p><code>renice 10 PID </code></p>
<p>这个命令会将指定进程ID的优先级改为10。</p>
<p><strong>在后台运行进程 - bg</strong>:</p>
<p><code>bg</code></p>
<p>命令用于将一个已经停止的进程放到后台运行。</p>
<p><code>bg %jobnumber </code></p>
<p>这个命令会将指定的作业号的进程放到后台。</p>
<p><strong>将进程带到前台 - fg</strong>:</p>
<p><code>fg</code></p>
<p>命令用于将后台进程带到前台。</p>
<p><code>fg %jobnumber </code></p>
<p>这个命令会将指定的作业号的进程带到前台。</p>
<p><strong>查找进程 - pgrep 和 pkill</strong>:</p>
<p><code>pgrep</code></p>
<p>命令用于查找匹配条件的进程ID。</p>
<p><code>pgrep process_name </code></p>
<p>这个命令会列出所有名为</p>
<p><code>process_name</code></p>
<p>的进程的ID。</p>
<p><code>pkill</code></p>
<p>命令用于发送信号给匹配条件的进程，通常用于结束进程。</p>
<p><code>pkill process_name </code></p>
<p>这个命令会结束所有名为</p>
<p><code>process_name</code></p>
<p>的进程。</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/09/linux-signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/linux-signal/" class="post-title-link" itemprop="url">linux信号</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-09T12:00:00+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:12:35" itemprop="dateModified" datetime="2024-05-19T19:12:35+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kill-x2F-killall"><a href="#kill-x2F-killall" class="headerlink" title="kill&#x2F;killall"></a>kill&#x2F;killall</h1><p><code>kill</code> 和 <code>killall</code> 命令都是用于终止进程的工具，但它们的应用场景和方式有所不同：</p>
<ol>
<li><strong>kill 命令</strong>：<ul>
<li><code>kill</code> 命令用于发送信号给指定的进程。</li>
<li>通常，如果没有指定信号，<code>kill</code> 会发送 <code>SIGTERM</code>（信号 15），这是一个请求进程优雅终止的信号。</li>
<li>如果进程没有响应 <code>SIGTERM</code>，可以使用 <code>SIGKILL</code>（信号 9），这是一个强制终止进程的信号，进程无法忽略。</li>
<li>命令格式：<code>kill [信号] 进程ID</code>。例如，<code>kill -9 1234</code> 会强制终止进程 ID 为 1234 的进程。</li>
</ul>
</li>
<li><strong>killall 命令</strong>：<ul>
<li><code>killall</code> 命令用于终止所有与给定名称相匹配的进程。</li>
<li>它不需要进程 ID，而是根据进程名称操作。</li>
<li>如果进程名不完整或不正确，<code>killall</code> 可能会报错或不执行任何操作。</li>
<li>命令格式：<code>killall [信号] 进程名称</code>。例如，<code>killall -9 nginx</code> 会强制终止所有名为 <code>nginx</code> 的进程。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1847239">使用 <code>kill</code> 命令时，你需要知道进程的 ID，而使用 <code>killall</code> 时，你只需要知道进程的名称。<code>kill</code> 命令在你需要精确控制哪个进程被终止时更为合适，而 <code>killall</code> 在你想要快速停止所有同名进程时更加方便。然而，使用 <code>killall</code> 时需要小心，以免误杀其他同名进程</a></p>
<p><code>kill</code> 和 <code>killall</code> 命令在技术上是用来向进程发送信号的。在 Unix-like 系统中，信号是进程间通信的一种方式，可以用来告知进程发生了某个事件。每种信号都有预定义的含义，比如：</p>
<ul>
<li><code>SIGTERM</code>（默认信号，通常是 15）：请求进程优雅地终止。</li>
<li><code>SIGKILL</code>（信号 9）：立即强制终止进程。</li>
</ul>
<p>当我们说“杀死进程”时，通常是指发送 <code>SIGKILL</code> 信号，因为这个信号会导致进程立即停止执行。但是，进程可以捕获和处理其他信号（除了 <code>SIGKILL</code> 和 <code>SIGSTOP</code>），这意味着进程可以决定如何响应大多数信号，包括是否终止。</p>
<p>所以，你可以将 <code>kill</code> 和 <code>killall</code> 看作是向进程发送各种信号的工具，而不仅仅是终止它们。这些命令的灵活性允许系统管理员以多种方式与进程交互，包括但不限于终止进程。</p>
<p>文末会有一些常用信号。</p>
<p>以下代码执行后会一直循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 是一个信号处理函数，当接收到信号时会被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;get signal:&quot;</span>&lt;&lt;signum&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">signal</span>(signum,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func1 是另一个信号处理函数，用于处理 SIGALRM（定时器信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;alarm do \n&quot;</span>;</span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2 是第三个信号处理函数，用于处理 SIGINT（中断信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span> <span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;holt shit,sb&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;really?\n&quot;</span>;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;OK QAQ\n&quot;</span>;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">1</span>,func);<span class="comment">// 为 SIGHUP 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">15</span>,func);<span class="comment">// 为 SIGTERM 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">2</span>,func2); <span class="comment">// 为 SIGINT 信号设置 func2 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">3</span>,SIG_IGN); <span class="comment">// 忽略 SIGQUIT 信号</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>); <span class="comment">// 设置一个 5 秒后的定时器</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">14</span>,func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot; do \n&quot;</span>; <span class="comment">// 主循环中打印消息</span></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>请注意，程序中的 <code>func2</code> 函数包含不雅的语言，这在正式编程实践中是不推荐的。此外，<code>exit(0)</code> 在 <code>func2</code> 中被调用，这将导致程序在接收到 <code>SIGINT</code> 信号时立即退出。而 <code>func1</code> 函数在处理 <code>SIGALRM</code> 信号时重新设置了定时器，这将导致每 5 秒打印一次 “alarm do \n” 并再次设置定时器。<code>func</code> 函数在接收到 <code>SIGHUP</code> 或 <code>SIGTERM</code> 信号后，会将信号的处理方式恢复为默认。最后，<code>SIGQUIT</code> 信号被程序忽略。</p>
<h1 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h1><p>常见的信号及其含义：</p>
<ul>
<li><code>SIGHUP</code> (1): 终端挂断或父进程终止时发送。</li>
<li><code>SIGINT</code> (2): 当用户按下中断键（通常是 Ctrl-C）时发送。</li>
<li><code>SIGQUIT</code> (3): 当用户按下退出键（通常是 Ctrl-\）时发送。</li>
<li><code>SIGILL</code> (4): 非法指令。</li>
<li><code>SIGABRT</code> (6): 由 <code>abort</code> 系统调用产生。</li>
<li><code>SIGFPE</code> (8): 浮点异常。</li>
<li><code>SIGKILL</code> (9): 强制终止进程，不能被捕获或忽略。</li>
<li><code>SIGSEGV</code> (11): 无效的内存引用。</li>
<li><code>SIGPIPE</code> (13): 向一个没有读端的管道写数据时发送。</li>
<li><code>SIGALRM</code> (14): 由 <code>alarm</code> 系统调用产生的定时器信号。</li>
<li><code>SIGTERM</code> (15): 请求终止进程，可以被捕获和处理。</li>
<li><code>SIGUSR1</code> (10) 和 <code>SIGUSR2</code> (12): 用户定义信号。</li>
<li><code>SIGCHLD</code> (17): 子进程停止或终止时发送。</li>
<li><code>SIGCONT</code> (18): 使停止的进程继续执行。</li>
<li><code>SIGSTOP</code> (19): 停止进程的执行，不能被捕获或忽略。</li>
<li><code>SIGTSTP</code> (20): 由用户发送的停止信号（通常是 Ctrl-Z）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61882365">除了这些，还有许多其他信号，如 <code>SIGBUS</code>、<code>SIGPOLL</code>、<code>SIGPROF</code>、<code>SIGSYS</code>、<code>SIGTRAP</code> 等，以及一系列的实时信号 <code>SIGRTMIN</code> 到 <code>SIGRTMAX</code>。实时信号支持排队，不会丢失，而传统信号可能会丢失</a></p>
<h3 id="补"><a href="#补" class="headerlink" title="补"></a>补</h3><p>signal(SIGPIPE, SIG_IGN); 是一个系统调用，用于处理信号。这里的 SIGPIPE 是一个信号，通常在进程向一个已经关闭的管道或者socket写入数据时发出。而 SIG_IGN 是一个宏，表示忽略信号的处理程序。</p>
<p>具体来说，signal(SIGPIPE, SIG_IGN); 的作用是告诉系统忽略 SIGPIPE 信号。如果不忽略这个信号，当进程试图写入一个已经没有读端的管道时，默认行为是终止进程。通过设置 SIG_IGN，进程可以继续运行，不会因为 SIGPIPE 而被意外终止。</p>
<p>这里有一些注意事项：</p>
<p>●   signal 函数是一个较老的接口，现在通常推荐使用 sigaction 函数，因为它提供了更好的控制能力，并且在某些系统上不需要重置处理程序 。</p>
<p>●   除了 SIGKILL 和 SIGSTOP 之外，大多数信号都可以被忽略。SIGKILL 和 SIGSTOP 是两个不能被捕获或忽略的信号。</p>
<p>如果想恢复 SIGPIPE 信号的默认处理行为，可以使用</p>
<p> signal(SIGPIPE, SIG_DFL);，</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-ftp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-ftp/" class="post-title-link" itemprop="url">FTP协议</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 20:23:48" itemprop="dateModified" datetime="2024-06-03T20:23:48+08:00">2024-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/FTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" itemprop="url" rel="index"><span itemprop="name">FTP文件传输</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ftp（File Transfer Protocol文件传输协议）是基于TCP&#x2F;IP 协议的应用层协议，用于文件的传输，包括ftp服务器（或服务端）和ftp客户端。</p>
<p>ftp客户端与服务器创建网络连接，请求登录服务器，登录成功后，就可以进行文件传输，主要包括开载文件和上传文件两种操作。</p>
<p>ftp协议很古老，有人说它技术太落后，不安全，但在内部网络环境中，ftp仍是应用最广泛文件传输协议。</p>
<p>在Linux系统中，ftp客户端和ftp服务器是操作系统自带的，但不一定会缺省安装。</p>
<p>ftp的传输模式有被动模式和主动模式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。</p>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><ol>
<li>关闭SELINUX</li>
</ol>
<p>修改&#x2F;etc&#x2F;selinux&#x2F;config文件，把SELINUX参数的值改为disabled。</p>
<p><code>SELINUX =disabled</code></p>
<p>重启linux系统或执行 setenforce 0 使修改马上生效。</p>
<ol start="2">
<li>配置ftp数据端口参数</li>
</ol>
<p>ftp的数据端口也称为高端口，在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。</p>
<p><code>pasv_min_port=5000   # 高端口范围的最小值。</code></p>
<p><code>pasv_max_port=5500   # 高端口范围的最大值。</code></p>
<ol start="3">
<li>开通防火墙</li>
</ol>
<p>开通防火墙的方法有两种：</p>
<p>1）开通ftp服务。</p>
<p><code>firewall-cmd --zone=public --add-service=ftp --permanent</code></p>
<p>2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。</p>
<p><code>firewall-cmd --zone=public --add-port=21/tcp --permanent</code></p>
<p><code>firewall-cmd --zone=public --add-port=5000-5500/tcp --permanent</code></p>
<p>重启防火墙：</p>
<p><code>systemctl restart firewalld.service</code></p>
<h2 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h2><p>ftp服务器的服务名是vsftpd，相关的操作如下：</p>
<p>systemctl start    vsftpd   # 启动服务。</p>
<p>systemctl stop    vsftpd    # 停止服务。</p>
<p>systemctl restart vsftpd    # 重启服务。</p>
<p>systemctl status  vsftpd    # 查看服务状态。</p>
<p>systemctl enable  vsftpd    # 启用开机自启动vsftpd服务。</p>
<p>systemctl disable vsftpd    # 禁用开机自启动vsftpd服务。</p>
<h2 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h2><p>ftp有两种模式，分别是port模式（主动模式）和pasv模式（被动模式）。</p>
<ol>
<li>主动模式</li>
</ol>
<p>客户端给服务端的21端口发命令说：我要输传文件，我已经打开了自己的20端口，你向我的20端口发起TCP连接，我们来传输文件。服务端收到客户端的请求后，就会主动向客户端的20端口发起连接，连接成功后开始传输文件                                                  </p>
<p>在主动模式下，ftp请求是由客户端TCP连接的；传输数据的时候，TCP连接却是由服务端发起的。</p>
<ol start="2">
<li>被动模式</li>
</ol>
<p>客户端给服务器端的21端口发命令说：我要传输文件。服务器端收到客户端的请求后，打开一个空闲的高端口，然后告诉客户端，我已经打开了某某端口，你向我这个端口发起TCP连接，然后我们用这个端口来传输文件.</p>
<p>在被动模式下，不管是执行ftp命令，还是传输数据，都是由客户端向服务端发起TCP连接的。</p>
<ol start="3">
<li>从主动模式到被动模式</li>
</ol>
<p>在很久以前每台电脑都有一个ip地址，ftp只有主动模式，后来出现了共享上网技术，所以也就有了下面的问题。</p>
<p>共享上网就是多台电脑共享一个公网ip去使用internet，例如某个局域网出口的公网ip是210.33.25.108，当内网用户（192.168.1.100）访问外网的ftp服务器时，如果采用主动模式，192.168.1.100告诉了ftp服务器我需要某个文件和我打开了20端口之后，由于共享上网的原因，192.168.1.100在出网关的时候ip已经被转换成了210.33.25.108，所以ftp服务器端收到的消息是210.33.25.108需要某个文件并打开了20端口，ftp服务器就会尝试连接210.33.25.108的20端口，这样当然不会成功。</p>
<p>在主动模式中，ftp的两个端口是相对固定的，如果命令端口是n的话，那数据端口就是n-1，也就是说默认情况下，命令端口是21，数据端口就是20，如果你把ftp服务的端口改成了521，那么数据端口就是520，这样配置防火墙很方便，只需要开通两个端口就可以了。但是，在共享上网的环境中无法使用主动模式。</p>
<p>在被动模式中，默认情况下命令端口是21，数据端口是随机分配的。但是，被动模式中数据端口的范围可以配置，防火墙也可以配置端口范围。</p>
<h2 id="常用命令及注意"><a href="#常用命令及注意" class="headerlink" title="常用命令及注意"></a>常用命令及注意</h2><ul>
<li>缺省情况下，ftp服务器操作系统用户名&#x2F;密码也是ftp客户端登录的用户名&#x2F;密码。root用户的权限过大，不允许登录ftp服务器。</li>
</ul>
<h3 id="登录服务器："><a href="#登录服务器：" class="headerlink" title="登录服务器："></a>登录服务器：</h3><ol>
<li><p>输入ftp 服务器ip地址，回车后根据提示输入用户名和密</p>
<p><code>ftp 127.0.0.1</code></p>
</li>
<li><p>输入ftp，用open 服务器ip地址，连上服务器后再输入用户名和密码</p>
<p><code>ftp</code>   —&gt;    <code>open 127.0.0.1</code></p>
</li>
<li><p>输入ftp -n 服务器ip地址，再输入user 用户名 密码登录</p>
<p><code>ftp -n 127.0.0.1</code></p>
</li>
</ol>
<h3 id="切换工作目录"><a href="#切换工作目录" class="headerlink" title="切换工作目录"></a>切换工作目录</h3><p>注意，如果目录名中有特殊符号，如空格，可以用双引号把目录名包含起来。</p>
<ol>
<li>查看服务器工作目录</li>
</ol>
<p><code>pwd</code></p>
<ol start="2">
<li>切换服务器工作目录</li>
</ol>
<p><code>cd 目录名</code></p>
<ol start="3">
<li>切换本地工作目录</li>
</ol>
<p><code>lcd 目录名</code></p>
<h3 id="查看服务器上的目录和文件"><a href="#查看服务器上的目录和文件" class="headerlink" title="查看服务器上的目录和文件"></a>查看服务器上的目录和文件</h3><p>1、列出目录或文件名的详细信息</p>
<p><code>ls  目录或文件名</code></p>
<p><code>dir 目录或文件名</code></p>
<p>ls和dir都可以用于查看目录和文件信息，常用ls，语法和Linux的ls命令相同。</p>
<p>​                                                  </p>
<p>2、仅列出目录和文件名</p>
<p>nlist 目录或文件名 [本地文件名]</p>
<p>1）列出&#x2F;freecplus目录下的匹配*.h的文件名信息。</p>
<p>2）列出&#x2F;freecplus目录下的匹配*.h的文件名信息，结果输出到本地的&#x2F;tmp&#x2F;freecplus.list文件中。</p>
<p>查看&#x2F;tmp&#x2F;freecplus.list内容。</p>
<h3 id="下载-x2F-上传文件"><a href="#下载-x2F-上传文件" class="headerlink" title="下载&#x2F;上传文件"></a>下载&#x2F;上传文件</h3><h4 id="文件传输的模式"><a href="#文件传输的模式" class="headerlink" title="文件传输的模式"></a>文件传输的模式</h4><p>ftp传输文件的模式分二进制和ASCII码两种模式，二进制模式可以传输任何文件，包括压缩包. 可执行程序. 图片. 视频. 音频等，而ASCII模式只能传输.txt、.htm等ascii码文件（文本文件）。在实际开发中，不管什么文件，都用二进制方式传输。</p>
<p>1）查看当前的传输模式。</p>
<p><code>type</code></p>
<p>2）设定传输模式为二进制。</p>
<p><code>bin</code></p>
<p>3）设定传输模式为ASCII。</p>
<p><code>ascii</code></p>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><ol>
<li>下载单个文件</li>
</ol>
<p><code>get|recv 服务端文件名 [本地文件名]</code></p>
<p>使用说明：</p>
<p>l  下载文件用get和recv都可以。</p>
<p>l  文件名不允许用“*”. ”?”等通配符。</p>
<p>l  服务端文件名和本地文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p>
<p>l  如果本地文件名省略不写，表示把服务端文件下载到本地的当前工作目录，文件名与服务端文件名相同。</p>
<ol start="2">
<li>下载多个文件</li>
</ol>
<p><code>mget 服务端文件1 服务端文件2 服务端文件3 …… 服务端文件n</code></p>
<p>使用说明：</p>
<p>l  待下载的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p>
<p>l  下载的文件，存放在本地当前工作目录中。</p>
<p>l  下载文件时，会一一提示，如果想关闭提示信息，先输入prompt命令。</p>
<p><code>prompt</code></p>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ol>
<li>上传单个文件</li>
</ol>
<p><code>put|send 本地文件名 [服务端文件名]</code></p>
<p>l  上传文件用put和send都可以。</p>
<p>l  文件名不允许用通配符。</p>
<p>l  本地文件名和服务端文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p>
<p>l  如果服务端文件名省略不写，表示把本地文件上传到服务端的当前工作目录，文件名与本地文件名相同。</p>
<ol start="2">
<li>上传多个文件**</li>
</ol>
<p><code>mput 本地文件1 本地文件2 本地文件3 …… 本地文件n</code></p>
<p>使用说明：</p>
<p>l  待上传的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p>
<p>l  上传的文件，存放在服务端当前工作目录中。</p>
<p>l  上传文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p>
<p><code>prompt</code></p>
<h3 id="其它ftp命令"><a href="#其它ftp命令" class="headerlink" title="其它ftp命令"></a>其它ftp命令</h3><p><strong>1****）重命名ftp服务端的文件</strong></p>
<p><code>rename 旧文件名 新文件名</code></p>
<p><strong>2****）删除ftp服务端上单个文件</strong></p>
<p><code>delete 文件名</code></p>
<p>3）删除ftp服务端的多个文件。</p>
<p><code>mdelete 文件名1 文件名2 文件名3 …… 文件名n</code></p>
<p><strong>4****）在ftp服务端上创建目录。</strong></p>
<p><code>mkdir pathname</code></p>
<p>5）删除ftp服务端上的目录。</p>
<p><code>rmdir pathname</code></p>
<p>6）切换传输模式。</p>
<p><code>passive</code></p>
<p>7）显示帮助信息。</p>
<p><code>help [命令名]</code></p>
<p>显示ftp命令的帮助信息，如果不输入命令名，则显示全ftp命令的帮助信息。</p>
<p>8）退出ftp。</p>
<p><code>bye</code></p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-file/" class="post-title-link" itemprop="url">linux文件操作</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 12:00:00 / 修改时间：20:52:47" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/file/" itemprop="url" rel="index"><span itemprop="name">file</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ol>
<li>目录显示与切换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line"><span class="comment">//文件目录操作</span></span><br><span class="line"><span class="comment">//pwd：显示当前路径</span></span><br><span class="line"><span class="type">char</span> path1[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">getcwd</span>(path1,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path1= &quot;</span>&lt;&lt;path1&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pwd2：显示当前路径</span></span><br><span class="line"><span class="type">char</span> *path2=<span class="built_in">get_current_dir_name</span>();</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path2= &quot;</span>&lt;&lt;path2&lt;&lt;std::endl;</span><br><span class="line"><span class="built_in">free</span>(path2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cd:切换当前工作路径</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path3=<span class="string">&quot;/home/jenwein/dev/zgjcpp&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chdir</span>(path3)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;success to dir: &quot;</span>;</span><br><span class="line"><span class="built_in">getcwd</span>(path,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;path&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mkdir：创建目录文件夹</span></span><br><span class="line"><span class="comment">//arg1-目录名 arg2-访问权限 成功返回0</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>,<span class="number">0755</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;makedir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to makedir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmdir：删除文件夹</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">rmdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;rmdir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to rmdir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>读取文件&#x2F;目录信息</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Using ./t2 &quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DIR *dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dir=<span class="built_in">opendir</span>(argv[<span class="number">1</span>]))==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>* <span class="built_in">stdinfo</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>((stdinfo=<span class="built_in">readdir</span>(dir))==<span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;filename = &quot;</span>&lt;&lt;stdinfo-&gt;d_name&lt;&lt;<span class="string">&quot;, filetype = &quot;</span>&lt;&lt;(<span class="type">int</span>)stdinfo-&gt;d_type&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closedir</span>(dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>错误显示</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于系统调用的函数才会设置errno，其值只有在库函数调用发生错误时才会被设置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> iret=<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/bbb/aaa&quot;</span>,<span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;iret= &quot;</span>&lt;&lt;iret&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;errno&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;<span class="comment">//显示错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示最近一次系统错误的详细信息</span></span><br><span class="line"><span class="comment">//perror(strerror(errno));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;150;i++)</span></span><br><span class="line"><span class="comment">std::cout&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;strerror(i)&lt;&lt;std::endl;//打印所有linux中错误代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>其他操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;std::cout&lt;&lt;<span class="string">&quot;Using ./file (file or dir) (option:newpath)&quot;</span>&lt;&lt;std::endl; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access查看文件权限，主要用于判断文件或目录是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK)!=<span class="number">0</span>)</span><br><span class="line">&#123;std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; not exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件的stat的各属性，名称，权限，修改时间。。。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;<span class="comment">//struct for dir or file ins</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stat</span>(argv[<span class="number">1</span>],&amp;st)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;stat(&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;): &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a file (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a dir (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rename file/dir 重命名文件</span></span><br><span class="line"><span class="keyword">if</span>(argc=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">rename</span>(argv[<span class="number">1</span>],argv[<span class="number">2</span>])==<span class="number">0</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rename success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove file/dir 删除文件</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;want rm the last dir/file?(y/n)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">std::cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">remove</span>(argv[<span class="number">3</span>])==<span class="number">0</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rm success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;file to rm sth\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-socket/" class="post-title-link" itemprop="url">linux网络编程</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:55:59" itemprop="dateModified" datetime="2024-05-19T19:55:59+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>想象一下，客户端和服务端的通信就像是在两个人之间传递秘密信息的过程。</p>
<p><strong>服务端</strong>就像是一个有家的人。首先，他需要建立一个家（<strong>创建套接字</strong>），然后告诉大家他的家在哪里（<strong>绑定IP地址和端口</strong>），打开门等待访客（<strong>监听连接</strong>）。当有人敲门（<strong>客户端发起连接</strong>）时，他会开门（<strong>接受连接</strong>），然后他们可以在屋子里自由地交谈（<strong>数据交换</strong>）。访问结束后，客人离开，他会关门（<strong>关闭套接字</strong>）。</p>
<p><strong>客户端</strong>就像是一个想要拜访朋友的人。他知道朋友的地址（<strong>服务端的IP地址和端口</strong>），所以他出发去朋友家（<strong>创建套接字</strong>），敲门（<strong>发起连接</strong>）。朋友开门后，他们开始聊天（<strong>数据交换</strong>）。聊完后，他告别离开（<strong>关闭套接字</strong>）。</p>
<p>整个过程就像是朋友之间的一次访问，通过敲门、交谈和告别来完成一次愉快的交流。</p>
<p><img src="http://cdn.rhahr.asia/a5a489fb29badb46407c10524c69be5.png"></p>
<hr>
<h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="创建流式socket-—socket"><a href="#创建流式socket-—socket" class="headerlink" title="创建流式socket  —socket()"></a>创建流式socket  —socket()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>( AF_INET , SOCK_STREAM , <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>函数原型:int socket(int domain,int type,int protocol);</p>
<p>参数：</p>
<ul>
<li><p>domain 通讯协议族：通常为Ipv4即PF_INET,</p>
<ul>
<li>PF_INET           IPv4互联网协议族.</li>
<li>PF_INET6            IPv6互联网协议族。</li>
<li>PF_LOCAL          本地通信的协议族。</li>
<li>PF_PACKET        内核底层的协议族。</li>
<li>PF_IPX                IPX Novell协议族。</li>
</ul>
</li>
<li><p>type 数据传输方式：</p>
<ul>
<li>SOCK_STREAM        面向连接的socket：<ul>
<li>1）数据不会丢失；2）数据的顺序不会错乱；3）双向通道。</li>
</ul>
</li>
<li>SOCK_DGRAM        无连接的socket：<ul>
<li>1）数据可能会丢失；2）数据的顺序可能会错乱；3）传输的效率更高。</li>
</ul>
</li>
</ul>
</li>
<li><p>protocol协议：分别与第二个参数对应的协议为IPPROTO_TCP和IPPRPTP_UDP</p>
<p>（或填0自动识别）</p>
</li>
</ul>
<p>成功返回一个有效的socketid，失败返回-1，errno被设置。</p>
<h3 id="向服务器发起连接请求-—connect"><a href="#向服务器发起连接请求-—connect" class="headerlink" title="向服务器发起连接请求 —connect()"></a>向服务器发起连接请求 —connect()</h3><h4 id="准备连接所需IP以及Port"><a href="#准备连接所需IP以及Port" class="headerlink" title="准备连接所需IP以及Port"></a>准备连接所需IP以及Port</h4><h5 id="1-gethostbyname"><a href="#1-gethostbyname" class="headerlink" title="1.gethostbyname"></a>1.gethostbyname</h5><p>获取字符传并转换为网络字节序IP</p>
<blockquote>
<p>根据域名&#x2F;主机名&#x2F;字符串IP获取大端序IP，用于网络通讯的客户端程序中。</p>
<p>struct hostent *gethostbyname(const char *name);</p>
<p>struct hostent { </p>
<p>  char *h_name;        &#x2F;&#x2F; 主机名。</p>
<p>  char **h_aliases;     &#x2F;&#x2F; 主机所有别名构成的字符串数组，同一IP可绑定多个域名。 </p>
<p>  short h_addrtype;     &#x2F;&#x2F; 主机IP地址的类型，例如IPV4（AF_INET）还是IPV6。</p>
<p>  short h_length;      &#x2F;&#x2F; 主机IP地址长度，IPV4地址为4，IPV6地址则为16。</p>
<p>  char **h_addr_list;    &#x2F;&#x2F; 主机的ip地址，以网络字节序存储。 </p>
<p>};</p>
<p>#define h_addr h_addr_list[0]  &#x2F;&#x2F; for backward compatibility.</p>
<p>转换后，用以下代码把大端序的地址复制到sockaddr_in结构体的sin_addr成员中。</p>
<p>memcpy(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</p>
</blockquote>
<h5 id="2-sockaddr与sockaddr-in"><a href="#2-sockaddr与sockaddr-in" class="headerlink" title="2.sockaddr与sockaddr_in"></a>2.sockaddr与sockaddr_in</h5><p>使用sockaddr与sockaddr_in存储IP和Port,一般都需要定义为sockaddr_in在最后连接时再转换为sockaddr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;- 存放协议族、端口和地址信息，客户端和<span class="built_in">connect</span>()函数和服务端的<span class="built_in">bind</span>()函数需要这个结构体。</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="type">unsigned</span> <span class="type">short</span> sa_family;      <span class="comment">// 协议族，与socket()函数的第一个参数相同，填AF_INET。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="type">unsigned</span> <span class="type">char</span> sa_data[<span class="number">14</span>];    <span class="comment">// 14字节的端口和地址。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;</span><br><span class="line">&gt;- sockaddr结构体是为了统一地址结构的表示方法，统一接口函数，但是，操作不方便，所以定义了等价的sockaddr_in结构体，它的大小与sockaddr相同，可以强制转换成sockaddr。</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;  </span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">short</span> sin_family;     <span class="comment">// 协议族，与socket()函数的第一个参数相同，填AF_INET。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">short</span> sin_port;        <span class="comment">// 16位端口号，大端序。用htons(整数的端口)转换。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;          <span class="comment">// IP地址的结构体。192.168.101.138</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];     <span class="comment">// 未使用，为了保持与struct sockaddr一样的长度而添加。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  &#125;;</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;                      <span class="comment">// IP地址的结构体。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">int</span> s_addr;        <span class="comment">// 32位的IP地址，大端序。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-addinfo"><a href="#3-addinfo" class="headerlink" title="3.addinfo"></a>3.addinfo</h5><p>这里有一个函数getaddrinfo，可以直接将之前的两步简化</p>
<p><code>getaddrinfo(m_ip.c_str(), std::to_string(m_port).c_str(), &amp;hints, &amp;res);</code> </p>
<ul>
<li><code>m_ip.c_str()</code>：这是一个指向以 null 结尾的字符串的指针，包含主机名或者 IP 地址。在这个例子中，<code>m_ip</code> 是一个 <code>std::string</code> 对象，它存储了服务器的 IP 地址或主机名。使用 <code>c_str()</code> 方法将 <code>std::string</code> 转换为 C 风格的字符串。</li>
<li><code>std::to_string(m_port).c_str()</code>：这是一个指向以 null 结尾的字符串的指针，包含服务名或端口号。<code>m_port</code> 是一个整数，表示端口号。使用 <code>std::to_string</code> 将整数转换为 <code>std::string</code>，然后使用 <code>c_str()</code> 方法将其转换为 C 风格的字符串。</li>
<li><code>&amp;hints</code>：这是一个指向 <code>addrinfo</code> 结构的指针，该结构提供了关于期望返回的地址类型的提示。在这个结构中，可以设置地址族（如 <code>AF_INET</code>），套接字类型（如 <code>SOCK_STREAM</code>），协议类型（如 <code>IPPROTO_TCP</code>），以及其他可能的选项。</li>
<li><code>&amp;res</code>：这是一个指向 <code>addrinfo</code> 结构指针的指针。函数成功执行后，<code>res</code> 将指向一个 <code>addrinfo</code> 结构链表，其中每个结构包含一个可用于 <code>bind(2)</code> 或 <code>connect(2)</code> 调用的网络地址。</li>
</ul>
<p>这个方法主要做了几件事：</p>
<blockquote>
<p>getaddrinfo </p>
<p>  1.解析：将传入的 IP 地址或主机名（m_ip.c_str()）和服务名或端口号（std::to_string(m_port).c_str()）解析为具体的网络地址<br>  2.填充：根据 hints 结构提供的参数（如协议族、套接字类型、协议类型等），getaddrinfo 会搜索符合条件的网络地址。<br>  3.返回：它会分配一个或多个 addrinfo 结构，并将它们链接成一个链表。每个 addrinfo 结构包含了可以用于创建套接字和建立连接的地址信息。<br>  4.赋值：函数成功后，res 指针会指向这个链表的头部，你可以遍历这个链表，使用其中的信息来创建套接字或进行其他网络操作</p>
</blockquote>
<p><strong>将C风格ip与port字符串以及包含协议族，套接字类型，协议类型的hints这三个参数一起用来解析，完成后分配addrinfo结构体的链表并将表头地址赋给res</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addrinfo 结构体，它包含了以下信息：</span></span><br><span class="line">ai_family	：地址族，如 AF_INET（IPv4）或 AF_INET6（IPv6）。</span><br><span class="line">ai_socktype	：套接字类型，如 SOCK_STREAM（流式套接字）或 SOCK_DGRAM（数据报套接字）。</span><br><span class="line">ai_protocol	：协议类型，如 IPPROTO_TCP（TCP 协议）或 IPPROTO_UDP（UDP 协议）。</span><br><span class="line">ai_addrlen	：地址长度，表示 ai_addr 指向的地址的长度。</span><br><span class="line">ai_addr		：指向一个 sockaddr 结构的指针，该结构包含具体的网络地址。</span><br><span class="line">ai_canonname：如果请求规范名，这是主机的规范名。</span><br><span class="line">ai_next		：指向链表中下一个 addrinfo 结构的指针。</span><br></pre></td></tr></table></figure>

<p>最终看一下两个版本的代码</p>
<p>gehostbynamey获取port+sockaddr保存信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* h; </span><br><span class="line"><span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )</span><br><span class="line">&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span> &lt;&lt; endl; </span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;              		</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));     		</span><br><span class="line">servaddr.sin_family = AF_INET;            	</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));         </span><br></pre></td></tr></table></figure>

<p>addinfo:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints,*res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_INET;          <span class="comment">//ipv4</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;    <span class="comment">//TCP流</span></span><br><span class="line">    hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line">    std::string ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//解析服务器地址和端口</span></span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getaddrinfo</span>(ip.<span class="built_in">c_str</span>(),(std::<span class="built_in">to_string</span>(port)).<span class="built_in">c_str</span>(),&amp;hints,&amp;res);</span><br><span class="line">    <span class="keyword">if</span> (status!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;getaddrinfo error&quot;</span>&lt;&lt;<span class="built_in">gai_strerror</span>(status)&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">-------------------</span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">	m_connfd = <span class="built_in">socket</span>(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">	<span class="comment">//int sockfd = socket(AF_INET,SOCK_STREAM,0);</span></span><br><span class="line">	<span class="keyword">if</span>(m_connfd == INVALID_SOCKET)</span><br><span class="line">	&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	<span class="comment">//连接到服务器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(m_connfd, res-&gt;ai_addr, (<span class="type">int</span>)res-&gt;ai_addrlen) != <span class="number">0</span>)</span><br><span class="line">	&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	<span class="built_in">freeaddrinfo</span>(res);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整洁美观。</p>
<p>实际上addrinfo和sockaddr之间并不是替代关系，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23401147/what-is-the-difference-between-struct-addrinfo-and-struct-sockaddr">在某种意义上，<code>addrinfo</code> 可以看作是 <code>sockaddr</code> 的替代者，因为它提供了更完整的信息集合。但实际上，它们是互补的：<code>addrinfo</code> 用于获取和存储地址信息，而 <code>sockaddr</code> 用于在socket API中表示地址</a></p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>连接：<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：客户端的套接字文件描述符。</li>
<li><code>addr</code>：指向<code>struct sockaddr</code>的指针，包含了目标服务端的地址信息，包括IP地址和端口号。</li>
<li><code>addrlen</code>：<code>addr</code>结构体的大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当客户端调用<code>connect()</code>函数时，它会发起对服务端的连接请求。</li>
<li>这个过程包括TCP协议的三次握手，确保客户端和服务端之间建立稳定的连接。</li>
<li>三次握手成功后，客户端和服务端之间的套接字就可以用于发送和接收数据。</li>
</ul>
<p>使用<code>connect()</code>函数时，客户端通常会阻塞，直到连接建立成功或者发生错误。如果连接成功，客户端就可以通过<code>send()</code>和<code>recv()</code>函数与服务端进行数据交换。</p>
<h3 id="发送-x2F-接收数据-—send-x2F-recv"><a href="#发送-x2F-接收数据-—send-x2F-recv" class="headerlink" title="发送&#x2F;接收数据 —send()&#x2F;recv()"></a>发送&#x2F;接收数据 —send()&#x2F;recv()</h3><h4 id="send-函数"><a href="#send-函数" class="headerlink" title="send() 函数:"></a><strong>send() 函数</strong>:</h4><ul>
<li><p>用于向TCP连接的另一端发送数据。</p>
</li>
<li><p>函数原型：</p>
<p><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags); </code></p>
</li>
<li><p>参数：</p>
<ul>
<li><code>sockfd</code>：连接的套接字文件描述符。</li>
<li><code>buf</code>：指向要发送数据的缓冲区。</li>
<li><code>len</code>：要发送的数据长度。</li>
<li><code>flags</code>：提供额外的信息来控制发送行为，一般设置为0。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时返回实际发送的字节数。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
</ul>
<h4 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv() 函数:"></a><strong>recv() 函数</strong>:</h4><ul>
<li><p>用于接收来自套接字缓冲区的数据。</p>
</li>
<li><p>函数原型：</p>
<p><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags); </code></p>
</li>
<li><p>参数：</p>
<ul>
<li><code>sockfd</code>：连接的套接字文件描述符。</li>
<li><code>buf</code>：指向用于接收数据的缓冲区。</li>
<li><code>len</code>：缓冲区长度。</li>
<li><code>flags</code>：提供额外的信息来控制接收行为，一般设置为0。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时返回实际读到的字节数。</li>
<li>如果在等待协议接收数据时网络中断了，那么它返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
</ul>
<p>在使用<code>send()</code>和<code>recv()</code>函数时，需要注意的是，它们都可能因为网络延迟或其他原因而阻塞。在阻塞模式下，如果发送&#x2F;接收缓冲区不可用，这些函数会等待直到缓冲区变得可用。在非阻塞模式下，如果操作会导致阻塞，这些函数会立即返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>错误。此外，如果<code>send()</code>在发送数据时遇到对端关闭连接的情况，会收到<code>SIGPIPE</code>信号。</p>
<h3 id="关闭连接，释放资源-—close"><a href="#关闭连接，释放资源-—close" class="headerlink" title="关闭连接，释放资源 —close()"></a>关闭连接，释放资源 —close()</h3><p>close(sockfd);</p>
<p>&#x3D;&#x3D;在网络编程中，数据收发的时候有自动转换机制，不需要程序员手动转换，只有向sockaddr_in结体成员变量填充数据时，才需要考虑字节序的问题。&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此程序用于演示socket的客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using:./demo1 服务端的IP 服务端的端口\nExample:./demo1 IP Port\n\n&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">  <span class="comment">// 第1步：创建客户端的socket。  </span></span><br><span class="line">  <span class="comment">//创建了一个ipv4的socket，得到了这个socket的描述符</span></span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd==<span class="number">-1</span>)<span class="comment">//所有网络编程失败返回-1     </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> -----------------</span><br><span class="line">  <span class="comment">// 第2步：向服务器发起连接请求。 </span></span><br><span class="line"> ------</span><br><span class="line">  <span class="comment">//a.获取并保存IP+Prot。发起请求需要从main参数中取得服务器的IP与端口</span></span><br><span class="line"> ---</span><br><span class="line">     <span class="comment">//①.获取IP并转换网络字节序</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;    <span class="comment">// 用于存放服务端IP的结构体。</span></span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )  <span class="comment">// 该函数根据域名/主机名/字符串IP获取大端序IP。</span></span><br><span class="line">  &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="built_in">close</span>(sockfd);<span class="comment">//无法获取则关闭socket并推出程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">---</span><br><span class="line">  <span class="comment">//②.将获取到的IP存入一个socket&quot;专用&quot;结构体(sockaddr/sockaddr_in)</span></span><br><span class="line">  <span class="comment">/*sockaddr结构体是为了统一地址结构的表示方法，统一接口函数，但是，操作不方便，所以定义了等价的sockaddr_in结构体，它的大小与sockaddr相同，可以强制转换成sockaddr。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;              		<span class="comment">// 用于存放服务端IP和端口的结构体。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));     		<span class="comment">//初始化置为全零</span></span><br><span class="line">  servaddr.sin_family = AF_INET;            		<span class="comment">// sin_family设置结构体第一个参数-协议族-Ipv4</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);	 <span class="comment">// sin_addr指定服务端的IP地址。将gethostbyname转换得到的IP存入</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));          <span class="comment">// 指定服务端的通信端口。unsigned short-unit16</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">//b.准备完毕，发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(sockfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">-----------------</span><br><span class="line">  <span class="comment">// 第3步：与服务端通讯，客户发送一个请求报文后等待服务端的回复，收到回复后，再发下一个请求报文。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;ii++)  <span class="comment">// 循环3次，将与服务端进行三次通讯。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iret;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;这是第%d个，编号%03d。&quot;</span>,i+<span class="number">1</span>,i+<span class="number">1</span>);  <span class="comment">// 生成请求报文内容。</span></span><br><span class="line">    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">send</span>(sockfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">// 接收服务端的回应报文，如果服务端没有发送回应报文，recv()函数将阻塞等待。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">recv</span>(sockfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>相似的部分不再复述</p>
<ul>
<li>第二步绑定中（line11）的htonl</li>
</ul>
<blockquote>
<p>为了解决不同字节序的计算机之间传输数据的问题，约定采用网络字节序（大端序）。</p>
<p>C语言提供了四个库函数，用于在主机字节序和网络字节序之间转换：</p>
<p>uint16_t h to n s(uint16_t hostshort);   &#x2F;&#x2F; uint16_t  2字节的整数 unsigned short</p>
<p>uint32_t htonl(uint32_t hostlong);    &#x2F;&#x2F; uint32_t  4字节的整数 unsigned int</p>
<p>uint16_t ntohs(uint16_t netshort);</p>
<p>uint32_t n to h l(uint32_t netlong);</p>
<p>h     host（主机）；</p>
<p>to  转换；</p>
<p>n     network（网络）；</p>
<p>s     short（2字节，16位的整数）；</p>
<p>l      long（4字节，32位的整数）；</p>
</blockquote>
<ul>
<li><p>bind绑定服务端的IP和端口到<code>listenfd</code>这个socket上(为socket分配ip和port)。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p> 参数说明：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，即代表<code>socket()</code>函数创建的套接字文件。</li>
<li><code>addr</code>：指向一个<code>struct sockaddr</code>类型的结构体变量，此结构体成员用于设置要绑定的IP和端口。</li>
<li><code>addrlen</code>：第二个参数所指向的结构体变量的大小。</li>
</ul>
<p> 返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
<li><p>listen设置当前状态为监听</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：指向已经绑定到一个本地地址的套接字的文件描述符。</li>
<li><code>backlog</code>：定义了套接字可以排队等待的挂起连接的最大数量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当调用<code>listen()</code>函数时，内核会为相应的套接字启动一个监听队列，用于存放等待处理的客户端连接请求。这个队列的长度由<code>backlog</code>参数指定。</li>
<li><code>backlog</code>参数告诉系统该套接字在开始拒绝新的连接请求之前，可以排队的未完成连接请求的最大数量。这个值通常由系统管理员根据系统资源和应用程序的需求进行配置。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459374581">在TCP三次握手过程中，当第一次握手（SYN）包到达服务器时，服务器会将这个连接放入一个半连接队列中。如果队列满了，新的连接请求可能会被忽略。<code>backlog</code>参数就是用来设置这个半连接队列的长度的</a></li>
</ul>
</li>
<li><p>accept受理请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：监听套接字的文件描述符，它是之前通过<code>socket()</code>创建并通过<code>bind()</code>和<code>listen()</code>设置为监听状态的套接字。</li>
<li><code>addr</code>：（可选）指向<code>struct sockaddr</code>结构的指针，用于接收连接的客户端的地址信息。</li>
<li><code>addrlen</code>：（可选）指向<code>socklen_t</code>类型的变量的指针，表示<code>addr</code>的长度。在调用前，应该设置为<code>addr</code>结构的大小；调用后，会被设置为实际接收到的地址的大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回一个新的套接字文件描述符，用于与客户端进行通信。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当服务器端的套接字处于监听状态时，<code>accept()</code>函数会检查是否有已完成的连接请求在队列中。</li>
<li>如果有，<code>accept()</code>会创建一个新的套接字，并将其与发起连接的客户端关联起来。这个新的套接字不同于监听套接字，它专门用于与该客户端的通信。</li>
<li>如果<code>addr</code>和<code>addrlen</code>参数不为NULL，<code>accept()</code>还会将客户端的地址信息写入<code>addr</code>所指向的结构，并更新<code>addrlen</code>所指的值为实际地址的长度。</li>
<li>如果在调用<code>accept()</code>时没有已完成的连接请求，那么根据套接字的阻塞状态，<code>accept()</code>可能会阻塞等待，直到有连接请求完成或者发生错误。</li>
</ul>
<p>&#x3D;&#x3D;服务端通过accept利用绑定好的且处于监听状态的监听套接字与客户端的请求匹配，成功后返回一个新的套接字用于回复客户端&#x3D;&#x3D;</p>
<p>回复与发送的内容都在buffer中进行</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此程序用于演示socket通信的服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//第一步相同</span></span><br><span class="line"><span class="comment">// 第1步：创建服务端的socket。 </span></span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (listenfd==<span class="number">-1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">-------------------------------</span><br><span class="line">  <span class="comment">/*第2步：把服务端用于通信的IP和端口绑定到socket上*/</span></span><br><span class="line">  <span class="comment">//a.准备ip与端口</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;          <span class="comment">// 用于存放服务端IP和端口的数据结构。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;                <span class="comment">// 指定协议。与客户端相同</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 服务端任意网卡的IP都可以用于通讯，服务端可以与多个客户端建立连接。</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));     <span class="comment">// 指定通信端口，端口需要与客户端相同</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//b.绑定服务端的IP和端口到listenfd这个socket上(为socket分配ip和port)。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(listenfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第3步：把socket设置为可连接（监听）的状态。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(listenfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第4步：受理客户端的连接请求，如果没有客户端连上来，accept()函数将阻塞等待。</span></span><br><span class="line"><span class="comment">//accept利用监听套接字连接客户端</span></span><br><span class="line">  <span class="type">int</span> clientfd=<span class="built_in">accept</span>(listenfd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (clientfd==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    	<span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>); <span class="function">c</span></span><br><span class="line"><span class="function">        <span class="title">lose</span><span class="params">(listenfd)</span></span>; </span><br><span class="line">     	 <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;客户端已连接。\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iret;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">// 接收客户端的请求报文，如果客户端没有发送请求报文，recv()函数将阻塞等待。</span></span><br><span class="line">    <span class="comment">// 如果客户端已断开连接，recv()函数将返回0。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">recv</span>(clientfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;  <span class="keyword">break</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,<span class="string">&quot;ok&quot;</span>);  <span class="comment">// 生成回应报文内容。</span></span><br><span class="line">    <span class="comment">// 向客户端发送回应报文。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">send</span>(clientfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(listenfd);   <span class="comment">// 关闭服务端用于监听的socket。</span></span><br><span class="line">  <span class="built_in">close</span>(clientfd);   <span class="comment">// 关闭客户端连上来的socket。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-systemerror/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-systemerror/" class="post-title-link" itemprop="url">linux进程调用</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 18:53:09" itemprop="dateModified" datetime="2024-05-19T18:53:09+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>608</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h1><h1 id="errno-1"><a href="#errno-1" class="headerlink" title="errno"></a>errno</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-perror.html"><code>perror()</code> 是 C 语言标准库中的一个函数，定义在 &#96;&#96; 头文件中。它的作用是将最近的一个系统错误代码转换为可读的错误描述，并输出到标准错误流（<code>stderr</code>）。通常，参数 <code>str</code> 是一个自定义的字符串，用于在错误描述前添加额外的信息。如果 <code>str</code> 为 <code>NULL</code>，则 <code>perror()</code> 函数直接打印函数执行出错的消息。这在调试程序时非常有用，因为它提供了一个快速、简洁的方法来通知用户有关程序中特定库函数调用失败的原因</a></p>
<p>在 Linux 中，错误信息通常与 <code>errno</code>（错误号）相关联，它是一个全局变量，用于存储系统调用的最后一个错误代码。每个错误代码都对应一个特定的错误情况。当系统调用失败时，可以通过 <code>errno</code> 获取错误原因，并使用 <code>perror</code> 或 <code>strerror</code> 函数将错误代码转换为人类可读的形式。</p>
<p>以下是一些常见的 <code>errno</code> 错误代码及其含义：</p>
<ul>
<li><code>EPERM (1)</code>: 操作不允许</li>
<li><code>ENOENT (2)</code>: 没有这样的文件或目录</li>
<li><code>ESRCH (3)</code>: 没有这样的过程</li>
<li><code>EINTR (4)</code>: 系统调用被中断</li>
<li><code>EIO (5)</code>: I&#x2F;O 错误</li>
<li><code>ENXIO (6)</code>: 没有这样的设备或地址</li>
<li><code>E2BIG (7)</code>: 参数列表太长</li>
<li><code>ENOEXEC (8)</code>: 执行格式错误</li>
<li><code>EBADF (9)</code>: 坏的文件描述符</li>
<li><code>ECHILD (10)</code>: 没有子进程</li>
<li><code>EAGAIN (11)</code>: 资源暂时不可用</li>
<li><code>ENOMEM (12)</code>: 内存溢出</li>
<li><code>EACCES (13)</code>: 权限被拒绝</li>
<li><code>EFAULT (14)</code>: 错误的地址</li>
<li>……</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-system/" class="post-title-link" itemprop="url">linux进程调用</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-20 19:14:53" itemprop="dateModified" datetime="2024-05-20T19:14:53+08:00">2024-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h1><p>在 Linux 中，<code>system</code> 函数和 <code>execl</code> 函数都是用于执行系统命令的函数，但它们在使用和行为上有一些关键的区别：</p>
<ol>
<li><strong>system 函数</strong>：<ul>
<li><code>system</code> 函数通过创建一个新的子进程来执行指定的命令，然后等待该命令执行完成。</li>
<li>它实际上是调用 <code>/bin/sh -c command</code> 来执行命令，其中 <code>command</code> 是传递给 <code>system</code> 函数的字符串。</li>
<li>在命令执行期间，<code>SIGCHLD</code> 信号会被阻塞，而 <code>SIGINT</code> 和 <code>SIGQUIT</code> 信号会被忽略。</li>
<li><code>system</code> 函数的返回值是命令执行后的状态码。如果命令成功执行，返回值通常是命令的退出状态。如果 <code>system</code> 函数本身失败，则返回 <code>-1</code>。</li>
<li>只有一个参数，即要执行的命令字符串。</li>
<li>函数原型：<code>int system(const char *command);</code></li>
<li>如果 <code>command</code> 是 <code>NULL</code>，则 <code>system</code> 函数会检查 shell 是否可用，如果可用则返回非零值。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">如果 <code>command</code> 不是 <code>NULL</code>，则 <code>system</code> 函数会执行命令，并返回命令的退出状态码。</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/linluan33/article/details/8097916">2</a></li>
</ul>
</li>
<li><strong>execl 函数</strong>：<ul>
<li><code>execl</code> 函数用于在当前进程中执行一个新的程序，它会替换当前进程的映像、数据、堆和栈。</li>
<li>这意味着，一旦 <code>execl</code> 成功执行，当前进程的执行代码将变为新程序的代码，原来的程序将不再存在。</li>
<li><code>execl</code> 函数需要指定新程序的路径和传递给新程序的参数列表，参数列表的最后必须是 <code>NULL</code>。</li>
<li>如果 <code>execl</code> 调用成功，它不会返回；如果调用失败，它会返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误原因。</li>
<li>需要多个参数：第一个是可执行文件的路径，接下来是传递给程序的参数列表，最后必须以 <code>NULL</code> 结尾。</li>
<li>函数原型：<code>int execl(const char *path, const char *arg, ..., (char *)NULL);</code></li>
<li>第一个参数 <code>path</code> 是要执行的程序的路径。</li>
<li>第二个参数 <code>arg</code> 是程序的第一个参数（通常是程序的名称）。</li>
<li>后续参数可以根据需要传递给程序，最后一个参数必须是 <code>NULL</code>，以标识参数列表的结束。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">如果 <code>execl</code> 调用成功，它不会返回；如果调用失败，它会返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误原因。</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53133879/article/details/125092300">3</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/105329417">4</a></li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cccarl/p/6639089.html">简单来说，<code>system</code> 函数适合于需要执行外部命令并等待其完成的情况，而 <code>execl</code> 函数适合于需要替换当前进程为一个全新程序的情况。</a></p>
<p>system创建新的子进程来执行指定的命令，执行完成后返回原进程</p>
<p>execl创建新的进程并替换（取代）当前进程打的数据堆栈等，原程序将不再存在</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/105329417">Linux编程之exec类函数（参数详解+示例）_exec函数 调用带命令行参数的可执行文件 示例-CSDN博客</a></p>
</blockquote>
<h1 id="return和exit"><a href="#return和exit" class="headerlink" title="return和exit"></a>return和exit</h1><p><code>return</code> 和 <code>exit</code> 都用于结束函数执行，但它们的用途和影响范围有所不同：</p>
<ol>
<li><strong>return</strong>：<ul>
<li><code>return</code> 用于从当前函数返回一个值到调用函数。</li>
<li>它只会结束当前函数的执行，并将控制权交回给调用该函数的代码。</li>
<li>如果 <code>return</code> 用在 <code>main</code> 函数中，它会结束整个程序，因为 <code>main</code> 是程序的入口点。</li>
</ul>
</li>
<li><strong>exit</strong>：<ul>
<li><code>exit</code> 是一个标准库函数，定义在 <code>&lt;stdlib.h&gt;</code> 中，用于立即终止程序的执行。</li>
<li>它会关闭所有使用的文件描述符，终止进程，并将控制权交还给操作系统。</li>
<li><code>exit</code> 可以在程序的任何地方调用，不仅限于 <code>main</code> 函数。</li>
<li><code>exit</code> 还会执行一些清理操作，比如调用通过 <code>atexit</code> 注册的函数。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noble/p/4144166.html">总结来说，<code>return</code> 是用于从函数返回，而 <code>exit</code> 是用于立即结束整个程序的执行。如果你在 <code>main</code> 函数中使用 <code>return</code>，它和 <code>exit</code> 有相似的效果，因为它们都会导致程序终止。但在其他函数中，<code>return</code> 只会结束当前函数，而 <code>exit</code> 会结束整个程序。</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noble/p/4144166.html">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lb543210/article/details/81435694">2</a></p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方式可以中止进程，其中5种为正常终止，它们是：</p>
<p>1）在main()函数用return返回；</p>
<p>2）在任意函数中调用exit()函数；</p>
<p>3）在任意函数中调用_exit()或_Exit()函数；</p>
<p>4）最后一个线程从其启动例程（线程主函数）用return返回；</p>
<p>5）在最后一个线程中调用pthread_exit()返回；</p>
<p>异常终止有3种方式，它们是：</p>
<p>6）调用abort()函数中止；</p>
<p>7）接收到一个信号；</p>
<p>8）最后一个线程对取消请求做出响应</p>
<h3 id="一、进程终止的状态"><a href="#一、进程终止的状态" class="headerlink" title="一、进程终止的状态"></a>一、进程终止的状态</h3><p>在main()函数中，return的返回值即终止状态，如果没有return语句或调用exit()，那么该进程的终止状态是0。</p>
<p>在Shell中，查看进程终止的状态：<code>echo $?</code></p>
<p>正常终止进程的3个函数（<code>exit()</code>和<code>_Exit()</code>是由ISO C说明的，<code>_exit()</code>是由POSIX说明的）。</p>
<p><code>void exit(int status);</code></p>
<p><code>void _exit(int status);</code></p>
<p><code>void _Exit(int status);</code></p>
<p>status也是进程终止的状态。</p>
<p>如果进程被异常终止，终止状态为非0。  服务程序的调度、日志和监控</p>
<h3 id="二、资源释放的问题"><a href="#二、资源释放的问题" class="headerlink" title="二、资源释放的问题"></a>二、资源释放的问题</h3><p>return表示函数返回，会调用局部对象的析构函数，main()函数中的return还会调用全局对象的析构函数。</p>
<p>**exit()<strong>表示终止进程，</strong>&#x3D;&#x3D;不会调用局部对象的析构函数，只调用全局对象的析构函数&#x3D;&#x3D;**。</p>
<p><code>exit()</code>会执行清理工作，然后退出，<code>_exit()</code>和<code>_Exit()</code>直接退出，不会执行任何清理工作。</p>
<h3 id="三、进程的终止函数"><a href="#三、进程的终止函数" class="headerlink" title="三、进程的终止函数"></a>三、进程的终止函数</h3><p>进程可以用atexit()函数登记终止函数（最多32个），这些函数将由exit()自动调用。</p>
<p><code>int atexit(void (*function)(void));</code></p>
<p><code>exit()</code>调用终止函数的顺序与登记时相反。 进程退出前的收尾工作</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=188550&auto=1&height=66"></iframe>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hah"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hah</p>
  <div class="site-description" itemprop="description">我没有为你伤春悲秋不配有憾事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Jenwein" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jenwein" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rgw127310@gmail.com" title="E-Mail → mailto:rgw127310@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-4 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hah</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">303k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


    </div>
</body>
</html>
