<!DOCTYPE html>
<html lang="zh-CN">
<head>
<script src="https://lf-cdn.coze.cn/obj/unpkg/flow-platform/chat-app-sdk/1.0.0-beta.4/libs/cn/index.js"></script>

<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/sword1.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/sword2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rhahr.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":"ture","trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:type" content="website">
<meta property="og:title" content="HahのBlog">
<meta property="og:url" content="http://rhahr.top/page/4/index.html">
<meta property="og:site_name" content="HahのBlog">
<meta property="og:description" content="我没有为你伤春悲秋不配有憾事">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hah">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://rhahr.top/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>HahのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/Jenwein" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HahのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/10/linux-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/linux-process/" class="post-title-link" itemprop="url">linux进程创建</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-10T12:00:00+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:06:09" itemprop="dateModified" datetime="2024-05-19T19:06:09+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><h3 id="fork（）"><a href="#fork（）" class="headerlink" title="fork（）"></a>fork（）</h3><p><code>fork</code> 是 Unix 和类 Unix（比如 Linux）操作系统中用来创建新进程的一个系统调用。当一个进程（通常称为父进程）调用 <code>fork</code> 时，它创建了一个新的进程（称为子进程）。子进程几乎是父进程的完整副本：它包含了父进程的数据、代码、堆和栈的复制。</p>
<p>下面详细解释下 <code>fork</code> 的行为和用法：</p>
<ol>
<li><strong>如何工作：</strong><ul>
<li><code>fork</code> 创建一个与当前进程几乎完全相同的新进程。</li>
<li>子进程获得与父进程相同的数据副本（但是它拥有自己的数据空间）。</li>
<li>两个进程（父子）继续从 <code>fork</code> 调用返回的地方独立运行。</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li>父进程中，<code>fork</code> 返回新创建的子进程的进程标识符（PID），如果 <code>fork</code> 调用失败，则返回 -1。</li>
<li>在子进程中，<code>fork</code> 返回 0 表示成功创建。</li>
<li>这种方式允许父进程和子进程检测谁是谁，并决定后续的行动。</li>
</ul>
</li>
<li><strong>后续操作：</strong><ul>
<li>一旦 <code>fork</code> 成功，两个进程就可能做一些完全不同的事情。</li>
<li>子进程常常通过 <code>exec</code> 系列函数替换其进程映像来执行与父进程不同的程序。</li>
<li>父进程可能继续创建更多的子进程，或者等待子进程的完成。</li>
</ul>
</li>
<li><strong>资源共享：</strong><ul>
<li><code>fork</code> 后，父子进程在初期共享相同的物理内存页，这是一种称为写时复制（Copy-On-Write, COW）的优化技术。</li>
<li>如果一个进程尝试修改共享的内存，操作系统会为这个进程创建这个内存页的私有副本，保证不同进程的内存空间是隔离的。</li>
</ul>
</li>
<li><strong>文件描述符：</strong><ul>
<li><strong>子进程会继承父进程的文件描述符。如果父进程打开了文件或网络连接，子进程会共有这些资源的访问。</strong></li>
<li>文件描述符计数会增加，确保除非所有相关进程都关闭了文件描述符，否则资源不会释放。</li>
</ul>
</li>
<li><strong>进程状态：</strong><ul>
<li><strong>子进程会继承父进程的进程状态。这包括信号处理方式、进程优先级以及控制终端等。</strong></li>
</ul>
</li>
<li><strong>用例和限制：</strong><ul>
<li><code>fork</code> 被广泛用于创建后台进程或者守护进程。</li>
<li><code>fork</code> 在创建新进程时有一定资源消耗，尽管有 COW 技术，频繁的 <code>fork</code> 和执行可能会降低系统性能。</li>
</ul>
</li>
</ol>
<p>总结来讲，<code>fork</code> 是 Unix 系统进程创建中最基本和最重要的操作之一。通过 <code>fork</code> 调用，系统能够基于现存的进程创建新进程，这是构建多进程应用的基石。</p>
<h3 id="信号和I-x2F-O的继承"><a href="#信号和I-x2F-O的继承" class="headerlink" title="信号和I&#x2F;O的继承"></a><strong>信号和I&#x2F;O的继承</strong></h3><p>进程的切换及创建主要是由fork和exec族函数实现的，一个是创建出子进程，另一个是用一个新的进程来取代当前进程</p>
<ul>
<li><strong>I&#x2F;O状态</strong>：在<code>exec</code>执行后，所有已经关闭的文件描述符（fd）会保持关闭状态。如果文件描述符在<code>exec</code>执行前没有被关闭，它们默认会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志或者在<code>exec</code>之前显式地关闭它们。</li>
<li><strong>信号处理</strong>：<code>fork</code>创建的子进程会继承父进程的信号处理方式。但是，当<code>exec</code>系列函数执行时，大多数信号的处理方式会被重置为默认值（<code>SIG_DFL</code>），除非信号处理方式被设置为忽略（<code>SIG_IGN</code>），这种情况下会被保留。这是因为新程序可能没有定义原先的信号处理函数，所以继承的信号处理函数地址可能在新程序中没有意义。</li>
<li><strong>信号屏蔽字</strong>：<code>fork</code>之后，子进程会继承父进程的信号屏蔽字，即使在<code>exec</code>之后，这个信号屏蔽字也会被保留。</li>
<li><strong>文件描述符</strong>：默认情况下，所有打开的文件描述符在<code>execv</code>执行后都会保持打开状态，除非在打开文件时指定了<code>O_CLOEXEC</code>标志，或者在<code>execv</code>之前显式地关闭它们。在你的代码中，由于使用了<code>close(i)</code>关闭了所有文件描述符，这些操作会影响到<code>execv</code>执行的新程序，因为新程序将不会继承这些已经关闭的文件描述符。</li>
</ul>
<h3 id="写时拷贝（COW）"><a href="#写时拷贝（COW）" class="headerlink" title="写时拷贝（COW）"></a>写时拷贝（COW）</h3><p>Copy-On-Write（写时复制）是操作系统在进行进程创建和内存管理时用到的一种优化技术。写时复制允许操作系统在必要时才复制内存数据，而不是在每次进程创建时都进行复制，从而提高效率和节省资源。</p>
<p>具体来说，在一个进程执行 <code>fork()</code> 系统调用创建子进程时，操作系统并不立即将父进程的内存数据完全复制一份给子进程。相反，它会让父进程和子进程共享同一片物理内存区域，并<strong>设置这些内存区域为只读</strong>。这时，父子进程实际上是读取同一份数据。</p>
<p>当其中一个进程<strong>尝试修改这些共享的内存数据时</strong>，操作系统会使用写时复制技术进行处理。在修改动作发生的那一刻，操作系统会<strong>创建一个新的内存页面的副本，然后将修改应用于这个副本上，同时更新该进程的内存页表</strong>，确保它指向这个新的、已修改的内存页。其它未被修改的部分仍然保持共享状态。这个过程对于进程本身是透明的，进程不会意识到内存的这种管理方式。</p>
<p>写时复制技术的优点包括：</p>
<ol>
<li><strong>节约内存</strong>：只有在必要的情况下才复制内存页面，因而节约了大量内存资源。</li>
<li><strong>提高效率</strong>：由于初始时不需要复制整个进程空间，<code>fork()</code> 调用可以迅速完成。</li>
<li><strong>优化响应时间</strong>：复制操作是按需进行的，这可以减少进程创建或页面写入时的延迟。</li>
<li><strong>方便内存管理</strong>：当多个进程读取相同的数据时，内存利用率更高。</li>
</ol>
<p>写时复制技术最常见的用途之一就是在 <code>fork()</code> 调用中。它也被虚拟化技术广泛采用，比如在虚拟机和容器技术中，来优化多个虚拟环境共享宿主机资源时的效率和性能。</p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><p>进程映像（Process Image）指的是一个进程在操作系统中所拥有的，与其运行相关的所有资源和信息的集合。这包括但不限于：</p>
<ol>
<li><strong>程序代码</strong>（text segment）：执行的机器语言代码。</li>
<li><strong>数据段</strong>（data segment）：包括全局变量、静态变量等。</li>
<li><strong>堆</strong>（heap）：动态分配的内存，如 C 语言中通过 <code>malloc</code> 分配得到的内存。</li>
<li><strong>栈</strong>（stack）：函数调用时使用的内存，包括局部变量、函数参数、返回地址等。</li>
<li><strong>执行上下文</strong>（context）：包括程序计数器（PC）、寄存器、系统状态字等，这些是CPU执行指令时的当前状态信息。</li>
<li><strong>文件描述符表</strong>：该进程打开的所有文件和网络连接的索引。</li>
<li><strong>环境变量</strong>：例如 PATH、HOME 等。</li>
<li><strong>信号处理方式</strong>：该进程对不同信号设置的处理函数。</li>
<li><strong>控制终端信息</strong>：与进程关联的终端信息。</li>
<li><strong>用户和组ID</strong>：进程运行所在的用户和组权限。</li>
</ol>
<p>进程映像实际上定义了一个进程的运营状态，它能够让操作系统知道如何管理和执行一个进程。当进程通过 <code>fork</code> 被复制时，这个映像也被复制（通过写时复制技术，Copy-On-Write），创建一个新的进程。当执行 <code>exec</code> 类系统调用时，当前进程的程序码和数据段会被新的内容替换，但是其它的部分，如打开的文件描述符等会保留下来。这样的设计允许进程在创造出新的执行流的同时，保持资源使用和环境设置的连续性。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>如果父进程比子进程先退出，子进程将被1号进程（init）托管（这也是一种让程序在后台运行的方法）–孤儿进程。</p>
<h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>僵尸进程（Zombie Process）是指已经结束执行但其进程描述符仍然存在的进程。这种情况发生在子进程已经完成执行并退出，但其父进程尚未通过<code>wait()</code>或<code>waitpid()</code>系统调用来读取子进程的退出状态。在这种情况下，子进程的进程ID和退出状态仍然保存在系统中，以便父进程可以查询。</p>
<p>僵尸进程不占用除了进程表项之外的任何资源，不会消耗CPU时间，也不会占用内存空间。然而，因为每个进程都需要一个唯一的进程ID，如果系统中存在大量的僵尸进程，它们可能会耗尽可用的进程ID，从而阻止新的进程被创建。</p>
<h3 id="僵尸进程的避免："><a href="#僵尸进程的避免：" class="headerlink" title="僵尸进程的避免："></a>僵尸进程的避免：</h3><ol>
<li>子进程退出的时候，内核会向父进程发头SIGCHLD信号，如果父进程用signal(SIGCHLD,SIG_IGN)通知<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8?fromModule=lemma_inlink">内核</a>，表示自己对子进程的退出不感兴趣，那么子进程退出后会立即释放数据结构。</li>
<li>父进程通过wait()&#x2F;waitpid()等函数等待子进程结束，在子进程退出之前，父进程将被阻塞待。</li>
<li>如果父进程很忙，可以捕获SIGCHLD信号，在信号处理函数中调用wait()&#x2F;waitpid()。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="type">int</span> sts;</span><br><span class="line">    <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="comment">//sleep(100);</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="number">0</span>; *p=<span class="number">10</span>;<span class="comment">//会造成内存泄漏</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中：</p>
<ul>
<li><code>fork()</code>函数用于创建一个新的子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程。</li>
<li>父进程执行<code>wait()</code>函数，该函数阻塞父进程直到任一子进程结束。<code>wait()</code>返回结束子进程的PID，并通过<code>sts</code>参数传出子进程的退出状态。</li>
<li><code>WIFEXITED(sts)</code>宏检查子进程是否正常退出。如果是，<code>WEXITSTATUS(sts)</code>宏可以获取子进程的退出代码。</li>
<li><code>WTERMSIG(sts)</code>宏用于获取终止子进程的信号编号，如果子进程是因为信号而非正常退出的话。</li>
<li>子进程中的代码尝试对一个空指针进行写操作，这将导致运行时错误（段错误），并使子进程异常终止。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> sig)</span>   <span class="comment">// 子进程退出的信号处理函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> sts;</span><br><span class="line">  <span class="type">pid_t</span> pid=<span class="built_in">wait</span>(&amp;sts);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;已终止的子进程编号是：&quot;</span> &lt;&lt; pid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(sts)) &#123; cout &lt;&lt; <span class="string">&quot;子进程是正常退出的，退出状态是：&quot;</span> &lt;&lt; <span class="built_in">WEXITSTATUS</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; cout &lt;&lt; <span class="string">&quot;子进程是异常退出的，终止它的信号是：&quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(sts) &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">signal</span>(SIGCHLD,func);  <span class="comment">// 捕获子进程退出的信号。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 父进程的流程。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;父进程忙着执行任务。\n&quot;</span>;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123; <span class="comment">// 子进程的流程。</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// int *p=0; *p=10;</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>main</code>函数中的<code>fork()</code>调用创建了一个子进程。如果<code>fork()</code>返回值大于0，说明当前是父进程，父进程进入一个无限循环，模拟持续的工作。如果<code>fork()</code>返回0，说明当前是子进程，子进程休眠5秒后退出，并返回状态码1。</p>
<p>父进程通过<code>signal()</code>函数注册了一个信号处理函数<code>func</code>，该函数会在子进程退出时被调用。在<code>func</code>函数中，<code>wait()</code>函数被用来等待子进程结束，并获取其退出状态。根据退出状态，<code>func</code>函数会打印子进程是正常退出还是异常退出，以及相应的退出状态码或终止信号。</p>
<p>这个程序演示了如何在父进程中处理子进程的退出，确保资源得到正确释放，并获取子进程的退出信息</p>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><h4 id="wait函数-1"><a href="#wait函数-1" class="headerlink" title="wait函数"></a>wait函数</h4><p>是一个系统调用，它使父进程暂停执行，直到一个子进程结束或者该进程接收到一个指定的信号为止。如果父进程没有子进程或者它的子进程已经结束，则<code>wait</code>函数会立即返回。</p>
<p><code>wait</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>  </span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>; </span><br></pre></td></tr></table></figure>

<p>这个函数接受一个参数：</p>
<ul>
<li><p>status:</p>
<ul>
<li>这是一个指向整数的指针，用于存储子进程退出时的状态信息。如果你对子进程的退出状态不感兴趣，可以将这个参数设置为<code>NULL</code>。</li>
</ul>
</li>
</ul>
<p><code>wait</code>函数的返回值是：</p>
<ul>
<li>成功时返回子进程的进程ID。</li>
<li>如果调用进程没有子进程，返回-1，并且<code>errno</code>会被设置为<code>ECHILD</code>。</li>
</ul>
<p>当子进程结束时，它会返回一些状态信息，这些信息可以通过<code>status</code>参数获取。为了解析这些状态信息，通常会使用一些宏，例如：</p>
<ul>
<li><code>WIFEXITED(status)</code>：如果子进程正常结束，则返回非零值。</li>
<li><code>WEXITSTATUS(status)</code>：如果<code>WIFEXITED</code>非零，这个宏可以获取子进程的返回值。</li>
</ul>
<p>这些宏帮助父进程确定子进程是如何结束的，例如，是正常退出还是因为收到了信号而结束。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/549981187"><code>wait</code>函数通常与<code>fork</code>函数一起使用，<code>fork</code>用于创建新的进程，而<code>wait</code>用于回收子进程的资源，防止子进程成为僵尸进程。</a></p>
<h4 id="多个子进程"><a href="#多个子进程" class="headerlink" title="多个子进程"></a>多个子进程</h4><p>当一个父进程使用<code>wait</code>函数等待子进程结束时，如果没有指定特定的子进程ID，<code>wait</code>会等待任何一个子进程结束。一旦有任何一个子进程结束，<code>wait</code>函数就会返回该子进程的PID，并且如果提供了一个非空指针作为参数，它还会返回子进程的退出状态。</p>
<p>如果父进程需要等待特定的子进程，或者想要同时管理多个子进程的结束，它可以使用<code>waitpid</code>函数。<code>waitpid</code>允许父进程指定一个特定的子进程ID来等待，或者通过传递特定的参数来等待任何子进程或某个进程组的子进程。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">例如，如果父进程想要等待任何一个子进程结束，它可以调用<code>waitpid(-1, &amp;status, 0);</code>。如果父进程想要非阻塞地检查子进程的状态，它可以使用<code>WNOHANG</code>选项，如<code>waitpid(-1, &amp;status, WNOHANG);</code>，这样父进程不会被阻塞，即使没有子进程结束</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/sl1248/article/details/50936823">1</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mindtechnist/p/17243761.html">2</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59008960/article/details/123625060">3</a>。</p>
<p>在处理多个子进程时，通常的做法是在一个循环中调用<code>waitpid</code>，并检查返回值来确定哪个子进程结束了。如果<code>waitpid</code>返回0，表示没有子进程已经结束；如果返回-1，表示出错，通常是因为没有更多的子进程要等待了</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程（Orphan Process）是指那些父进程已经结束或被终止，但子进程仍然在运行的进程。孤儿进程不会被系统立即终止，而是会被init进程（通常是系统中的第一个进程，PID为1）所收养。init进程会负责这些孤儿进程的管理工作，并在它们结束时收集它们的状态信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork()!=<span class="number">0</span>)</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="孤儿进程的特点："><a href="#孤儿进程的特点：" class="headerlink" title="孤儿进程的特点："></a>孤儿进程的特点：</h3><ul>
<li><strong>父进程终止</strong>：当一个进程结束时，它的所有子进程将成为孤儿进程。</li>
<li><strong>被init进程收养</strong>：孤儿进程会被系统的init进程收养，这意味着它们的父进程ID（PPID）将变为1。</li>
<li><strong>资源回收</strong>：当孤儿进程最终结束运行时，init进程会回收它们使用的资源，并清理它们的状态信息。</li>
</ul>
<h3 id="孤儿进程的产生："><a href="#孤儿进程的产生：" class="headerlink" title="孤儿进程的产生："></a>孤儿进程的产生：</h3><p>通常，孤儿进程的产生是由于父进程在执行完毕或因为某些原因被终止，而没有等待（通过<code>wait</code>或<code>waitpid</code>系统调用）子进程结束。</p>
<h3 id="孤儿进程的影响："><a href="#孤儿进程的影响：" class="headerlink" title="孤儿进程的影响："></a>孤儿进程的影响：</h3><p>孤儿进程通常不会对系统造成负面影响，因为它们会被init进程妥善管理。然而，如果有大量的孤儿进程被创建且长时间运行，它们可能会占用不必要的系统资源。</p>
<h3 id="孤儿进程与僵尸进程的区别："><a href="#孤儿进程与僵尸进程的区别：" class="headerlink" title="孤儿进程与僵尸进程的区别："></a>孤儿进程与僵尸进程的区别：</h3><p>孤儿进程与僵尸进程不同。僵尸进程是已经结束但其状态信息尚未被父进程收集的进程。如果父进程没有调用<code>wait</code>或<code>waitpid</code>来收集子进程的状态信息，子进程将成为僵尸进程。相比之下，孤儿进程是那些父进程已经结束，但子进程仍在运行的进程。</p>
<h3 id="孤儿进程的处理："><a href="#孤儿进程的处理：" class="headerlink" title="孤儿进程的处理："></a>孤儿进程的处理：</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/654235321">在大多数情况下，孤儿进程不需要特别处理，因为它们会被init进程自动收养和管理。但是，如果开发者希望避免产生孤儿进程，可以通过编程确保父进程在子进程结束之前一直运行，或者确保父进程适时地调用<code>wait</code>或<code>waitpid</code>来等待子进程结束</a></p>
<h2 id="多进程与信号"><a href="#多进程与信号" class="headerlink" title="多进程与信号"></a>多进程与信号</h2><p>在多进程的服务程序中，如果子进程收到退出信号，子进程自行退出，如果父进程收到退出信号，则应该先向全部的子进程发送退出信号，然后自己再退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span>;  <span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 忽略全部的信号，不希望被打扰。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">65</span>;i++) <span class="built_in">signal</span>(i,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置信号,在shell状态下可用 &quot;kill 进程号&quot; 或 &quot;Ctrl+c&quot; 正常终止些进程</span></span><br><span class="line">  <span class="comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGTERM,FathEXIT); <span class="built_in">signal</span>(SIGINT,FathEXIT);  <span class="comment">// SIGTERM 15 SIGINT 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork()&gt;<span class="number">0</span>) <span class="comment">// 父进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">5</span>); <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>          <span class="comment">// 子进程的流程。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 子进程需要重新设置信号。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGTERM,ChldEXIT);   <span class="comment">// 子进程的退出函数与父进程不一样。</span></span><br><span class="line">      <span class="built_in">signal</span>(SIGINT ,SIG_IGN);    <span class="comment">// 子进程不需要捕获SIGINT信号。</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;正在运行中。\n&quot;</span>; <span class="built_in">sleep</span>(<span class="number">3</span>); <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FathEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;父进程退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">kill</span>(<span class="number">0</span>,SIGTERM);     <span class="comment">// 向全部的子进程发送15的信号，通知它们退出。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（全局的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程的信号处理函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChldEXIT</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span></span><br><span class="line">  <span class="built_in">signal</span>(SIGINT,SIG_IGN); <span class="built_in">signal</span>(SIGTERM,SIG_IGN);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;子进程&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里增加释放资源的代码（只释放子进程的资源）。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>除了fork，操作系统中还有其他几种创建进程的方式，尤其在Unix-like系统中常见的有：</p>
<ol>
<li>**vfork()**：<ul>
<li><code>vfork()</code> 和 <code>fork()</code> 非常相似，但它不会复制父进程的页表。</li>
<li><code>vfork()</code> 的目的是父进程和子进程共享相同的物理内存。</li>
<li>子进程会在父进程的上下文中运行，直到它调用 <code>exec()</code> 或 <code>exit()</code>。</li>
<li>它的使用不如 <code>fork()</code> 那么广泛，因为如果不正确使用，很容易导致问题。</li>
</ul>
</li>
<li>**clone()**：<ul>
<li><code>clone()</code> 是 Linux 提供的一种更加灵活的创建进程的方式。</li>
<li>它允许调用者指定共享哪些资源，如文件系统、信号处理器、用户命名空间等。</li>
<li><code>clone()</code> 可以用来实现线程，因为线程是共享资源的轻量级进程。</li>
</ul>
</li>
<li><strong>exec() 系列函数</strong>：<ul>
<li><code>exec()</code> 并不是用来直接创建新的进程，而是用于在当前进程中加载一个新的可执行文件，替换当前进程映像。</li>
<li>通常与 <code>fork()</code> 配合使用，子进程会通过 <code>fork()</code> 创建后立即调用 <code>exec()</code> 来运行不同的程序。</li>
</ul>
</li>
<li><strong>posix_spawn() 和 posix_spawnp()</strong>:<ul>
<li>这两个函数是 POSIX 标准提供的用于创建进程的函数。</li>
<li>他们结合了 <code>fork()</code> 和 <code>exec()</code> 的步骤，可能在某些系统上比单独调用这两个步骤更高效。</li>
</ul>
</li>
</ol>
<p>与 <code>fork()</code> 的区别主要在于：</p>
<ul>
<li><strong>资源共享</strong>：<ul>
<li><code>fork()</code> 会复制父进程的页表，子进程会获得父进程数据的一个副本；</li>
<li><code>vfork()</code> 和父进程共享数据部分，直至 <code>exec()</code> 或 <code>exit()</code> 被调用；</li>
<li><code>clone()</code> 可以详细指定共享何种资源，非常灵活。</li>
</ul>
</li>
<li><strong>创建目的</strong>：<ul>
<li><code>fork()</code> 创建的子进程通常会执行不同的任务或者进一步使用 <code>exec()</code> 加载新的程序；</li>
<li><code>vfork()</code> 主要是为了快速创建子进程以执行新程序，强调共享父进程空间；</li>
<li><code>clone()</code> 除了能创建进程外，还经常用来实现线程。</li>
</ul>
</li>
<li><strong>效率和用途</strong>：<ul>
<li><code>posix_spawn()</code> 提供了更高层次的接口，可能在某些系统上提供比 <code>fork()</code> 更高效的操作，它的用途更接近于 <code>fork()</code> 后跟随 <code>exec()</code> 的常见用法。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/09/linux-signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/09/linux-signal/" class="post-title-link" itemprop="url">linux信号</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-09 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-09T12:00:00+08:00">2024-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:12:35" itemprop="dateModified" datetime="2024-05-19T19:12:35+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kill-x2F-killall"><a href="#kill-x2F-killall" class="headerlink" title="kill&#x2F;killall"></a>kill&#x2F;killall</h1><p><code>kill</code> 和 <code>killall</code> 命令都是用于终止进程的工具，但它们的应用场景和方式有所不同：</p>
<ol>
<li><strong>kill 命令</strong>：<ul>
<li><code>kill</code> 命令用于发送信号给指定的进程。</li>
<li>通常，如果没有指定信号，<code>kill</code> 会发送 <code>SIGTERM</code>（信号 15），这是一个请求进程优雅终止的信号。</li>
<li>如果进程没有响应 <code>SIGTERM</code>，可以使用 <code>SIGKILL</code>（信号 9），这是一个强制终止进程的信号，进程无法忽略。</li>
<li>命令格式：<code>kill [信号] 进程ID</code>。例如，<code>kill -9 1234</code> 会强制终止进程 ID 为 1234 的进程。</li>
</ul>
</li>
<li><strong>killall 命令</strong>：<ul>
<li><code>killall</code> 命令用于终止所有与给定名称相匹配的进程。</li>
<li>它不需要进程 ID，而是根据进程名称操作。</li>
<li>如果进程名不完整或不正确，<code>killall</code> 可能会报错或不执行任何操作。</li>
<li>命令格式：<code>killall [信号] 进程名称</code>。例如，<code>killall -9 nginx</code> 会强制终止所有名为 <code>nginx</code> 的进程。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1847239">使用 <code>kill</code> 命令时，你需要知道进程的 ID，而使用 <code>killall</code> 时，你只需要知道进程的名称。<code>kill</code> 命令在你需要精确控制哪个进程被终止时更为合适，而 <code>killall</code> 在你想要快速停止所有同名进程时更加方便。然而，使用 <code>killall</code> 时需要小心，以免误杀其他同名进程</a></p>
<p><code>kill</code> 和 <code>killall</code> 命令在技术上是用来向进程发送信号的。在 Unix-like 系统中，信号是进程间通信的一种方式，可以用来告知进程发生了某个事件。每种信号都有预定义的含义，比如：</p>
<ul>
<li><code>SIGTERM</code>（默认信号，通常是 15）：请求进程优雅地终止。</li>
<li><code>SIGKILL</code>（信号 9）：立即强制终止进程。</li>
</ul>
<p>当我们说“杀死进程”时，通常是指发送 <code>SIGKILL</code> 信号，因为这个信号会导致进程立即停止执行。但是，进程可以捕获和处理其他信号（除了 <code>SIGKILL</code> 和 <code>SIGSTOP</code>），这意味着进程可以决定如何响应大多数信号，包括是否终止。</p>
<p>所以，你可以将 <code>kill</code> 和 <code>killall</code> 看作是向进程发送各种信号的工具，而不仅仅是终止它们。这些命令的灵活性允许系统管理员以多种方式与进程交互，包括但不限于终止进程。</p>
<p>文末会有一些常用信号。</p>
<p>以下代码执行后会一直循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 是一个信号处理函数，当接收到信号时会被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;get signal:&quot;</span>&lt;&lt;signum&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">signal</span>(signum,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func1 是另一个信号处理函数，用于处理 SIGALRM（定时器信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;alarm do \n&quot;</span>;</span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func2 是第三个信号处理函数，用于处理 SIGINT（中断信号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span> <span class="params">(<span class="type">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;holt shit,sb&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;really?\n&quot;</span>;</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;OK QAQ\n&quot;</span>;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">1</span>,func);<span class="comment">// 为 SIGHUP 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">15</span>,func);<span class="comment">// 为 SIGTERM 信号设置 func 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">2</span>,func2); <span class="comment">// 为 SIGINT 信号设置 func2 为处理函数</span></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">3</span>,SIG_IGN); <span class="comment">// 忽略 SIGQUIT 信号</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">alarm</span>(<span class="number">5</span>); <span class="comment">// 设置一个 5 秒后的定时器</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">signal</span>(<span class="number">14</span>,func1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot; do \n&quot;</span>; <span class="comment">// 主循环中打印消息</span></span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>请注意，程序中的 <code>func2</code> 函数包含不雅的语言，这在正式编程实践中是不推荐的。此外，<code>exit(0)</code> 在 <code>func2</code> 中被调用，这将导致程序在接收到 <code>SIGINT</code> 信号时立即退出。而 <code>func1</code> 函数在处理 <code>SIGALRM</code> 信号时重新设置了定时器，这将导致每 5 秒打印一次 “alarm do \n” 并再次设置定时器。<code>func</code> 函数在接收到 <code>SIGHUP</code> 或 <code>SIGTERM</code> 信号后，会将信号的处理方式恢复为默认。最后，<code>SIGQUIT</code> 信号被程序忽略。</p>
<h1 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h1><p>常见的信号及其含义：</p>
<ul>
<li><code>SIGHUP</code> (1): 终端挂断或父进程终止时发送。</li>
<li><code>SIGINT</code> (2): 当用户按下中断键（通常是 Ctrl-C）时发送。</li>
<li><code>SIGQUIT</code> (3): 当用户按下退出键（通常是 Ctrl-\）时发送。</li>
<li><code>SIGILL</code> (4): 非法指令。</li>
<li><code>SIGABRT</code> (6): 由 <code>abort</code> 系统调用产生。</li>
<li><code>SIGFPE</code> (8): 浮点异常。</li>
<li><code>SIGKILL</code> (9): 强制终止进程，不能被捕获或忽略。</li>
<li><code>SIGSEGV</code> (11): 无效的内存引用。</li>
<li><code>SIGPIPE</code> (13): 向一个没有读端的管道写数据时发送。</li>
<li><code>SIGALRM</code> (14): 由 <code>alarm</code> 系统调用产生的定时器信号。</li>
<li><code>SIGTERM</code> (15): 请求终止进程，可以被捕获和处理。</li>
<li><code>SIGUSR1</code> (10) 和 <code>SIGUSR2</code> (12): 用户定义信号。</li>
<li><code>SIGCHLD</code> (17): 子进程停止或终止时发送。</li>
<li><code>SIGCONT</code> (18): 使停止的进程继续执行。</li>
<li><code>SIGSTOP</code> (19): 停止进程的执行，不能被捕获或忽略。</li>
<li><code>SIGTSTP</code> (20): 由用户发送的停止信号（通常是 Ctrl-Z）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61882365">除了这些，还有许多其他信号，如 <code>SIGBUS</code>、<code>SIGPOLL</code>、<code>SIGPROF</code>、<code>SIGSYS</code>、<code>SIGTRAP</code> 等，以及一系列的实时信号 <code>SIGRTMIN</code> 到 <code>SIGRTMAX</code>。实时信号支持排队，不会丢失，而传统信号可能会丢失</a></p>
<h3 id="补"><a href="#补" class="headerlink" title="补"></a>补</h3><p>signal(SIGPIPE, SIG_IGN); 是一个系统调用，用于处理信号。这里的 SIGPIPE 是一个信号，通常在进程向一个已经关闭的管道或者socket写入数据时发出。而 SIG_IGN 是一个宏，表示忽略信号的处理程序。</p>
<p>具体来说，signal(SIGPIPE, SIG_IGN); 的作用是告诉系统忽略 SIGPIPE 信号。如果不忽略这个信号，当进程试图写入一个已经没有读端的管道时，默认行为是终止进程。通过设置 SIG_IGN，进程可以继续运行，不会因为 SIGPIPE 而被意外终止。</p>
<p>这里有一些注意事项：</p>
<p>●   signal 函数是一个较老的接口，现在通常推荐使用 sigaction 函数，因为它提供了更好的控制能力，并且在某些系统上不需要重置处理程序 。</p>
<p>●   除了 SIGKILL 和 SIGSTOP 之外，大多数信号都可以被忽略。SIGKILL 和 SIGSTOP 是两个不能被捕获或忽略的信号。</p>
<p>如果想恢复 SIGPIPE 信号的默认处理行为，可以使用</p>
<p> signal(SIGPIPE, SIG_DFL);，</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-file/" class="post-title-link" itemprop="url">linux文件操作</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 12:00:00 / 修改时间：20:52:47" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/file/" itemprop="url" rel="index"><span itemprop="name">file</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ol>
<li>目录显示与切换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line"><span class="comment">//文件目录操作</span></span><br><span class="line"><span class="comment">//pwd：显示当前路径</span></span><br><span class="line"><span class="type">char</span> path1[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">getcwd</span>(path1,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path1= &quot;</span>&lt;&lt;path1&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pwd2：显示当前路径</span></span><br><span class="line"><span class="type">char</span> *path2=<span class="built_in">get_current_dir_name</span>();</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;path2= &quot;</span>&lt;&lt;path2&lt;&lt;std::endl;</span><br><span class="line"><span class="built_in">free</span>(path2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cd:切换当前工作路径</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path3=<span class="string">&quot;/home/jenwein/dev/zgjcpp&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chdir</span>(path3)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;success to dir: &quot;</span>;</span><br><span class="line"><span class="built_in">getcwd</span>(path,<span class="number">256</span>);</span><br><span class="line">std::cout&lt;&lt;path&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mkdir：创建目录文件夹</span></span><br><span class="line"><span class="comment">//arg1-目录名 arg2-访问权限 成功返回0</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>,<span class="number">0755</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;makedir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to makedir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmdir：删除文件夹</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">rmdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/testmkdir&quot;</span>)==<span class="number">0</span>)std::cout&lt;&lt;<span class="string">&quot;rmdir success&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;fail to rmdir&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>读取文件&#x2F;目录信息</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Using ./t2 &quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DIR *dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((dir=<span class="built_in">opendir</span>(argv[<span class="number">1</span>]))==<span class="literal">nullptr</span>)&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>* <span class="built_in">stdinfo</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>((stdinfo=<span class="built_in">readdir</span>(dir))==<span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;filename = &quot;</span>&lt;&lt;stdinfo-&gt;d_name&lt;&lt;<span class="string">&quot;, filetype = &quot;</span>&lt;&lt;(<span class="type">int</span>)stdinfo-&gt;d_type&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closedir</span>(dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>错误显示</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属于系统调用的函数才会设置errno，其值只有在库函数调用发生错误时才会被设置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> iret=<span class="built_in">mkdir</span>(<span class="string">&quot;/home/jenwein/dev/zgjcpp/dirope/bbb/aaa&quot;</span>,<span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;iret= &quot;</span>&lt;&lt;iret&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;errno&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;<span class="comment">//显示错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示最近一次系统错误的详细信息</span></span><br><span class="line"><span class="comment">//perror(strerror(errno));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;150;i++)</span></span><br><span class="line"><span class="comment">std::cout&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;strerror(i)&lt;&lt;std::endl;//打印所有linux中错误代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>其他操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;std::cout&lt;&lt;<span class="string">&quot;Using ./file (file or dir) (option:newpath)&quot;</span>&lt;&lt;std::endl; <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access查看文件权限，主要用于判断文件或目录是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">access</span>(argv[<span class="number">1</span>],F_OK)!=<span class="number">0</span>)</span><br><span class="line">&#123;std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; not exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line"></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;file/dir&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; exist&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件的stat的各属性，名称，权限，修改时间。。。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;<span class="comment">//struct for dir or file ins</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stat</span>(argv[<span class="number">1</span>],&amp;st)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;stat(&quot;</span>&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;): &quot;</span>&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a file (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode))</span><br><span class="line">std::cout&lt;&lt;argv[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; is a dir (&quot;</span>&lt;&lt;<span class="string">&quot;mtime&quot;</span>&lt;&lt;st.st_mtime&lt;&lt;<span class="string">&quot;,size= &quot;</span>&lt;&lt;st.st_size&lt;&lt;<span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rename file/dir 重命名文件</span></span><br><span class="line"><span class="keyword">if</span>(argc=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">rename</span>(argv[<span class="number">1</span>],argv[<span class="number">2</span>])==<span class="number">0</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rename success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove file/dir 删除文件</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;want rm the last dir/file?(y/n)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="type">char</span> s;</span><br><span class="line">std::cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">remove</span>(argv[<span class="number">3</span>])==<span class="number">0</span>);</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;rm success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> std::cout&lt;&lt;<span class="string">&quot;file to rm sth\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-ftp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-ftp/" class="post-title-link" itemprop="url">FTP协议</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 20:23:48" itemprop="dateModified" datetime="2024-06-03T20:23:48+08:00">2024-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/FTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/" itemprop="url" rel="index"><span itemprop="name">FTP文件传输</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ftp（File Transfer Protocol文件传输协议）是基于TCP&#x2F;IP 协议的应用层协议，用于文件的传输，包括ftp服务器（或服务端）和ftp客户端。</p>
<p>ftp客户端与服务器创建网络连接，请求登录服务器，登录成功后，就可以进行文件传输，主要包括开载文件和上传文件两种操作。</p>
<p>ftp协议很古老，有人说它技术太落后，不安全，但在内部网络环境中，ftp仍是应用最广泛文件传输协议。</p>
<p>在Linux系统中，ftp客户端和ftp服务器是操作系统自带的，但不一定会缺省安装。</p>
<p>ftp的传输模式有被动模式和主动模式两种，缺省是被动模式，主动模式的应用场景极少，为了方便表达，在接下来的内容中只介绍被动模式，主动模式在本文中也有介绍。</p>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><ol>
<li>关闭SELINUX</li>
</ol>
<p>修改&#x2F;etc&#x2F;selinux&#x2F;config文件，把SELINUX参数的值改为disabled。</p>
<p><code>SELINUX =disabled</code></p>
<p>重启linux系统或执行 setenforce 0 使修改马上生效。</p>
<ol start="2">
<li>配置ftp数据端口参数</li>
</ol>
<p>ftp的数据端口也称为高端口，在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置，由pasv_min_port和pasv_max_port两个参数指定，如果文件中没有这两个参数，手工的加进去。</p>
<p><code>pasv_min_port=5000   # 高端口范围的最小值。</code></p>
<p><code>pasv_max_port=5500   # 高端口范围的最大值。</code></p>
<ol start="3">
<li>开通防火墙</li>
</ol>
<p>开通防火墙的方法有两种：</p>
<p>1）开通ftp服务。</p>
<p><code>firewall-cmd --zone=public --add-service=ftp --permanent</code></p>
<p>2）开通ftp服务需要的端口，21是控制端口，5000-5500是数据端口范围，也就是上一节中在&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf文件中配置的pasv_min_port和pasv_max_port参数。</p>
<p><code>firewall-cmd --zone=public --add-port=21/tcp --permanent</code></p>
<p><code>firewall-cmd --zone=public --add-port=5000-5500/tcp --permanent</code></p>
<p>重启防火墙：</p>
<p><code>systemctl restart firewalld.service</code></p>
<h2 id="启动vsftpd服务"><a href="#启动vsftpd服务" class="headerlink" title="启动vsftpd服务"></a>启动vsftpd服务</h2><p>ftp服务器的服务名是vsftpd，相关的操作如下：</p>
<p>systemctl start    vsftpd   # 启动服务。</p>
<p>systemctl stop    vsftpd    # 停止服务。</p>
<p>systemctl restart vsftpd    # 重启服务。</p>
<p>systemctl status  vsftpd    # 查看服务状态。</p>
<p>systemctl enable  vsftpd    # 启用开机自启动vsftpd服务。</p>
<p>systemctl disable vsftpd    # 禁用开机自启动vsftpd服务。</p>
<h2 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h2><p>ftp有两种模式，分别是port模式（主动模式）和pasv模式（被动模式）。</p>
<ol>
<li>主动模式</li>
</ol>
<p>客户端给服务端的21端口发命令说：我要输传文件，我已经打开了自己的20端口，你向我的20端口发起TCP连接，我们来传输文件。服务端收到客户端的请求后，就会主动向客户端的20端口发起连接，连接成功后开始传输文件                                                  </p>
<p>在主动模式下，ftp请求是由客户端TCP连接的；传输数据的时候，TCP连接却是由服务端发起的。</p>
<ol start="2">
<li>被动模式</li>
</ol>
<p>客户端给服务器端的21端口发命令说：我要传输文件。服务器端收到客户端的请求后，打开一个空闲的高端口，然后告诉客户端，我已经打开了某某端口，你向我这个端口发起TCP连接，然后我们用这个端口来传输文件.</p>
<p>在被动模式下，不管是执行ftp命令，还是传输数据，都是由客户端向服务端发起TCP连接的。</p>
<ol start="3">
<li>从主动模式到被动模式</li>
</ol>
<p>在很久以前每台电脑都有一个ip地址，ftp只有主动模式，后来出现了共享上网技术，所以也就有了下面的问题。</p>
<p>共享上网就是多台电脑共享一个公网ip去使用internet，例如某个局域网出口的公网ip是210.33.25.108，当内网用户（192.168.1.100）访问外网的ftp服务器时，如果采用主动模式，192.168.1.100告诉了ftp服务器我需要某个文件和我打开了20端口之后，由于共享上网的原因，192.168.1.100在出网关的时候ip已经被转换成了210.33.25.108，所以ftp服务器端收到的消息是210.33.25.108需要某个文件并打开了20端口，ftp服务器就会尝试连接210.33.25.108的20端口，这样当然不会成功。</p>
<p>在主动模式中，ftp的两个端口是相对固定的，如果命令端口是n的话，那数据端口就是n-1，也就是说默认情况下，命令端口是21，数据端口就是20，如果你把ftp服务的端口改成了521，那么数据端口就是520，这样配置防火墙很方便，只需要开通两个端口就可以了。但是，在共享上网的环境中无法使用主动模式。</p>
<p>在被动模式中，默认情况下命令端口是21，数据端口是随机分配的。但是，被动模式中数据端口的范围可以配置，防火墙也可以配置端口范围。</p>
<h2 id="常用命令及注意"><a href="#常用命令及注意" class="headerlink" title="常用命令及注意"></a>常用命令及注意</h2><ul>
<li>缺省情况下，ftp服务器操作系统用户名&#x2F;密码也是ftp客户端登录的用户名&#x2F;密码。root用户的权限过大，不允许登录ftp服务器。</li>
</ul>
<h3 id="登录服务器："><a href="#登录服务器：" class="headerlink" title="登录服务器："></a>登录服务器：</h3><ol>
<li><p>输入ftp 服务器ip地址，回车后根据提示输入用户名和密</p>
<p><code>ftp 127.0.0.1</code></p>
</li>
<li><p>输入ftp，用open 服务器ip地址，连上服务器后再输入用户名和密码</p>
<p><code>ftp</code>   —&gt;    <code>open 127.0.0.1</code></p>
</li>
<li><p>输入ftp -n 服务器ip地址，再输入user 用户名 密码登录</p>
<p><code>ftp -n 127.0.0.1</code></p>
</li>
</ol>
<h3 id="切换工作目录"><a href="#切换工作目录" class="headerlink" title="切换工作目录"></a>切换工作目录</h3><p>注意，如果目录名中有特殊符号，如空格，可以用双引号把目录名包含起来。</p>
<ol>
<li>查看服务器工作目录</li>
</ol>
<p><code>pwd</code></p>
<ol start="2">
<li>切换服务器工作目录</li>
</ol>
<p><code>cd 目录名</code></p>
<ol start="3">
<li>切换本地工作目录</li>
</ol>
<p><code>lcd 目录名</code></p>
<h3 id="查看服务器上的目录和文件"><a href="#查看服务器上的目录和文件" class="headerlink" title="查看服务器上的目录和文件"></a>查看服务器上的目录和文件</h3><p>1、列出目录或文件名的详细信息</p>
<p><code>ls  目录或文件名</code></p>
<p><code>dir 目录或文件名</code></p>
<p>ls和dir都可以用于查看目录和文件信息，常用ls，语法和Linux的ls命令相同。</p>
<p>​                                                  </p>
<p>2、仅列出目录和文件名</p>
<p>nlist 目录或文件名 [本地文件名]</p>
<p>1）列出&#x2F;freecplus目录下的匹配*.h的文件名信息。</p>
<p>2）列出&#x2F;freecplus目录下的匹配*.h的文件名信息，结果输出到本地的&#x2F;tmp&#x2F;freecplus.list文件中。</p>
<p>查看&#x2F;tmp&#x2F;freecplus.list内容。</p>
<h3 id="下载-x2F-上传文件"><a href="#下载-x2F-上传文件" class="headerlink" title="下载&#x2F;上传文件"></a>下载&#x2F;上传文件</h3><h4 id="文件传输的模式"><a href="#文件传输的模式" class="headerlink" title="文件传输的模式"></a>文件传输的模式</h4><p>ftp传输文件的模式分二进制和ASCII码两种模式，二进制模式可以传输任何文件，包括压缩包. 可执行程序. 图片. 视频. 音频等，而ASCII模式只能传输.txt、.htm等ascii码文件（文本文件）。在实际开发中，不管什么文件，都用二进制方式传输。</p>
<p>1）查看当前的传输模式。</p>
<p><code>type</code></p>
<p>2）设定传输模式为二进制。</p>
<p><code>bin</code></p>
<p>3）设定传输模式为ASCII。</p>
<p><code>ascii</code></p>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><ol>
<li>下载单个文件</li>
</ol>
<p><code>get|recv 服务端文件名 [本地文件名]</code></p>
<p>使用说明：</p>
<p>l  下载文件用get和recv都可以。</p>
<p>l  文件名不允许用“*”. ”?”等通配符。</p>
<p>l  服务端文件名和本地文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p>
<p>l  如果本地文件名省略不写，表示把服务端文件下载到本地的当前工作目录，文件名与服务端文件名相同。</p>
<ol start="2">
<li>下载多个文件</li>
</ol>
<p><code>mget 服务端文件1 服务端文件2 服务端文件3 …… 服务端文件n</code></p>
<p>使用说明：</p>
<p>l  待下载的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p>
<p>l  下载的文件，存放在本地当前工作目录中。</p>
<p>l  下载文件时，会一一提示，如果想关闭提示信息，先输入prompt命令。</p>
<p><code>prompt</code></p>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><ol>
<li>上传单个文件</li>
</ol>
<p><code>put|send 本地文件名 [服务端文件名]</code></p>
<p>l  上传文件用put和send都可以。</p>
<p>l  文件名不允许用通配符。</p>
<p>l  本地文件名和服务端文件名可以用绝对路径，如果不写路径，表示当前工作目录。</p>
<p>l  如果服务端文件名省略不写，表示把本地文件上传到服务端的当前工作目录，文件名与本地文件名相同。</p>
<ol start="2">
<li>上传多个文件**</li>
</ol>
<p><code>mput 本地文件1 本地文件2 本地文件3 …… 本地文件n</code></p>
<p>使用说明：</p>
<p>l  待上传的文件名，可以一一列出来（用空格分隔），也可以用通配符。</p>
<p>l  上传的文件，存放在服务端当前工作目录中。</p>
<p>l  上传文件时，会一一提示，如果想关闭都显示信息，先输入prompt命令。</p>
<p><code>prompt</code></p>
<h3 id="其它ftp命令"><a href="#其它ftp命令" class="headerlink" title="其它ftp命令"></a>其它ftp命令</h3><p><strong>1****）重命名ftp服务端的文件</strong></p>
<p><code>rename 旧文件名 新文件名</code></p>
<p><strong>2****）删除ftp服务端上单个文件</strong></p>
<p><code>delete 文件名</code></p>
<p>3）删除ftp服务端的多个文件。</p>
<p><code>mdelete 文件名1 文件名2 文件名3 …… 文件名n</code></p>
<p><strong>4****）在ftp服务端上创建目录。</strong></p>
<p><code>mkdir pathname</code></p>
<p>5）删除ftp服务端上的目录。</p>
<p><code>rmdir pathname</code></p>
<p>6）切换传输模式。</p>
<p><code>passive</code></p>
<p>7）显示帮助信息。</p>
<p><code>help [命令名]</code></p>
<p>显示ftp命令的帮助信息，如果不输入命令名，则显示全ftp命令的帮助信息。</p>
<p>8）退出ftp。</p>
<p><code>bye</code></p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-systemerror/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-systemerror/" class="post-title-link" itemprop="url">linux进程调用</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 18:53:09" itemprop="dateModified" datetime="2024-05-19T18:53:09+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>608</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h1><h1 id="errno-1"><a href="#errno-1" class="headerlink" title="errno"></a>errno</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-perror.html"><code>perror()</code> 是 C 语言标准库中的一个函数，定义在 &#96;&#96; 头文件中。它的作用是将最近的一个系统错误代码转换为可读的错误描述，并输出到标准错误流（<code>stderr</code>）。通常，参数 <code>str</code> 是一个自定义的字符串，用于在错误描述前添加额外的信息。如果 <code>str</code> 为 <code>NULL</code>，则 <code>perror()</code> 函数直接打印函数执行出错的消息。这在调试程序时非常有用，因为它提供了一个快速、简洁的方法来通知用户有关程序中特定库函数调用失败的原因</a></p>
<p>在 Linux 中，错误信息通常与 <code>errno</code>（错误号）相关联，它是一个全局变量，用于存储系统调用的最后一个错误代码。每个错误代码都对应一个特定的错误情况。当系统调用失败时，可以通过 <code>errno</code> 获取错误原因，并使用 <code>perror</code> 或 <code>strerror</code> 函数将错误代码转换为人类可读的形式。</p>
<p>以下是一些常见的 <code>errno</code> 错误代码及其含义：</p>
<ul>
<li><code>EPERM (1)</code>: 操作不允许</li>
<li><code>ENOENT (2)</code>: 没有这样的文件或目录</li>
<li><code>ESRCH (3)</code>: 没有这样的过程</li>
<li><code>EINTR (4)</code>: 系统调用被中断</li>
<li><code>EIO (5)</code>: I&#x2F;O 错误</li>
<li><code>ENXIO (6)</code>: 没有这样的设备或地址</li>
<li><code>E2BIG (7)</code>: 参数列表太长</li>
<li><code>ENOEXEC (8)</code>: 执行格式错误</li>
<li><code>EBADF (9)</code>: 坏的文件描述符</li>
<li><code>ECHILD (10)</code>: 没有子进程</li>
<li><code>EAGAIN (11)</code>: 资源暂时不可用</li>
<li><code>ENOMEM (12)</code>: 内存溢出</li>
<li><code>EACCES (13)</code>: 权限被拒绝</li>
<li><code>EFAULT (14)</code>: 错误的地址</li>
<li>……</li>
</ul>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-socket/" class="post-title-link" itemprop="url">linux网络编程</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 19:55:59" itemprop="dateModified" datetime="2024-05-19T19:55:59+08:00">2024-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>想象一下，客户端和服务端的通信就像是在两个人之间传递秘密信息的过程。</p>
<p><strong>服务端</strong>就像是一个有家的人。首先，他需要建立一个家（<strong>创建套接字</strong>），然后告诉大家他的家在哪里（<strong>绑定IP地址和端口</strong>），打开门等待访客（<strong>监听连接</strong>）。当有人敲门（<strong>客户端发起连接</strong>）时，他会开门（<strong>接受连接</strong>），然后他们可以在屋子里自由地交谈（<strong>数据交换</strong>）。访问结束后，客人离开，他会关门（<strong>关闭套接字</strong>）。</p>
<p><strong>客户端</strong>就像是一个想要拜访朋友的人。他知道朋友的地址（<strong>服务端的IP地址和端口</strong>），所以他出发去朋友家（<strong>创建套接字</strong>），敲门（<strong>发起连接</strong>）。朋友开门后，他们开始聊天（<strong>数据交换</strong>）。聊完后，他告别离开（<strong>关闭套接字</strong>）。</p>
<p>整个过程就像是朋友之间的一次访问，通过敲门、交谈和告别来完成一次愉快的交流。</p>
<p><img src="http://cdn.rhahr.asia/a5a489fb29badb46407c10524c69be5.png"></p>
<hr>
<h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><h3 id="创建流式socket-—socket"><a href="#创建流式socket-—socket" class="headerlink" title="创建流式socket  —socket()"></a>创建流式socket  —socket()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>( AF_INET , SOCK_STREAM , <span class="number">0</span> );</span><br></pre></td></tr></table></figure>

<p>函数原型:int socket(int domain,int type,int protocol);</p>
<p>参数：</p>
<ul>
<li><p>domain 通讯协议族：通常为Ipv4即PF_INET,</p>
<ul>
<li>PF_INET           IPv4互联网协议族.</li>
<li>PF_INET6            IPv6互联网协议族。</li>
<li>PF_LOCAL          本地通信的协议族。</li>
<li>PF_PACKET        内核底层的协议族。</li>
<li>PF_IPX                IPX Novell协议族。</li>
</ul>
</li>
<li><p>type 数据传输方式：</p>
<ul>
<li>SOCK_STREAM        面向连接的socket：<ul>
<li>1）数据不会丢失；2）数据的顺序不会错乱；3）双向通道。</li>
</ul>
</li>
<li>SOCK_DGRAM        无连接的socket：<ul>
<li>1）数据可能会丢失；2）数据的顺序可能会错乱；3）传输的效率更高。</li>
</ul>
</li>
</ul>
</li>
<li><p>protocol协议：分别与第二个参数对应的协议为IPPROTO_TCP和IPPRPTP_UDP</p>
<p>（或填0自动识别）</p>
</li>
</ul>
<p>成功返回一个有效的socketid，失败返回-1，errno被设置。</p>
<h3 id="向服务器发起连接请求-—connect"><a href="#向服务器发起连接请求-—connect" class="headerlink" title="向服务器发起连接请求 —connect()"></a>向服务器发起连接请求 —connect()</h3><h4 id="准备连接所需IP以及Port"><a href="#准备连接所需IP以及Port" class="headerlink" title="准备连接所需IP以及Port"></a>准备连接所需IP以及Port</h4><h5 id="1-gethostbyname"><a href="#1-gethostbyname" class="headerlink" title="1.gethostbyname"></a>1.gethostbyname</h5><p>获取字符传并转换为网络字节序IP</p>
<blockquote>
<p>根据域名&#x2F;主机名&#x2F;字符串IP获取大端序IP，用于网络通讯的客户端程序中。</p>
<p>struct hostent *gethostbyname(const char *name);</p>
<p>struct hostent { </p>
<p>  char *h_name;        &#x2F;&#x2F; 主机名。</p>
<p>  char **h_aliases;     &#x2F;&#x2F; 主机所有别名构成的字符串数组，同一IP可绑定多个域名。 </p>
<p>  short h_addrtype;     &#x2F;&#x2F; 主机IP地址的类型，例如IPV4（AF_INET）还是IPV6。</p>
<p>  short h_length;      &#x2F;&#x2F; 主机IP地址长度，IPV4地址为4，IPV6地址则为16。</p>
<p>  char **h_addr_list;    &#x2F;&#x2F; 主机的ip地址，以网络字节序存储。 </p>
<p>};</p>
<p>#define h_addr h_addr_list[0]  &#x2F;&#x2F; for backward compatibility.</p>
<p>转换后，用以下代码把大端序的地址复制到sockaddr_in结构体的sin_addr成员中。</p>
<p>memcpy(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</p>
</blockquote>
<h5 id="2-sockaddr与sockaddr-in"><a href="#2-sockaddr与sockaddr-in" class="headerlink" title="2.sockaddr与sockaddr_in"></a>2.sockaddr与sockaddr_in</h5><p>使用sockaddr与sockaddr_in存储IP和Port,一般都需要定义为sockaddr_in在最后连接时再转换为sockaddr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;- 存放协议族、端口和地址信息，客户端和<span class="built_in">connect</span>()函数和服务端的<span class="built_in">bind</span>()函数需要这个结构体。</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="type">unsigned</span> <span class="type">short</span> sa_family;      <span class="comment">// 协议族，与socket()函数的第一个参数相同，填AF_INET。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="type">unsigned</span> <span class="type">char</span> sa_data[<span class="number">14</span>];    <span class="comment">// 14字节的端口和地址。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;</span><br><span class="line">&gt;- sockaddr结构体是为了统一地址结构的表示方法，统一接口函数，但是，操作不方便，所以定义了等价的sockaddr_in结构体，它的大小与sockaddr相同，可以强制转换成sockaddr。</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;  </span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">short</span> sin_family;     <span class="comment">// 协议族，与socket()函数的第一个参数相同，填AF_INET。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">short</span> sin_port;        <span class="comment">// 16位端口号，大端序。用htons(整数的端口)转换。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;          <span class="comment">// IP地址的结构体。192.168.101.138</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];     <span class="comment">// 未使用，为了保持与struct sockaddr一样的长度而添加。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  &#125;;</span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;                      <span class="comment">// IP地址的结构体。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;    <span class="type">unsigned</span> <span class="type">int</span> s_addr;        <span class="comment">// 32位的IP地址，大端序。</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-addinfo"><a href="#3-addinfo" class="headerlink" title="3.addinfo"></a>3.addinfo</h5><p>这里有一个函数getaddrinfo，可以直接将之前的两步简化</p>
<p><code>getaddrinfo(m_ip.c_str(), std::to_string(m_port).c_str(), &amp;hints, &amp;res);</code> </p>
<ul>
<li><code>m_ip.c_str()</code>：这是一个指向以 null 结尾的字符串的指针，包含主机名或者 IP 地址。在这个例子中，<code>m_ip</code> 是一个 <code>std::string</code> 对象，它存储了服务器的 IP 地址或主机名。使用 <code>c_str()</code> 方法将 <code>std::string</code> 转换为 C 风格的字符串。</li>
<li><code>std::to_string(m_port).c_str()</code>：这是一个指向以 null 结尾的字符串的指针，包含服务名或端口号。<code>m_port</code> 是一个整数，表示端口号。使用 <code>std::to_string</code> 将整数转换为 <code>std::string</code>，然后使用 <code>c_str()</code> 方法将其转换为 C 风格的字符串。</li>
<li><code>&amp;hints</code>：这是一个指向 <code>addrinfo</code> 结构的指针，该结构提供了关于期望返回的地址类型的提示。在这个结构中，可以设置地址族（如 <code>AF_INET</code>），套接字类型（如 <code>SOCK_STREAM</code>），协议类型（如 <code>IPPROTO_TCP</code>），以及其他可能的选项。</li>
<li><code>&amp;res</code>：这是一个指向 <code>addrinfo</code> 结构指针的指针。函数成功执行后，<code>res</code> 将指向一个 <code>addrinfo</code> 结构链表，其中每个结构包含一个可用于 <code>bind(2)</code> 或 <code>connect(2)</code> 调用的网络地址。</li>
</ul>
<p>这个方法主要做了几件事：</p>
<blockquote>
<p>getaddrinfo </p>
<p>  1.解析：将传入的 IP 地址或主机名（m_ip.c_str()）和服务名或端口号（std::to_string(m_port).c_str()）解析为具体的网络地址<br>  2.填充：根据 hints 结构提供的参数（如协议族、套接字类型、协议类型等），getaddrinfo 会搜索符合条件的网络地址。<br>  3.返回：它会分配一个或多个 addrinfo 结构，并将它们链接成一个链表。每个 addrinfo 结构包含了可以用于创建套接字和建立连接的地址信息。<br>  4.赋值：函数成功后，res 指针会指向这个链表的头部，你可以遍历这个链表，使用其中的信息来创建套接字或进行其他网络操作</p>
</blockquote>
<p><strong>将C风格ip与port字符串以及包含协议族，套接字类型，协议类型的hints这三个参数一起用来解析，完成后分配addrinfo结构体的链表并将表头地址赋给res</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addrinfo 结构体，它包含了以下信息：</span></span><br><span class="line">ai_family	：地址族，如 AF_INET（IPv4）或 AF_INET6（IPv6）。</span><br><span class="line">ai_socktype	：套接字类型，如 SOCK_STREAM（流式套接字）或 SOCK_DGRAM（数据报套接字）。</span><br><span class="line">ai_protocol	：协议类型，如 IPPROTO_TCP（TCP 协议）或 IPPROTO_UDP（UDP 协议）。</span><br><span class="line">ai_addrlen	：地址长度，表示 ai_addr 指向的地址的长度。</span><br><span class="line">ai_addr		：指向一个 sockaddr 结构的指针，该结构包含具体的网络地址。</span><br><span class="line">ai_canonname：如果请求规范名，这是主机的规范名。</span><br><span class="line">ai_next		：指向链表中下一个 addrinfo 结构的指针。</span><br></pre></td></tr></table></figure>

<p>最终看一下两个版本的代码</p>
<p>gehostbynamey获取port+sockaddr保存信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* h; </span><br><span class="line"><span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )</span><br><span class="line">&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span> &lt;&lt; endl; </span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;              		</span><br><span class="line"><span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));     		</span><br><span class="line">servaddr.sin_family = AF_INET;            	</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);</span><br><span class="line">servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));         </span><br></pre></td></tr></table></figure>

<p>addinfo:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints,*res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="built_in">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = AF_INET;          <span class="comment">//ipv4</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;    <span class="comment">//TCP流</span></span><br><span class="line">    hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line">    std::string ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">//解析服务器地址和端口</span></span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">getaddrinfo</span>(ip.<span class="built_in">c_str</span>(),(std::<span class="built_in">to_string</span>(port)).<span class="built_in">c_str</span>(),&amp;hints,&amp;res);</span><br><span class="line">    <span class="keyword">if</span> (status!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;getaddrinfo error&quot;</span>&lt;&lt;<span class="built_in">gai_strerror</span>(status)&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">-------------------</span><br><span class="line">	<span class="comment">//创建socket</span></span><br><span class="line">	m_connfd = <span class="built_in">socket</span>(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">	<span class="comment">//int sockfd = socket(AF_INET,SOCK_STREAM,0);</span></span><br><span class="line">	<span class="keyword">if</span>(m_connfd == INVALID_SOCKET)</span><br><span class="line">	&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	<span class="comment">//连接到服务器</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(m_connfd, res-&gt;ai_addr, (<span class="type">int</span>)res-&gt;ai_addrlen) != <span class="number">0</span>)</span><br><span class="line">	&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	<span class="built_in">freeaddrinfo</span>(res);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>整洁美观。</p>
<p>实际上addrinfo和sockaddr之间并不是替代关系，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23401147/what-is-the-difference-between-struct-addrinfo-and-struct-sockaddr">在某种意义上，<code>addrinfo</code> 可以看作是 <code>sockaddr</code> 的替代者，因为它提供了更完整的信息集合。但实际上，它们是互补的：<code>addrinfo</code> 用于获取和存储地址信息，而 <code>sockaddr</code> 用于在socket API中表示地址</a></p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>连接：<code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：客户端的套接字文件描述符。</li>
<li><code>addr</code>：指向<code>struct sockaddr</code>的指针，包含了目标服务端的地址信息，包括IP地址和端口号。</li>
<li><code>addrlen</code>：<code>addr</code>结构体的大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当客户端调用<code>connect()</code>函数时，它会发起对服务端的连接请求。</li>
<li>这个过程包括TCP协议的三次握手，确保客户端和服务端之间建立稳定的连接。</li>
<li>三次握手成功后，客户端和服务端之间的套接字就可以用于发送和接收数据。</li>
</ul>
<p>使用<code>connect()</code>函数时，客户端通常会阻塞，直到连接建立成功或者发生错误。如果连接成功，客户端就可以通过<code>send()</code>和<code>recv()</code>函数与服务端进行数据交换。</p>
<h3 id="发送-x2F-接收数据-—send-x2F-recv"><a href="#发送-x2F-接收数据-—send-x2F-recv" class="headerlink" title="发送&#x2F;接收数据 —send()&#x2F;recv()"></a>发送&#x2F;接收数据 —send()&#x2F;recv()</h3><h4 id="send-函数"><a href="#send-函数" class="headerlink" title="send() 函数:"></a><strong>send() 函数</strong>:</h4><ul>
<li><p>用于向TCP连接的另一端发送数据。</p>
</li>
<li><p>函数原型：</p>
<p><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags); </code></p>
</li>
<li><p>参数：</p>
<ul>
<li><code>sockfd</code>：连接的套接字文件描述符。</li>
<li><code>buf</code>：指向要发送数据的缓冲区。</li>
<li><code>len</code>：要发送的数据长度。</li>
<li><code>flags</code>：提供额外的信息来控制发送行为，一般设置为0。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时返回实际发送的字节数。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
</ul>
<h4 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv() 函数:"></a><strong>recv() 函数</strong>:</h4><ul>
<li><p>用于接收来自套接字缓冲区的数据。</p>
</li>
<li><p>函数原型：</p>
<p><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags); </code></p>
</li>
<li><p>参数：</p>
<ul>
<li><code>sockfd</code>：连接的套接字文件描述符。</li>
<li><code>buf</code>：指向用于接收数据的缓冲区。</li>
<li><code>len</code>：缓冲区长度。</li>
<li><code>flags</code>：提供额外的信息来控制接收行为，一般设置为0。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时返回实际读到的字节数。</li>
<li>如果在等待协议接收数据时网络中断了，那么它返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
</ul>
<p>在使用<code>send()</code>和<code>recv()</code>函数时，需要注意的是，它们都可能因为网络延迟或其他原因而阻塞。在阻塞模式下，如果发送&#x2F;接收缓冲区不可用，这些函数会等待直到缓冲区变得可用。在非阻塞模式下，如果操作会导致阻塞，这些函数会立即返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>错误。此外，如果<code>send()</code>在发送数据时遇到对端关闭连接的情况，会收到<code>SIGPIPE</code>信号。</p>
<h3 id="关闭连接，释放资源-—close"><a href="#关闭连接，释放资源-—close" class="headerlink" title="关闭连接，释放资源 —close()"></a>关闭连接，释放资源 —close()</h3><p>close(sockfd);</p>
<p>&#x3D;&#x3D;在网络编程中，数据收发的时候有自动转换机制，不需要程序员手动转换，只有向sockaddr_in结体成员变量填充数据时，才需要考虑字节序的问题。&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此程序用于演示socket的客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using:./demo1 服务端的IP 服务端的端口\nExample:./demo1 IP Port\n\n&quot;</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">  <span class="comment">// 第1步：创建客户端的socket。  </span></span><br><span class="line">  <span class="comment">//创建了一个ipv4的socket，得到了这个socket的描述符</span></span><br><span class="line">  <span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (sockfd==<span class="number">-1</span>)<span class="comment">//所有网络编程失败返回-1     </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> -----------------</span><br><span class="line">  <span class="comment">// 第2步：向服务器发起连接请求。 </span></span><br><span class="line"> ------</span><br><span class="line">  <span class="comment">//a.获取并保存IP+Prot。发起请求需要从main参数中取得服务器的IP与端口</span></span><br><span class="line"> ---</span><br><span class="line">     <span class="comment">//①.获取IP并转换网络字节序</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hostent</span>* h;    <span class="comment">// 用于存放服务端IP的结构体。</span></span><br><span class="line">  <span class="keyword">if</span> ( (h = <span class="built_in">gethostbyname</span>(argv[<span class="number">1</span>])) == <span class="number">0</span> )  <span class="comment">// 该函数根据域名/主机名/字符串IP获取大端序IP。</span></span><br><span class="line">  &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gethostbyname failed.\n&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="built_in">close</span>(sockfd);<span class="comment">//无法获取则关闭socket并推出程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">---</span><br><span class="line">  <span class="comment">//②.将获取到的IP存入一个socket&quot;专用&quot;结构体(sockaddr/sockaddr_in)</span></span><br><span class="line">  <span class="comment">/*sockaddr结构体是为了统一地址结构的表示方法，统一接口函数，但是，操作不方便，所以定义了等价的sockaddr_in结构体，它的大小与sockaddr相同，可以强制转换成sockaddr。*/</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;              		<span class="comment">// 用于存放服务端IP和端口的结构体。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));     		<span class="comment">//初始化置为全零</span></span><br><span class="line">  servaddr.sin_family = AF_INET;            		<span class="comment">// sin_family设置结构体第一个参数-协议族-Ipv4</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr,h-&gt;h_addr,h-&gt;h_length);	 <span class="comment">// sin_addr指定服务端的IP地址。将gethostbyname转换得到的IP存入</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));          <span class="comment">// 指定服务端的通信端口。unsigned short-unit16</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">//b.准备完毕，发起连接请求</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr))!=<span class="number">0</span>)  <span class="comment">// 向服务端发起连接清求。</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(sockfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">-----------------</span><br><span class="line">  <span class="comment">// 第3步：与服务端通讯，客户发送一个请求报文后等待服务端的回复，收到回复后，再发下一个请求报文。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;ii++)  <span class="comment">// 循环3次，将与服务端进行三次通讯。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iret;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;这是第%d个，编号%03d。&quot;</span>,i+<span class="number">1</span>,i+<span class="number">1</span>);  <span class="comment">// 生成请求报文内容。</span></span><br><span class="line">    <span class="comment">// 向服务端发送请求报文。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">send</span>(sockfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">// 接收服务端的回应报文，如果服务端没有发送回应报文，recv()函数将阻塞等待。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">recv</span>(sockfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第4步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>相似的部分不再复述</p>
<ul>
<li>第二步绑定中（line11）的htonl</li>
</ul>
<blockquote>
<p>为了解决不同字节序的计算机之间传输数据的问题，约定采用网络字节序（大端序）。</p>
<p>C语言提供了四个库函数，用于在主机字节序和网络字节序之间转换：</p>
<p>uint16_t h to n s(uint16_t hostshort);   &#x2F;&#x2F; uint16_t  2字节的整数 unsigned short</p>
<p>uint32_t htonl(uint32_t hostlong);    &#x2F;&#x2F; uint32_t  4字节的整数 unsigned int</p>
<p>uint16_t ntohs(uint16_t netshort);</p>
<p>uint32_t n to h l(uint32_t netlong);</p>
<p>h     host（主机）；</p>
<p>to  转换；</p>
<p>n     network（网络）；</p>
<p>s     short（2字节，16位的整数）；</p>
<p>l      long（4字节，32位的整数）；</p>
</blockquote>
<ul>
<li><p>bind绑定服务端的IP和端口到<code>listenfd</code>这个socket上(为socket分配ip和port)。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p> 参数说明：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，即代表<code>socket()</code>函数创建的套接字文件。</li>
<li><code>addr</code>：指向一个<code>struct sockaddr</code>类型的结构体变量，此结构体成员用于设置要绑定的IP和端口。</li>
<li><code>addrlen</code>：第二个参数所指向的结构体变量的大小。</li>
</ul>
<p> 返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
</li>
<li><p>listen设置当前状态为监听</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：指向已经绑定到一个本地地址的套接字的文件描述符。</li>
<li><code>backlog</code>：定义了套接字可以排队等待的挂起连接的最大数量。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回0。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当调用<code>listen()</code>函数时，内核会为相应的套接字启动一个监听队列，用于存放等待处理的客户端连接请求。这个队列的长度由<code>backlog</code>参数指定。</li>
<li><code>backlog</code>参数告诉系统该套接字在开始拒绝新的连接请求之前，可以排队的未完成连接请求的最大数量。这个值通常由系统管理员根据系统资源和应用程序的需求进行配置。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459374581">在TCP三次握手过程中，当第一次握手（SYN）包到达服务器时，服务器会将这个连接放入一个半连接队列中。如果队列满了，新的连接请求可能会被忽略。<code>backlog</code>参数就是用来设置这个半连接队列的长度的</a></li>
</ul>
</li>
<li><p>accept受理请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>sockfd</code>：监听套接字的文件描述符，它是之前通过<code>socket()</code>创建并通过<code>bind()</code>和<code>listen()</code>设置为监听状态的套接字。</li>
<li><code>addr</code>：（可选）指向<code>struct sockaddr</code>结构的指针，用于接收连接的客户端的地址信息。</li>
<li><code>addrlen</code>：（可选）指向<code>socklen_t</code>类型的变量的指针，表示<code>addr</code>的长度。在调用前，应该设置为<code>addr</code>结构的大小；调用后，会被设置为实际接收到的地址的大小。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功时返回一个新的套接字文件描述符，用于与客户端进行通信。</li>
<li>失败时返回-1，并设置<code>errno</code>以指示错误类型。</li>
</ul>
<p>功能描述：</p>
<ul>
<li>当服务器端的套接字处于监听状态时，<code>accept()</code>函数会检查是否有已完成的连接请求在队列中。</li>
<li>如果有，<code>accept()</code>会创建一个新的套接字，并将其与发起连接的客户端关联起来。这个新的套接字不同于监听套接字，它专门用于与该客户端的通信。</li>
<li>如果<code>addr</code>和<code>addrlen</code>参数不为NULL，<code>accept()</code>还会将客户端的地址信息写入<code>addr</code>所指向的结构，并更新<code>addrlen</code>所指的值为实际地址的长度。</li>
<li>如果在调用<code>accept()</code>时没有已完成的连接请求，那么根据套接字的阻塞状态，<code>accept()</code>可能会阻塞等待，直到有连接请求完成或者发生错误。</li>
</ul>
<p>&#x3D;&#x3D;服务端通过accept利用绑定好的且处于监听状态的监听套接字与客户端的请求匹配，成功后返回一个新的套接字用于回复客户端&#x3D;&#x3D;</p>
<p>回复与发送的内容都在buffer中进行</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此程序用于演示socket通信的服务端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//第一步相同</span></span><br><span class="line"><span class="comment">// 第1步：创建服务端的socket。 </span></span><br><span class="line">  <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (listenfd==<span class="number">-1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">-------------------------------</span><br><span class="line">  <span class="comment">/*第2步：把服务端用于通信的IP和端口绑定到socket上*/</span></span><br><span class="line">  <span class="comment">//a.准备ip与端口</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> servaddr;          <span class="comment">// 用于存放服务端IP和端口的数据结构。</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;servaddr,<span class="number">0</span>,<span class="built_in">sizeof</span>(servaddr));</span><br><span class="line">  servaddr.sin_family = AF_INET;                <span class="comment">// 指定协议。与客户端相同</span></span><br><span class="line">  servaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// 服务端任意网卡的IP都可以用于通讯，服务端可以与多个客户端建立连接。</span></span><br><span class="line">  servaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));     <span class="comment">// 指定通信端口，端口需要与客户端相同</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//b.绑定服务端的IP和端口到listenfd这个socket上(为socket分配ip和port)。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="built_in">sizeof</span>(servaddr)) != <span class="number">0</span> )</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(listenfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第3步：把socket设置为可连接（监听）的状态。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd,<span class="number">5</span>) != <span class="number">0</span> ) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>); </span><br><span class="line">    <span class="built_in">close</span>(listenfd); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第4步：受理客户端的连接请求，如果没有客户端连上来，accept()函数将阻塞等待。</span></span><br><span class="line"><span class="comment">//accept利用监听套接字连接客户端</span></span><br><span class="line">  <span class="type">int</span> clientfd=<span class="built_in">accept</span>(listenfd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (clientfd==<span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    	<span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>); <span class="function">c</span></span><br><span class="line"><span class="function">        <span class="title">lose</span><span class="params">(listenfd)</span></span>; </span><br><span class="line">     	 <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;客户端已连接。\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iret;</span><br><span class="line">    <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="comment">// 接收客户端的请求报文，如果客户端没有发送请求报文，recv()函数将阻塞等待。</span></span><br><span class="line">    <span class="comment">// 如果客户端已断开连接，recv()函数将返回0。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">recv</span>(clientfd,buffer,<span class="built_in">sizeof</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;  <span class="keyword">break</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,<span class="string">&quot;ok&quot;</span>);  <span class="comment">// 生成回应报文内容。</span></span><br><span class="line">    <span class="comment">// 向客户端发送回应报文。</span></span><br><span class="line">    <span class="keyword">if</span> ( (iret=<span class="built_in">send</span>(clientfd,buffer,<span class="built_in">strlen</span>(buffer),<span class="number">0</span>))&lt;=<span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>); <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第6步：关闭socket，释放资源。</span></span><br><span class="line">  <span class="built_in">close</span>(listenfd);   <span class="comment">// 关闭服务端用于监听的socket。</span></span><br><span class="line">  <span class="built_in">close</span>(clientfd);   <span class="comment">// 关闭客户端连上来的socket。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/07/linux-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/linux-system/" class="post-title-link" itemprop="url">linux进程调用</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:00:00" itemprop="dateCreated datePublished" datetime="2024-04-07T12:00:00+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-20 19:14:53" itemprop="dateModified" datetime="2024-05-20T19:14:53+08:00">2024-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/process/" itemprop="url" rel="index"><span itemprop="name">process</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程调用"><a href="#进程调用" class="headerlink" title="进程调用"></a>进程调用</h1><p>在 Linux 中，<code>system</code> 函数和 <code>execl</code> 函数都是用于执行系统命令的函数，但它们在使用和行为上有一些关键的区别：</p>
<ol>
<li><strong>system 函数</strong>：<ul>
<li><code>system</code> 函数通过创建一个新的子进程来执行指定的命令，然后等待该命令执行完成。</li>
<li>它实际上是调用 <code>/bin/sh -c command</code> 来执行命令，其中 <code>command</code> 是传递给 <code>system</code> 函数的字符串。</li>
<li>在命令执行期间，<code>SIGCHLD</code> 信号会被阻塞，而 <code>SIGINT</code> 和 <code>SIGQUIT</code> 信号会被忽略。</li>
<li><code>system</code> 函数的返回值是命令执行后的状态码。如果命令成功执行，返回值通常是命令的退出状态。如果 <code>system</code> 函数本身失败，则返回 <code>-1</code>。</li>
<li>只有一个参数，即要执行的命令字符串。</li>
<li>函数原型：<code>int system(const char *command);</code></li>
<li>如果 <code>command</code> 是 <code>NULL</code>，则 <code>system</code> 函数会检查 shell 是否可用，如果可用则返回非零值。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">如果 <code>command</code> 不是 <code>NULL</code>，则 <code>system</code> 函数会执行命令，并返回命令的退出状态码。</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/linluan33/article/details/8097916">2</a></li>
</ul>
</li>
<li><strong>execl 函数</strong>：<ul>
<li><code>execl</code> 函数用于在当前进程中执行一个新的程序，它会替换当前进程的映像、数据、堆和栈。</li>
<li>这意味着，一旦 <code>execl</code> 成功执行，当前进程的执行代码将变为新程序的代码，原来的程序将不再存在。</li>
<li><code>execl</code> 函数需要指定新程序的路径和传递给新程序的参数列表，参数列表的最后必须是 <code>NULL</code>。</li>
<li>如果 <code>execl</code> 调用成功，它不会返回；如果调用失败，它会返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误原因。</li>
<li>需要多个参数：第一个是可执行文件的路径，接下来是传递给程序的参数列表，最后必须以 <code>NULL</code> 结尾。</li>
<li>函数原型：<code>int execl(const char *path, const char *arg, ..., (char *)NULL);</code></li>
<li>第一个参数 <code>path</code> 是要执行的程序的路径。</li>
<li>第二个参数 <code>arg</code> 是程序的第一个参数（通常是程序的名称）。</li>
<li>后续参数可以根据需要传递给程序，最后一个参数必须是 <code>NULL</code>，以标识参数列表的结束。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/457019360">如果 <code>execl</code> 调用成功，它不会返回；如果调用失败，它会返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误原因。</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53133879/article/details/125092300">3</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/105329417">4</a></li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Cccarl/p/6639089.html">简单来说，<code>system</code> 函数适合于需要执行外部命令并等待其完成的情况，而 <code>execl</code> 函数适合于需要替换当前进程为一个全新程序的情况。</a></p>
<p>system创建新的子进程来执行指定的命令，执行完成后返回原进程</p>
<p>execl创建新的进程并替换（取代）当前进程打的数据堆栈等，原程序将不再存在</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/105329417">Linux编程之exec类函数（参数详解+示例）_exec函数 调用带命令行参数的可执行文件 示例-CSDN博客</a></p>
</blockquote>
<h1 id="return和exit"><a href="#return和exit" class="headerlink" title="return和exit"></a>return和exit</h1><p><code>return</code> 和 <code>exit</code> 都用于结束函数执行，但它们的用途和影响范围有所不同：</p>
<ol>
<li><strong>return</strong>：<ul>
<li><code>return</code> 用于从当前函数返回一个值到调用函数。</li>
<li>它只会结束当前函数的执行，并将控制权交回给调用该函数的代码。</li>
<li>如果 <code>return</code> 用在 <code>main</code> 函数中，它会结束整个程序，因为 <code>main</code> 是程序的入口点。</li>
</ul>
</li>
<li><strong>exit</strong>：<ul>
<li><code>exit</code> 是一个标准库函数，定义在 <code>&lt;stdlib.h&gt;</code> 中，用于立即终止程序的执行。</li>
<li>它会关闭所有使用的文件描述符，终止进程，并将控制权交还给操作系统。</li>
<li><code>exit</code> 可以在程序的任何地方调用，不仅限于 <code>main</code> 函数。</li>
<li><code>exit</code> 还会执行一些清理操作，比如调用通过 <code>atexit</code> 注册的函数。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noble/p/4144166.html">总结来说，<code>return</code> 是用于从函数返回，而 <code>exit</code> 是用于立即结束整个程序的执行。如果你在 <code>main</code> 函数中使用 <code>return</code>，它和 <code>exit</code> 有相似的效果，因为它们都会导致程序终止。但在其他函数中，<code>return</code> 只会结束当前函数，而 <code>exit</code> 会结束整个程序。</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/noble/p/4144166.html">1</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/lb543210/article/details/81435694">2</a></p>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有8种方式可以中止进程，其中5种为正常终止，它们是：</p>
<p>1）在main()函数用return返回；</p>
<p>2）在任意函数中调用exit()函数；</p>
<p>3）在任意函数中调用_exit()或_Exit()函数；</p>
<p>4）最后一个线程从其启动例程（线程主函数）用return返回；</p>
<p>5）在最后一个线程中调用pthread_exit()返回；</p>
<p>异常终止有3种方式，它们是：</p>
<p>6）调用abort()函数中止；</p>
<p>7）接收到一个信号；</p>
<p>8）最后一个线程对取消请求做出响应</p>
<h3 id="一、进程终止的状态"><a href="#一、进程终止的状态" class="headerlink" title="一、进程终止的状态"></a>一、进程终止的状态</h3><p>在main()函数中，return的返回值即终止状态，如果没有return语句或调用exit()，那么该进程的终止状态是0。</p>
<p>在Shell中，查看进程终止的状态：<code>echo $?</code></p>
<p>正常终止进程的3个函数（<code>exit()</code>和<code>_Exit()</code>是由ISO C说明的，<code>_exit()</code>是由POSIX说明的）。</p>
<p><code>void exit(int status);</code></p>
<p><code>void _exit(int status);</code></p>
<p><code>void _Exit(int status);</code></p>
<p>status也是进程终止的状态。</p>
<p>如果进程被异常终止，终止状态为非0。  服务程序的调度、日志和监控</p>
<h3 id="二、资源释放的问题"><a href="#二、资源释放的问题" class="headerlink" title="二、资源释放的问题"></a>二、资源释放的问题</h3><p>return表示函数返回，会调用局部对象的析构函数，main()函数中的return还会调用全局对象的析构函数。</p>
<p>**exit()<strong>表示终止进程，</strong>&#x3D;&#x3D;不会调用局部对象的析构函数，只调用全局对象的析构函数&#x3D;&#x3D;**。</p>
<p><code>exit()</code>会执行清理工作，然后退出，<code>_exit()</code>和<code>_Exit()</code>直接退出，不会执行任何清理工作。</p>
<h3 id="三、进程的终止函数"><a href="#三、进程的终止函数" class="headerlink" title="三、进程的终止函数"></a>三、进程的终止函数</h3><p>进程可以用atexit()函数登记终止函数（最多32个），这些函数将由exit()自动调用。</p>
<p><code>int atexit(void (*function)(void));</code></p>
<p><code>exit()</code>调用终止函数的顺序与登记时相反。 进程退出前的收尾工作</p>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/04/linux-Main(arg)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/04/linux-Main(arg)/" class="post-title-link" itemprop="url">main函数的参数</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-04 17:00:00 / 修改时间：18:29:13" itemprop="dateCreated datePublished" datetime="2024-04-04T17:00:00+08:00">2024-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="int-main-int-argc-char-argv-char-envp"><a href="#int-main-int-argc-char-argv-char-envp" class="headerlink" title="int main(int argc,char *argv[],char*envp[])"></a>int main(int argc,char *argv[],char*envp[])</h1><p>在C和C++中，<code>main</code> 函数可以有不同的形式，这取决于程序是否需要从命令行接收参数或环境变量。通常，如果程序不需要命令行参数或环境变量，可以使用 <code>int main()</code> 或 <code>int main(void)</code>。如果程序需要命令行参数，可以使用 <code>int main(int argc, char* argv[])</code>，其中 <code>argc</code> 表示参数数量，<code>argv</code> 是参数的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[],<span class="type">char</span>*envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出命令行的参数个数</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;There are &quot;</span>&lt;&lt;argc&lt;&lt;<span class="string">&quot; args&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"><span class="comment">//打印出所有参数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;argv[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//打印出所有环境变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;envp[i]!=<span class="number">0</span>;i++)</span><br><span class="line">std::cout&lt;&lt;envp[i]&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加环境变量</span></span><br><span class="line"><span class="built_in">setenv</span>(<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取环境变量</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;AA= &quot;</span>&lt;&lt;<span class="built_in">getenv</span>(<span class="string">&quot;AA&quot;</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>linux中g++编译后运行<code>./Main a1 a2</code>输出得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">There are 3 args</span><br><span class="line">0 : ./Main</span><br><span class="line">1 : a1</span><br><span class="line">2 : a2</span><br><span class="line">...</span><br><span class="line">//一大堆环境变量</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">XDG_MENU_PREFIX=gnome-</span><br><span class="line">PWD=/home/jenwein/dev/ostest3</span><br><span class="line">...</span><br><span class="line">_=./Main</span><br><span class="line">AA= aaaa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在vs中不再使用<code>putenv</code> 和 <code>getenv</code> ，理由之后再说&#x2F;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>** envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* pValue;</span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line">	<span class="type">errno_t</span> err;</span><br><span class="line"> <span class="comment">//输出命令行的参数个数</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; argc &lt;&lt; <span class="string">&quot; args&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//打印出所有参数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//打印出所有环境变量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; envp[i] != <span class="number">0</span>; i++)</span><br><span class="line">		std::cout &lt;&lt; envp[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加环境变量，使用_putenv(const char *envstring)参数为环境字符串定义。</span></span><br><span class="line">	<span class="comment">//envstring：指向环境变量的指针，其中环境变量必须以 &quot;name=value&quot; 的形式给出,调用成功返回 0调用失败时返回 非0 值</span></span><br><span class="line">	<span class="keyword">if</span> (_putenv(<span class="string">&quot;AA=aaaa&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;环境变量添加成功\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;环境变量添加失败\n&quot;</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取环境变量使用_dupenv_s（char **buffer,size_t *numberOfElements,const char *varname）</span></span><br><span class="line">    <span class="comment">//1.buffer 用于存储变量值的缓冲区。</span></span><br><span class="line">    <span class="comment">//2.numberOfElement sbuffer 的大小。</span></span><br><span class="line">    <span class="comment">//3.varname 环境变量名称</span></span><br><span class="line"><span class="comment">//ps:如果未找到变量，则将 buffer 设置为 NULL、将 numberOfElements 设置为 0，并且返回值是 0，因为未将这种情况视为错误条件。</span></span><br><span class="line"></span><br><span class="line">	err = _dupenv_s(&amp;pValue, &amp;len, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;获取失败,[ERROR]: &quot;</span> &lt;&lt; err &lt;&lt; std::endl;	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pValue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;环境变量 &#x27;BB&#x27; 不存在。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;BB=&quot;</span> &lt;&lt; pValue &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pValue != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(pValue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>putenv</code> vs <code>_putenv</code>:<ul>
<li><code>putenv</code> 是 POSIX 标准的一部分，用于设置或更改环境变量。在 Unix 类系统（如 Linux）中，<code>putenv</code> 是常用的函数。</li>
<li><code>_putenv</code> 是 Microsoft Visual C++ 提供的函数，它是 <code>putenv</code> 的替代品，用于在 Windows 系统中设置环境变量。它与 ISO C++ 标准兼容，因此在 Windows 平台上编程时推荐使用 <code>_putenv</code>。</li>
</ul>
</li>
<li><code>getenv</code> vs <code>_dupenv_s</code>:<ul>
<li><code>getenv</code> 是 C 和 POSIX 标准库中的一个函数，用于获取环境变量的值。但是，<code>getenv</code> 返回的是指向内部存储的指针，这可能会在多线程环境中引起问题，因为环境变量可能被其他线程更改。</li>
<li><code>_dupenv_s</code> 是一个更安全的函数，它在 Microsoft Visual C++ 中提供。它不仅返回环境变量的值，还会为这个值分配新的内存，避免了 <code>getenv</code> 可能带来的线程安全问题。因此，在需要考虑线程安全的 Windows 程序中，推荐使用 <code>_dupenv_s</code>。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>_putenv</code> 和 <code>_dupenv_s</code> 是在 Windows 平台上，为了提高安全性和符合标准而推荐使用的函数。它们提供了与 <code>putenv</code> 和 <code>getenv</code> 相同的功能，但是在处理环境变量时更安全，更适合多线程环境</p>
<p>相关用法详见</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/dupenv-s-wdupenv-s?view=msvc-170">_dupenv_s、_wdupenv_s | Microsoft Learn</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/putenv-wputenv?view=msvc-170">_putenv、_wputenv | Microsoft Learn</a></p>
</blockquote>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/04/03/linux-makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/linux-makefile/" class="post-title-link" itemprop="url">makefile</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-03 22:00:00 / 修改时间：15:06:11" itemprop="dateCreated datePublished" datetime="2024-04-03T22:00:00+08:00">2024-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/makefile/" itemprop="url" rel="index"><span itemprop="name">makefile</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/110905996">Makefile 是一个文本文件，用于定义如何编译和链接源代码以生成可执行文件、库文件或其他构建目标。它是 make 工具的输入文件，make 工具根据 Makefile 中定义的规则自动执行编译和链接操作。在 Makefile 中，你可以定义变量、编译规则、文件依赖关系等，以简化和自动化编译过程。例如，你可以指定哪些文件需要编译，哪些文件需要先编译，哪些文件需要后编译，以及哪些文件在源文件更改后需要重新编译</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/110905996">1</a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/575852387">2</a><a target="_blank" rel="noopener" href="https://getiot.tech/zh/makefile/makefile-intro/">3</a>。</p>
<p>这是一个简单的 Makefile 示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: program  </span></span><br><span class="line"><span class="section">program: main.o utils.o     </span></span><br><span class="line">		gcc -o program main.o utils.o  </span><br><span class="line"><span class="section">main.o: main.c     </span></span><br><span class="line">		gcc -c main.c  </span><br><span class="line"><span class="section">utils.o: utils.c     </span></span><br><span class="line">		gcc -c utils.c  </span><br><span class="line"><span class="section">clean:     </span></span><br><span class="line">		rm -f *.o program </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wohu1104/article/details/110905996">在这个例子中，<code>all</code> 是一个目标，它依赖于 <code>program</code> 目标。<code>program</code> 目标又依赖于 <code>main.o</code> 和 <code>utils.o</code> 对象文件。<code>gcc</code> 命令用于编译源文件并生成对象文件，以及链接对象文件生成最终的可执行文件。<code>clean</code> 是一个伪目标，用于清理编译生成的文件。使用 Makefile 可以大大提高软件开发的效率，特别是在处理大型项目时</a></p>
<p>Makefile 的语法主要包括以下几个部分：</p>
<ol>
<li><strong>目标（Targets）</strong>：指明要生成的文件或执行的操作。</li>
<li><strong>依赖（Dependencies）</strong>：目标文件依赖的文件，即在生成目标之前需要先存在或最新的文件。</li>
<li><strong>命令（Commands）</strong>：一系列执行的shell命令，用于生成目标文件。</li>
<li><strong>变量（Variables）</strong>：可以在 Makefile 中定义变量，以便重复使用。</li>
<li><strong>规则（Rules）</strong>：由目标、依赖和命令组成的指令，告诉 make 如何生成一个目标。</li>
<li><strong>伪目标（Phony Targets）</strong>：不是文件的目标，通常用于执行特定的命令序列。</li>
</ol>
<p>以下是一些具体的语法规则：</p>
<ul>
<li><p><strong>规则的基本语法</strong>：</p>
<p><code>目标...: 依赖...     命令 </code></p>
<p>每条命令前必须有一个Tab键作为缩进。</p>
</li>
<li><p><strong>变量的使用</strong>： 使用 <code>$</code> 符号表示取变量的值，例如：</p>
<p><code>CC = gcc CFLAGS = -g -Wall $(CC) $(CFLAGS) -c main.c </code></p>
</li>
<li><p><strong>通配符和模式匹配</strong>： 使用 <code>%</code> 作为模式匹配，例如：</p>
<p><code>%.o: %.c     $(CC) -c $&lt; -o $@ </code></p>
</li>
<li><p><strong>函数的使用</strong>： Makefile 提供了许多内置函数，例如 <code>wildcard</code>、<code>patsubst</code> 等，用于文件名和字符串的操作。</p>
</li>
<li><p><strong>条件判断</strong>： Makefile 支持条件判断语句，如 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code> 和 <code>ifndef</code>。</p>
</li>
<li><p><strong>包含其他 Makefile</strong>： 使用 <code>include</code> 关键字可以包含其他 Makefile 文件。</p>
</li>
<li><p><strong>注释</strong>： 使用 <code>#</code> 开头的行表示注释。</p>
</li>
</ul>
<h2 id="1-循环"><a href="#1-循环" class="headerlink" title="1.循环"></a>1.循环</h2><p>在 Makefile 中使用循环可以帮助你重复执行一系列命令，这在处理多个类似对象时非常有用。Makefile 支持 <code>foreach</code> 和 <code>while</code> 循环，但 <code>while</code> 循环不是直接支持的，通常需要通过其他方式模拟。以下是 <code>foreach</code> 循环的使用方法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量，包含多个值 </span></span><br><span class="line">FILES := file1.c file2.c file3.c  </span><br><span class="line"><span class="comment"># 使用 foreach 函数遍历 FILES 变量中的每个文件名 </span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">file</span>,<span class="variable">$(FILES)</span>,$(<span class="built_in">file</span>:.c=.o)</span>)  </span><br><span class="line"><span class="comment"># 定义规则，使用 OBJS 变量中的对象文件列表 </span></span><br><span class="line"><span class="section">all: <span class="variable">$(OBJS)</span>     </span></span><br><span class="line">	gcc -o program <span class="variable">$(OBJS)</span> </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>foreach</code> 函数遍历 <code>FILES</code> 变量中的每个文件名，并将 <code>.c</code> 后缀替换为 <code>.o</code>，生成对象文件列表 <code>OBJS</code>。然后，<code>all</code> 规则使用这个列表来编译程序。</p>
<p>对于 <code>while</code> 循环，由于 Makefile 本身不直接支持，通常需要通过 shell 脚本或其他工具来实现。例如，你可以在命令中使用 shell 的 <code>while</code> 循环：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 shell 命令的 while 循环 </span></span><br><span class="line"><span class="section">count:     </span></span><br><span class="line">	@count=0 ; \     </span><br><span class="line">	while [ $$count -lt 5 ]; do \         </span><br><span class="line">		echo Count: $$count ; \         </span><br><span class="line">		count=$$((count + 1)) ; \     </span><br><span class="line">	done </span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>count</code> 目标使用 shell 的 <code>while</code> 循环来打印数字 0 到 4。</p>
<h2 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2.条件判断"></a>2.条件判断</h2><p>常见的条件判断语句：</p>
<ol>
<li><strong>ifeq 和 ifneq</strong>：用于比较两个值是否相等或不相等。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(VARIABLE)</span>,value)     </span><br><span class="line"><span class="comment"># 如果 VARIABLE 等于 value，则执行这里的命令 </span></span><br><span class="line"><span class="keyword">else</span>     </span><br><span class="line"><span class="comment"># 如果 VARIABLE 不等于 value，则执行这里的命令 </span></span><br><span class="line"><span class="keyword">endif</span> </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>ifdef 和 ifndef</strong>：用于检查一个变量是否被定义。</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifdef</span> VARIABLE_NAME     </span><br><span class="line"><span class="comment"># 如果 VARIABLE_NAME 被定义，则执行这里的命令 </span></span><br><span class="line"><span class="keyword">else</span>     </span><br><span class="line"><span class="comment"># 如果 VARIABLE_NAME 未被定义，则执行这里的命令 </span></span><br><span class="line"><span class="keyword">endif</span> </span><br></pre></td></tr></table></figure>

<p>在使用条件判断时，需要注意以下几点：</p>
<ul>
<li><code>ifeq</code> 和 <code>ifneq</code> 后面的参数可以用小括号 <code>()</code> 或者是单引号 <code>&#39;&#39;</code> 包围。</li>
<li>条件语句中的 <code>else</code> 部分是可选的，如果不需要可以省略。</li>
<li>条件语句必须以 <code>endif</code> 结束。</li>
<li>在条件表达式中不能使用自动化变量，因为它们只在规则命令执行时有效。</li>
</ul>
<h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><p>$符号表示取变量的值，当变量名多于一个字符时，使用”( )”<br>$符的其他用法</p>
<p>$^ 表示所有的依赖文件</p>
<p>$@ 表示生成的目标文件</p>
<p>$&lt; 代表第一个依赖文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello.out</span></span><br><span class="line"> </span><br><span class="line"><span class="section">hello.out: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h2 id="4、变量赋值"><a href="#4、变量赋值" class="headerlink" title="4、变量赋值"></a>4、变量赋值</h2><p>1、”<strong>&#x3D;</strong>“是最普通的等号，在Makefile中容易搞错赋值等号，使用 “&#x3D;”进行赋值，变量的值是整个Makefile中最后被指定的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A = AA</span><br></pre></td></tr></table></figure>

<p>经过上面的赋值后，最后VIR_B的值是AA B，而不是A B，在make时，会把整个Makefile展开，来决定变量的值</p>
<p>2、”<strong>:&#x3D;</strong>“ 表示直接赋值，赋予当前位置的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A := A</span><br><span class="line">VIR_B := <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A := AA</span><br></pre></td></tr></table></figure>

<p>最后BIR_B的值是A B，即根据当前位置进行赋值。因此相当于“&#x3D;”，“：&#x3D;”才是真正意义上的直接赋值</p>
<p>3、”<strong>?&#x3D;</strong>“ 表示如果该变量没有被赋值，赋值予等号后面的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VIR ?= new_value</span><br></pre></td></tr></table></figure>

<p>如果VIR在之前没有被赋值，那么VIR的值就为new_value。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIR := old_value</span><br><span class="line">VIR ?= new_value</span><br></pre></td></tr></table></figure>

<p>这种情况下，VIR的值就是old_value<br>4、”<strong>+&#x3D;</strong>“和平时写代码的理解是一样的，表示将符号后面的值添加到前面的变量上</p>
<h2 id="5、预定义变量"><a href="#5、预定义变量" class="headerlink" title="5、预定义变量"></a>5、预定义变量</h2><p>CC：c编译器的名称，默认值为cc。cpp c预编译器的名称默认值为$(CC) -E</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br></pre></td></tr></table></figure>

<p>回显问题，Makefile中的命令都会被打印出来。如果不想打印命令部分 可以使用@去除回显</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo <span class="string">&quot;clean done!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h2><p>通配符</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br></pre></td></tr></table></figure>

<p>匹配目录下所有.c 文件，并将其赋值给SRC变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br></pre></td></tr></table></figure>

<p>这个函数有三个参数，意思是取出SRC中的所有值，然后将.c 替换为.o 最后赋值给OBJ变量。</p>
<p>示例：如果目录下有很多个.c 源文件，就不需要写很多条规则语句了，而是可以像下面这样写</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello.out</span></span><br><span class="line"> </span><br><span class="line"><span class="section">hello.out: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc <span class="variable">$(OBJ)</span> -o hello.out</span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">        gcc -c <span class="variable">$(SRC)</span> -o <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure>

<p>这里先将所有.c 文件编译为 .o 文件，这样后面更改某个 .c 文件时，其他的 .c 文件将不在编译，而只是编译有更改的 .c 文件，可以大大提高大项目中的编译速度。</p>
<h2 id="7、伪目标-PHONY"><a href="#7、伪目标-PHONY" class="headerlink" title="7、伪目标 .PHONY"></a>7、伪目标 .PHONY</h2><p>伪目标只是一个标签，clean是个伪目标没有依赖文件，只有用make来调用时才会执行</p>
<p>当目录下有与make 命令 同名的文件时 执行make 命令就会出现错误。</p>
<p>解决办法就是使用伪目标</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello.out</span></span><br><span class="line"> </span><br><span class="line"><span class="section">hello.out: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJ)</span> hello.out</span><br><span class="line"> </span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean ALL</span></span><br></pre></td></tr></table></figure>

<p>通常也会把ALL设置成伪目标</p>
<h2 id="8、其他常用功能"><a href="#8、其他常用功能" class="headerlink" title="8、其他常用功能"></a>8、其他常用功能</h2><p>代码清理clean<br>我们可以编译一条属于自己的clean语句，来清理make命令所产生的所有文件，列如</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">ALL: hello.out</span></span><br><span class="line"> </span><br><span class="line"><span class="section">hello.out: <span class="variable">$(OBJ)</span></span></span><br><span class="line">        gcc <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ)</span>: <span class="variable">$(SRC)</span></span><br><span class="line">        gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf <span class="variable">$(OBJ)</span> hello.out</span><br></pre></td></tr></table></figure>

<h2 id="9、嵌套执行Makefile"><a href="#9、嵌套执行Makefile" class="headerlink" title="9、嵌套执行Makefile"></a>9、嵌套执行Makefile</h2><p>在一些大工程中，会把不同模块或不同功能的源文件放在不同的目录中，我们可以在每个目录中都写一个该目录的Makefile这有利于让我们的Makefile变的更加简洁，不至于把所有东西全部写在一个Makefile中。</p>
<p>列如在子目录subdir目录下有个Makefile文件，来指明这个目录下文件的编译规则。外部总Makefile可以这样写</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">            cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line">其等价于：</span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">            <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>

<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较有利于维护。两个例子意思都是先进入”subdir”目录，然后执行make命令</p>
<p>我们把这个Makefile叫做总控Makefile，总控Makefile的变量可以传递到下级的Makefile中，但是不会覆盖下层Makefile中所定义的变量，除非指定了 “-e”参数。</p>
<p>如果传递变量到下级Makefile中，那么可以使用这样的声明</p>
<p>export</p>
<p>如果不想让某些变量传递到下级Makefile，可以使用</p>
<p>unexport</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable = value</span><br><span class="line">等价于</span><br><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">export</span> variable := value</span><br><span class="line">等价于</span><br><span class="line">variable := value</span><br><span class="line"><span class="keyword">export</span> variable</span><br><span class="line">如果需要传递所有变量，那么只要一个<span class="keyword">export</span>就行了。后面什么也不用跟，表示传递所有变量</span><br></pre></td></tr></table></figure>

<h2 id="10、指定头文件路径"><a href="#10、指定头文件路径" class="headerlink" title="10、指定头文件路径"></a>10、指定头文件路径</h2><p>一般都是通过”<strong>-I</strong>“（大写i）来指定，假设头文件在：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/develop/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>

<p>则可以通过-I指定：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-I/home/develop/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>

<p>将该目录添加到头文件搜索路径中</p>
<p>在Makefile中则可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-I/home/develop/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>

<p>然后在编译的时候，引用CFLAGS即可，如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">yourapp:*.c</span></span><br><span class="line">    gcc <span class="variable">$(CFLAGS)</span> -o yourapp</span><br></pre></td></tr></table></figure>

<h2 id="11、指定库文件路径"><a href="#11、指定库文件路径" class="headerlink" title="11、指定库文件路径"></a>11、指定库文件路径</h2><p>与上面指定头文件类似只不过使用的是”<strong>-L</strong>“来指定</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDFLAGS=-L/usr/lib -L/path/to/your/lib</span><br></pre></td></tr></table></figure>

<p>告诉链接器要链接哪些库文件，使用”<strong>-l</strong>“（小写L）如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBS = -lpthread -liconv</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ZBraveHeart/article/details/123187908">Makefile入门(超详细一文读懂)-CSDN博客</a></p>
</blockquote>
<h2 id="12、简单示例"><a href="#12、简单示例" class="headerlink" title="12、简单示例"></a>12、简单示例</h2><p>现假设这是一个大型项目目录结构：</p>
<p><img src="http://cdn.rhahr.icu/7dec33a3ab6e112db9972dc280b52c4.png"></p>
<p>Main是最终的运行文件（包含main.cpp）其中调用了public与myapi中的内容，此处将public.cpp与myapi.cpp制作为库文件（静态-.a|动态.so）,方便与Main链接，其中每一部分都有各自的makefile：</p>
<p>api：</p>
<p><img src="http://cdn.rhahr.icu/4901f141e46991eb329c4ebfa342edd.png"></p>
<p>tools（public）：</p>
<p><img src="http://cdn.rhahr.icu/25597ea5806ca3c884ac58776343fa0.png"></p>
<p>app（Main）：</p>
<p><img src="http://cdn.rhahr.icu/79bacdea1b75506494df220360de9c3.png"></p>
<p>前两个各自负责制作各自的动静态库文件，app中的main负责编译，当然也可以在项目根目录也就是此处的src中写一个总的makefile来统一调用管理：</p>
<p><img src="http://cdn.rhahr.icu/b27afaf377b4b528cfcc1eb1335f0d2.png"></p>
<p>不过就要注意子目录之间的依赖关系，在这里顺序为先make tools再api最后app，如果先是app的话，就会出现问题，因为还没有制作好库文件就开始编译Main，所以就找不到库文件</p>
<p>处理子目录之间的依赖关系是 Makefile 中一个重要的高级用法，尤其是在大型项目中。以下是一些处理子目录依赖关系的方法：</p>
<ol>
<li><strong>明确声明依赖关系</strong>：在主 Makefile 中，您可以明确指出子目录之间的依赖关系，并按照依赖顺序调用子 Makefile。</li>
<li><strong>使用递归 Make</strong>：通过在主 Makefile 中递归地调用 <code>$(MAKE)</code> 命令，可以构建子目录。如果子目录之间有依赖关系，可以在主 Makefile 中按照依赖顺序排列递归调用。</li>
<li><strong>自动生成依赖关系</strong>：对于 C&#x2F;C++ 项目，您可以使用编译器提供的 <code>-M</code> 选项来自动生成依赖关系文件（如 <code>.d</code> 文件），然后在 Makefile 中包含这些文件来自动处理依赖关系。</li>
<li><strong>使用非递归 Make</strong>：通过在主 Makefile 中包含子目录的 Makefile 片段（如 <code>subdir.mk</code>），可以将整个项目的构建规则集中管理，同时处理依赖关系。</li>
<li><strong>使用高级构建系统</strong>：例如 CMake，它可以帮助管理复杂的依赖关系，并生成适用于不同平台的 Makefile 或其他构建脚本。</li>
<li><strong>VPATH 和 vpath</strong>：使用这些变量可以指定额外的搜索路径，这样 make 就可以在这些路径中查找依赖文件。</li>
<li><strong>条件判断</strong>：在子 Makefile 中使用条件判断来确定是否需要重新构建某些目标，这可以基于文件是否存在或某些变量的值</li>
</ol>

      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rhahr.top/2024/03/26/OpenGL-%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Hah">
      <meta itemprop="description" content="我没有为你伤春悲秋不配有憾事">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HahのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/26/OpenGL-%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">OpenGL</a>
        </h2>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-26 22:00:00" itemprop="dateCreated datePublished" datetime="2024-03-26T22:00:00+08:00">2024-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-15 23:20:36" itemprop="dateModified" datetime="2024-04-15T23:20:36+08:00">2024-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h1><p>opengl就是一个状态机。</p>
<p>C++和OpenGL之间的关系可以这样理解：</p>
<ul>
<li><strong>C++程序</strong>：这是运行在CPU上的程序，它负责执行应用程序逻辑，处理输入输出，以及管理资源等。在OpenGL应用程序中，C++代码用于设置和控制渲染流程，包括调用OpenGL的API来执行具体的图形操作。</li>
<li><strong>OpenGL程序</strong>：这是运行在GPU上的程序，它由一系列着色器组成，这些着色器是用GLSL（OpenGL Shading Language）编写的。这些着色器程序负责处理所有的图形渲染任务，如顶点变换、光照计算、像素着色等。</li>
</ul>
<p>当你在C++的<code>main</code>函数中编写OpenGL相关的代码时，你实际上是在使用C++来控制GPU的行为。以下是整个过程的简化版：</p>
<ol>
<li><strong>编写着色器代码</strong>：在C++程序中，你会编写顶点着色器和片段着色器的源代码。</li>
<li><strong>创建和编译着色器</strong>：通过<code>CreateShader</code>和<code>CompileShader</code>函数，你会创建OpenGL着色器对象，并将你的GLSL代码编译成GPU可以理解的形式。</li>
<li><strong>链接着色器到程序</strong>：编译好的着色器会被附加到一个OpenGL程序对象上，然后这个程序对象会被链接。链接是将不同的着色器合并成一个完整的可执行程序的过程。</li>
<li><strong>验证程序</strong>：链接完成后，程序会被验证，以确保它可以在当前的OpenGL环境中运行。</li>
<li><strong>使用程序</strong>：在C++的<code>main</code>函数中，通过调用<code>glUseProgram</code>，你会告诉GPU使用之前链接好的程序来渲染图形。</li>
</ol>
<p>所以，你可以将C++程序看作是“指挥官”，它指挥GPU做什么；而OpenGL程序就像是在GPU上执行具体任务的“工人”。在C++程序中准备好一切后，通过<code>glUseProgram</code>实际上启动GPU上的OpenGL程序来进行渲染工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CompileShader</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的着色器对象，并返回一个可以引用它的非零值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id = <span class="built_in">glCreateShader</span>(type);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 将C++字符串转换为C风格字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src = source.<span class="built_in">c_str</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//将着色器中的源代码设置为字符串指定的字符串数组中的源代码</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(id,<span class="number">1</span>, &amp;src,<span class="literal">nullptr</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(id);</span><br><span class="line">   </span><br><span class="line">                      </span><br><span class="line">    <span class="comment">// 检查编译是否成功</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(id,GL_COMPILE_STATUS, &amp;result);<span class="comment">//返回着色器对象的参数</span></span><br><span class="line">    <span class="keyword">if</span> (result == GL_FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="comment">// 获取错误消息的长度</span></span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(id, GL_INFO_LOG_LENGTH, &amp;length);</span><br><span class="line">        <span class="comment">// 分配足够的空间来存储错误消息</span></span><br><span class="line">        <span class="type">char</span>* message=(<span class="type">char</span>*)_malloca(length*<span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="comment">// 获取错误消息</span></span><br><span class="line">        <span class="built_in">glGetShaderInfoLog</span>(id,length,&amp;length, message);</span><br><span class="line">        <span class="comment">// 打印错误消息</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to compile &quot;</span>&lt;&lt;(type==GL_VERTEX_SHADER?<span class="string">&quot; vertex &quot;</span> :<span class="string">&quot; fragment &quot;</span>) &lt;&lt; <span class="string">&quot; shader!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 删除着色器并返回0</span></span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回着色器ID</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; vertexShader, <span class="type">const</span> std::string&amp; fragmentShader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个程序对象并返回其ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> program=<span class="built_in">glCreateProgram</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 编译顶点和片段着色器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vs = <span class="built_in">CompileShader</span>(GL_VERTEX_SHADER,vertexShader);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fs = <span class="built_in">CompileShader</span>(GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将着色器附加到程序</span></span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vs);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fs);</span><br><span class="line">    <span class="comment">// 链接程序</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    <span class="comment">// 验证程序</span></span><br><span class="line">    <span class="built_in">glValidateProgram</span>(program);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器对象，它们已经链接到程序中，不再需要了</span></span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(vs);</span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(fs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回程序ID</span></span><br><span class="line">    <span class="keyword">return</span> program;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(<span class="number">640</span>, <span class="number">480</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window&#x27;s context current */</span></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">glewInit</span>()!=GLEW_OK) </span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Error \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">glGetString</span>(GL_VERSION) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建了顶点缓冲对象（VBO）</span></span><br><span class="line">    <span class="type">float</span> position[<span class="number">6</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>,</span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);<span class="comment">//生成1个缓冲区，并将缓冲区id传入buffer</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,buffer);<span class="comment">//将一个名为 buffer 的缓冲区对象绑定到 GL_ARRAY_BUFFER 目标上,指定了缓冲区对象将被用于顶点属性数据的存储,任何对GL_ARRAY_BUFFER的操作都会影响buffer</span></span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER,<span class="number">6</span>*<span class="built_in">sizeof</span>(<span class="type">float</span>), position,GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">//有一些顶点数据存储在 position 中，把这些数据的大小为 6 * sizeof(float) 的部分传输到GPU。多次使用这些数据来绘制，但不会对它们进行修改</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">//启用顶点属性数组</span></span><br><span class="line">    <span class="comment">//为这些数据指定布局,确保了顶点着色器能够正确地理解每个顶点属性的数据结构和存储方式</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(<span class="type">float</span>) * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是着色器源代码是用GL Shader Language (GLSL) 编写的，这是OpenGL的着色器编程语言</span></span><br><span class="line">    <span class="comment">//#version指令用于指定GLSL版本，</span></span><br><span class="line">    <span class="comment">//layout(location = 0)用于指定输入或输出变量的位置，</span></span><br><span class="line">    <span class="comment">//main函数是着色器的入口点</span></span><br><span class="line">    std::string vertexShader = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec4 position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    gl_Position = position;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string fragmentShader = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    color = vec4(1.0, 0.0, 1.0, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shader = <span class="built_in">CreateShader</span>(vertexShader, fragmentShader);</span><br><span class="line">    <span class="built_in">glUseProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">glDrawArrays</span>(GL_TRIANGLES,<span class="number">0</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        glBegin(GL_TRIANGLES);</span></span><br><span class="line"><span class="comment">        glVertex2f( -0.5f, -0.5f );</span></span><br><span class="line"><span class="comment">        glVertex2f(  0.0f,  0.5f );</span></span><br><span class="line"><span class="comment">        glVertex2f(  0.5f, -0.5f );</span></span><br><span class="line"><span class="comment">        glEnd();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glDeleteProgram</span>(shader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OpenGL编程的大体流程涉及多个阶段，每个阶段都有其特定的功能和作用。下面是一个简化的流程概述</p>
<ol>
<li><p><strong>创建OpenGL上下文（Context）</strong>：这是开始任何OpenGL编程之前的必要步骤。上下文是一个巨大的状态机，它保存了OpenGL中的各种状态。</p>
</li>
<li><p>设置视口（Viewport）：这一步涉及到定义一个屏幕上的矩形区域，OpenGL会将最终的图像渲染到这个区域内。</p>
</li>
<li><p>准备着色器和程序（Shaders and Program）：着色器是运行在GPU上的小程序，负责处理图形和像素的渲染。在OpenGL中，至少需要编写并编译顶点和片段着色器，然后将它们链接到一个程序中，这个程序会在渲染过程中使用。</p>
</li>
<li><p>创建缓冲区（Buffers）：在GPU内存中创建缓冲区来存储顶点数据、颜色、纹理坐标等信息。这些数据会在渲染时被着色器程序使用。</p>
</li>
<li><p>加载纹理（Textures）：如果需要的话，加载纹理数据到GPU，以便在渲染中应用到3D对象上。</p>
</li>
<li><p>设置渲染循环（Render Loop）：这是一个持续运行的循环，不断地绘制图像并刷新屏幕。在每次迭代中，会执行清除屏幕、设置摄像机和视图变换、绘制对象等操作。</p>
</li>
<li><p>输入处理（Input Handling）：响应用户输入，如键盘和鼠标事件，以实现交互式图形应用。</p>
</li>
<li><p>清除和绘制（Clear and Draw）：在每次迭代中，清除颜色缓冲区和深度缓冲区，然后根据缓冲区中的数据绘制3D对象。</p>
</li>
<li><p>交换缓冲区（Buffer Swap）：在双缓冲模式下，绘制完成后，将后台缓冲区的内容交换到前台，显示到屏幕上。</p>
</li>
</ol>
<p>关于 <strong>准备着色器和程序（Shaders and Program）</strong>部分。这段代码主要负责以下几个任务：</p>
<ol>
<li><strong>编译着色器（Compile Shaders）</strong>：<code>CompileShader</code>函数接收着色器类型和源代码字符串，创建着色器对象，将源代码与着色器关联，然后编译着色器。如果编译失败，它会打印错误信息并返回0。</li>
<li><strong>链接着色器到程序（Link Shaders to Program）</strong>：<code>CreateShader</code>函数创建一个OpenGL程序对象，调用<code>CompileShader</code>函数分别编译顶点和片段着色器，然后将这两个着色器附加到程序对象上。接着，它链接这个程序对象，使其成为一个完整的可执行程序，最后返回程序对象的ID。</li>
</ol>
<p>这些步骤是设置OpenGL渲染管线的关键部分，确保了GPU能够正确地执行着色器代码来渲染图形。</p>
<p>这里提到的程序是实际上的<strong>GPU上运行的程序</strong>，当main中写好的着色器代码传入CreateShader后编译这些代码，编译完成后将着色器附加到程序相当于是把编译好的代码添加到程序中，然后链接验证程序，最后将这个程序的id作为返回值返回，也就是相当于在CreateShader 和CompileShader 作准备工作，也就是编译着色器代码和创建程序以及两者的链接，然后在main中调用glUseProgram才会实际上执行这个程序</p>
<h2 id="顶点着色器（可编程）"><a href="#顶点着色器（可编程）" class="headerlink" title="顶点着色器（可编程）"></a>顶点着色器（可编程）</h2><p>当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器(Shader)。</strong> </p>
<p>图形渲染管线的第一个部分是**顶点着色器(Vertex Shader)**，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>
<p>它会在GPU上</p>
<ol>
<li>创建内存用于储存我们的顶点数据，</li>
<li>配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。</li>
<li>顶点着色器接着会处理我们在内存中指定数量的顶点</li>
</ol>
<p>通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理2中的这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>
<p>顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。</p>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>计算像素最后的颜色输出</p>
<blockquote>
<p>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p>
</blockquote>
<p>&#x3D;&#x3D;每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。&#x3D;&#x3D;</p>
<h2 id="顶点数组（VAO）"><a href="#顶点数组（VAO）" class="headerlink" title="顶点数组（VAO）"></a>顶点数组（VAO）</h2><p>。。。</p>
<p>在OpenGL中，当你绑定一个<strong>IBO（索引缓冲对象）到GL_ELEMENT_ARRAY_BUFFER</strong>目标，并且此时有一个<strong>VAO（顶点数组对象）</strong>处于绑定状态，IBO的绑定就会被VAO记录下来。这意味着，VAO不仅保存了顶点属性指针的状态，也保存了索引缓冲的绑定状态。</p>
<p>这里是发生这一过程的关键步骤：</p>
<ol>
<li>创建并绑定VAO。</li>
<li>绑定VBO并设置顶点属性指针（这些状态被保存在VAO中）。</li>
<li>绑定IBO到GL_ELEMENT_ARRAY_BUFFER（这个绑定也被保存在VAO中）。</li>
<li>解绑VAO。</li>
</ol>
<p>有一个vao绑定的期间绑定的所有对象都会被保存在vao中，所以在代码中才会出现刚创建vbo的时候进行了一次glBindBuffer(GL_ARRAY_BUFFER, VBO);绑定，在绑定vao之后又进行了一次这个绑定，第二次的绑定相当于是为了将其状态告知vao,</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;glad/glad.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// glfw: initialize and configure</span></span><br><span class="line">	<span class="comment">// ------------------------------</span></span><br><span class="line">	<span class="built_in">glfwInit</span>();</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">	<span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw window creation</span></span><br><span class="line">	<span class="comment">// --------------------</span></span><br><span class="line">	GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">glfwTerminate</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line">	<span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">	<span class="comment">// ---------------------------------------</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> vertices[] = &#123;</span><br><span class="line">	 <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下角</span></span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下角</span></span><br><span class="line">	<span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>    <span class="comment">// 左上角</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index[] = &#123;</span><br><span class="line">		<span class="comment">// 注意索引从0开始!</span></span><br><span class="line">		<span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line">		<span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"></span><br><span class="line">		<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">		<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), &amp;vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> IBO;</span><br><span class="line">	<span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;IBO);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(index), &amp;index, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* vertexshadersource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string">layout (location = 0) in vec3 aPos;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">	vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">	<span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexshadersource, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* fragmentshadersource = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string">out vec4 FragColor;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">	fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">	<span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentshadersource, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个程序对象</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ShaderProgram;</span><br><span class="line">	ShaderProgram = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编译的着色器附加到程序对象上</span></span><br><span class="line">	<span class="built_in">glAttachShader</span>(ShaderProgram, vertexShader);</span><br><span class="line">	<span class="built_in">glAttachShader</span>(ShaderProgram, fragmentShader);</span><br><span class="line">	<span class="built_in">glLinkProgram</span>(ShaderProgram);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//连接后即可删除</span></span><br><span class="line">	<span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">	<span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//激活这个程序对象</span></span><br><span class="line">	<span class="built_in">glUseProgram</span>(ShaderProgram);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。</span></span><br><span class="line"><span class="comment">	就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如</span></span><br><span class="line"><span class="comment">	何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float),0);</span></span><br><span class="line"><span class="comment">//	glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将</span></span><br><span class="line"><span class="comment">	顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，</span></span><br><span class="line"><span class="comment">	并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">	<span class="comment">// 1. 绑定VAO</span></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">	<span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 3. 把索引数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(index), index, GL_STATIC_DRAW);</span><br><span class="line">	<span class="comment">// 4. 设置顶点属性指针</span></span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);<span class="comment">//在这里的第一个参数使vao保存了vbo中数据应该有的状态！！！！！</span></span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// render loop</span></span><br><span class="line">	<span class="comment">// -----------</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// input</span></span><br><span class="line">		<span class="comment">// -----</span></span><br><span class="line">		<span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// render</span></span><br><span class="line">		<span class="comment">// ------</span></span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">glUseProgram</span>(ShaderProgram);</span><br><span class="line">		<span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">		<span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//glBindVertexArray(0);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">		<span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">	<span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">	<span class="built_in">glfwTerminate</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">		<span class="built_in">glfwSetWindowShouldClose</span>(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">	<span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">	<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=188550&auto=1&height=66"></iframe>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hah"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Hah</p>
  <div class="site-description" itemprop="description">我没有为你伤春悲秋不配有憾事</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Jenwein" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jenwein" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rgw127310@gmail.com" title="E-Mail → mailto:rgw127310@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-4 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hah</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">313k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


    </div>

  
      <script>
          new CozeWebSDK.WebChatClient({
            config: {
              bot_id: '7471691871526764559',
            },
            componentProps: {
              title: 'Coze',
            },
          });
      </script>
    
</body>
</html>
